<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>分享之</title>
  
  <subtitle>Share everything</subtitle>
  <link href="https://blog.fenxiangz.com/atom.xml" rel="self"/>
  
  <link href="https://blog.fenxiangz.com/"/>
  <updated>2020-12-23T05:47:04.368Z</updated>
  <id>https://blog.fenxiangz.com/</id>
  
  <author>
    <name>Hassan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HttpClient连接池原理及一次连接时序图</title>
    <link href="https://blog.fenxiangz.com/post/java/util/2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE.html"/>
    <id>https://blog.fenxiangz.com/post/java/util/2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE.html</id>
    <published>2020-12-23T00:00:00.000Z</published>
    <updated>2020-12-23T05:47:04.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HttpClient介绍"><a href="#HttpClient介绍" class="headerlink" title="HttpClient介绍"></a>HttpClient介绍</h1><p>HttpClient是一个实现了http协议的开源Java客户端工具库，可以通过程序发送http请求。</p><h2 id="1-1-HttpClient发送请求和接收响应"><a href="#1-1-HttpClient发送请求和接收响应" class="headerlink" title="1.1 HttpClient发送请求和接收响应"></a>1.1 HttpClient发送请求和接收响应</h2><h3 id="1-1-1-代码示例"><a href="#1-1-1-代码示例" class="headerlink" title="1.1.1 代码示例"></a>1.1.1 <strong>代码示例</strong></h3><p>以Get请求为例，以下代码获得google主页内容并将返回结果打印出来。</p><pre><code>public final static void main(String[] args) throws Exception &#123;    HttpClient httpclient = new DefaultHttpClient();    try &#123;        HttpGet httpget = new HttpGet(&quot;http://www.google.com/&quot;);        System.out.println(&quot;executing request &quot; + httpget.getURI());        // 创建response处理器        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();        String responseBody = httpclient.execute(httpget, responseHandler);        System.out.println(&quot;----------------------------------------&quot;);        System.out.println(responseBody);        System.out.println(&quot;----------------------------------------&quot;);    &#125; finally &#123;        //HttpClient不再使用时，关闭连接管理器以保证所有资源的释放        httpclient.getConnectionManager().shutdown();    &#125;&#125;</code></pre><h3 id="1-1-2-时序图"><a href="#1-1-2-时序图" class="headerlink" title="1.1.2 时序图"></a><strong>1.1.2 时序图</strong></h3><p>httpClient执行一次请求，即运行一次httpClient.execute()方法，时序图如下：</p><p><img src="./2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE/1.jpg"></p><h3 id="1-1-3-时序图说明"><a href="#1-1-3-时序图说明" class="headerlink" title="1.1.3 时序图说明"></a><strong>1.1.3 时序图说明</strong></h3><h4 id="1-1-3-1-时序图编号说明"><a href="#1-1-3-1-时序图编号说明" class="headerlink" title="1.1.3.1  时序图编号说明"></a>1.1.3.1  时序图编号说明</h4><p> 1.1、1.2、1.3等均为操作1的子操作，即：操作1 execute()中又分别调用了操作1.1 createClientConnectionManager()、操作1.2 createClientRequestDirector()以及操作1.3 requestDirector 对象的execute()方法等，以此类推。</p><p> 按时间先后顺序分别编号为1,2,3等，以此类推。</p><h4 id="1-1-3-2-主要类说明"><a href="#1-1-3-2-主要类说明" class="headerlink" title="1.1.3.2 主要类说明"></a>1.1.3.2 主要类说明</h4><p><img src="./2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE/2.jpg"></p><p> 对于图中各对象，httpClient jar包中均提供对应的接口及相应的实现类。</p><p> 图中直接与服务器进行socket通信的是最右端接口OperatedClientConnection某一实现类的对象，图中从右到左进行了层层的封装，最终开发人员直接使用的是接口HttpClient某一实现类的对象进行请求的发送和响应的接收（如2.1.1代码示例）。</p><p> 时序图中各对象所在类关系如下图类图所示（仅列出图中所出现的各个类及方法，参数多的方法省略部分参数，其他类属性和操作请参照源码）：</p><p><strong>1.1.3.2.1 接口OperatedClientConnection</strong></p><p> 该接口对应一个http连接，与服务器端建立socket连接进行通信。</p><p><strong>1.1.3.2.2 接口ManagedClientConnection</strong></p><p> 该接口对一个http连接OperatedClientConnection进行封装，ManagedClientConnection维持一个PoolEntry&lt;HttpRoute, OperatedClientConnection&gt;路由和连接的对应。提供方法获得对应连接管理器，对http连接的各类方法，如建立连接，获得相应，关闭连接等进行封装。</p><p><strong>1.1.3.2.3 接口RequestDirector</strong></p><p> RequestDirector为消息的发送执行者，该接口负责消息路由的选择和可能的重定向，消息的鉴权，连接的分配回收（调用ClientConnectionManager相关方法），建立，关闭等并控制连接的保持。</p><p> 连接是否保持以及保持时间默认原则如下：</p><p><strong>连接是否保持</strong>：客户端如果希望保持长连接，应该在发起请求时告诉服务器希望服务器保持长连接（http 1.0设置connection字段为keep-alive，http 1.1字段默认保持）。根据服务器的响应来确定是否保持长连接，判断原则如下：</p><p>检查返回response报文头的Transfer-Encoding字段，若该字段值存在且不为chunked，则连接不保持，直接关闭。其他情况进入下一步。</p><p>检查返回的response报文头的Content-Length字段，若该字段值为空或者格式不正确（多个长度，值不是整数），则连接不保持，直接关闭。其他情况进入下一步</p><p>检查返回的response报文头的connection字段（若该字段不存在，则为Proxy-Connection字段）值</p><p>如果这俩字段都不存在，则http 1.1版本默认为保持，将连接标记为保持， 1.0版本默认为连接不保持，直接关闭。</p><p>如果字段存在，若字段值为close 则连接不保持，直接关闭；若字段值为keep-alive则连接标记为保持。</p><p><strong>连接保持时间</strong>：连接交换至连接管理时，若连接标记为保持，则将由连接管理器保持一段时间；若连接没有标记为保持，则直接从连接池中删除并关闭entry。连接保持时，保持时间规则如下：</p><p>保持时间计时开始时间为连接交换至连接池的时间。</p><p>保持时长计算规则为：获取keep-alive字段中timeout属性的值，</p><p>若该字段存在，则保持时间为 timeout属性值*1000，单位毫秒。</p><p>若该字段不存在，则连接保持时间设置为-1，表示为无穷。</p><p>响应头日志示例：</p><pre><code>17:59:42.051 [main] DEBUG org.apache.http.headers - &lt;&lt; Keep-Alive: timeout=5, max=10017:59:42.051 [main] DEBUG org.apache.http.headers - &lt;&lt; Connection: Keep-Alive17:59:42.051 [main] DEBUG org.apache.http.headers - &lt;&lt; Content-Type: text/html; charset=utf-817:59:42.062 [main] DEBUG c.ebupt.omp.sop.srmms.SopHttpClient - Connection can be kept alive for 5000 MILLISECONDS</code></pre><p>若需要修改连接的保持及重用默认原则，则需编写子类继承自AbstractHttpClient，分别覆盖其  createConnectionReuseStrategy() 和createConnectionKeepAliveStrategy() 方法。</p><p><strong>1.1.3.2.4 接口ClientConnectionManager</strong></p><p> ClientConnectionManager为连接池管理器，是线程安全的。Jar包中提供的具体实现类有BasicClientConnectionManager和PoolingClientConnectionManager。其中BasicClientConnectionManager只管理一个连接。PoolingClientConnectionManager管理连接池。</p><p> 若有特殊需要，开发人员可自行编写连接管理器实现该接口。</p><p> 连接管理器自动管理连接的分配以及回收工作，并支持连接保持以及重用。连接保持以及重用由RequestDirector进行控制。</p><p><strong>1.1.3.2.5 接口HttpClient</strong></p><p>接口HttpClient为开发人员直接使用的发送请求和接收响应的接口，是线程安全的。jar包中提供的实现类有：AbstractHttpClient, DefaultHttpClient, AutoRetryHttpClient, ContentEncodingHttpClient, DecompressingHttpClient, SystemDefaultHttpClient。其中其他所有类都继承自抽象类AbStractHttpClient，该类使用了门面模式，对http协议的处理进行了默认的封装,包括默认连接管理器，默认消息头，默认消息发送等，开发人员可以覆盖其中的方法更改其默认设置。</p><p>AbstractHttpClient默认设置连接管理器为BasicClientConnectionManager。若要修改连接管理器，则应该采用以下方式之一：</p><p>初始化时，传入连接池，例如：</p><p>ClientConnectionManager connManager  = new PoolingClientConnectionManager();</p><p>HttpClient httpclient = new DefaultHttpClient(connManager);</p><p>编写httpClient接口的实现类，继承自AbstractHttpClient并覆盖其createClientConnectionManager()方法，在方法中创建自己的连接管理器。</p><h4 id="1-1-3-3-方法说明"><a href="#1-1-3-3-方法说明" class="headerlink" title="1.1.3.3 方法说明"></a>1.1.3.3 方法说明</h4><p>createClientConnectionManager()，创建连接池，该方法为protected。子类可覆盖修改默认连接池。</p><p>createClientRequestDirector()，创建请求执行者，该方法为protected。子类可覆盖但一般不需要。</p><p>httpClient中调用1.2方法所创建的请求执行者requestDirector的execute()方法。该方法中依次调用如下方法：</p><p>1.3.1调用连接管理器的requestConnection(route, userToken)方法，该方法调用连接池httpConnPool的lease方法，创建一个Future<HttpPoolEntry>。Futrue用法参见Java标准API。返回clientConnectionRequest。</p><p>1.3.2调用clientConnectionRequest的getConnection(timeout, TimeUnit.MILLISECONDS)方法，该方法负责将连接池中可用连接分配给当前请求，具体如下：</p><p>创建clientConnectionOperator。</p><p>执行1.3.1中创建的Future的任务，该任务获得当前可用的poolEntry&lt;router，OperatedClientConnection&gt;并封装成managedClientConnectionImpl返回。</p><p>1.3.3调用 tryConnect(roureq, context)方法，该方法最终调用OperatedClientConnection的openning方法，与服务器建立socket连接。</p><p>1.3.4调用 tryExecute(roureq, context)方法，该方法最终调用OperatedClientConnection的receiveResponseHeader（）和receiveResponseEntity（）获得服务器响应。</p><p>1.3.5 判断连接是否保持用来重用，若保持，则设置保持时间，并将连接标记为可重用不保持则调用managedClientConnectionImpl的close方法关闭连接，该方法最终调用OperatedClientConnection的close()方法关闭连接。</p><p>最终respose返回至httpClient。</p><p>发送请求的线程需处理当前连接，若已被标记为重用，则交还至连接池管理器；否则，关闭当前连接。（使用响应处理器ResponseHanler）。本次请求结束。</p><h2 id="1-2-HttpClient连接池"><a href="#1-2-HttpClient连接池" class="headerlink" title="1.2 HttpClient连接池"></a>1.2 HttpClient连接池</h2><p>若连接管理器配置为PoolingClientConnectionManager，则httpClient将使用连接池来管理连接的分配，回收等操作。</p><h3 id="1-2-1-连接池结构"><a href="#1-2-1-连接池结构" class="headerlink" title="1.2.1 连接池结构"></a><strong>1.2.1 连接池结构</strong></h3><p>连接池结构图如下，其中：</p><p><img src="./2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE/3.png"></p><p>PoolEntry&lt;HttpRoute, OperatedClientConnection&gt;为路由和连接的对应。</p><p>routeToPool可以多个（图中仅示例两个）；图中各队列大小动态变化，并不相等；</p><p>maxTotal限制的是外层httpConnPool中leased集合和available队列的总和的大小，leased和available的大小没有单独限制；</p><p>同理：maxPerRoute限制的是routeToPool中leased集合和available队列的总和的大小；</p><h3 id="1-2-2-连接池工作原理"><a href="#1-2-2-连接池工作原理" class="headerlink" title="1.2.2 连接池工作原理"></a><strong>1.2.2 连接池工作原理</strong></h3><h4 id="1-2-2-1-分配连接"><a href="#1-2-2-1-分配连接" class="headerlink" title="1.2.2.1  分配连接"></a>1.2.2.1  分配连接</h4><p>分配连接给当前请求包括两部分：1从连接池获取可用连接PoolEntry；2.将连接与当前请求绑定。其中第一部分从连接池获取可用连接的过程为：</p><p>1 获取route对应连接池routeToPool中可用的连接，有则返回该连接。若没有则转入下一步。</p><p>2 若routeToPool和外层HttpConnPool连接池均还有可用的空间，则新建连接，并将该连接作为可用连接返回；否则进行下一步</p><p>3 将当前请求放入pending队列，等待执行。</p><p>4 上述过程中包含各个队列和集合的删除，添加等操作以及各种判断条件，具体流程如下：</p><p><img src="./2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE/4.jpg"></p><h4 id="1-2-2-2-回收连接"><a href="#1-2-2-2-回收连接" class="headerlink" title="1.2.2.2  回收连接"></a>1.2.2.2  回收连接</h4><p>连接用完之后连接池需要进行回收，具体流程如下：</p><p>1 若当前连接标记为重用，则将该连接从routeToPool中的leased集合删除，并添加至available队列，同样的将该请求从外层httpConnPool的leased集合删除，并添加至其available队列。同时唤醒该routeToPool的pending队列的第一个PoolEntryFuture。将其从pending队列删除，并将其从外层httpConnPool的pending队列中删除。</p><p>2 若连接没有标记为重用，则分别从routeToPool和外层httpConnPool中删除该连接，并关闭该连接。</p><h4 id="1-2-2-3-过期和空闲连接的关闭"><a href="#1-2-2-3-过期和空闲连接的关闭" class="headerlink" title="1.2.2.3  过期和空闲连接的关闭"></a>1.2.2.3  过期和空闲连接的关闭</h4><p>连接如果标记为保持时，将由连接管理器保持一段时间，此时连接可能出现的情况是：</p><p>连接处于空闲状态，时间已超过连接保持时间</p><p>连接处于空闲状态，时间没有超过连接保持时间</p><p>以上两种情况中，随时都会出现连接的服务端已关闭的情况，而此时连接的客户端并没有阻塞着去接受服务端的数据，所以客户端不知道连接已关闭，无法关闭自身的socket。</p><p>连接池提供的方法：</p><p>首先连接池在每个请求获取连接时，都会在RouteToPool的available队列获取Entry并检测此时Entry是否已关闭或者已过期，若是则关闭并移除该Entry。</p><p>closeExpiredConnections()该方法关闭超过连接保持时间的空闲连接。</p><p>closeIdleConnections(timeout,tunit)该方法关闭空闲时间超过timeout的连接，空闲时间从交还给连接管理器时开始，不管是否已过期超过空闲时间则关闭。所以Idle时间应该设置的尽量长一点。</p><p>以上两个方法连接关闭的过程均是：</p><p>关闭entry;</p><p>RouteToPool中删除当前entry。先删available队列中的，如果没有，再删除leased集合中的。</p><p>httpConnPool中删除当前entry。删除过程同RouteToPool</p><p>唤醒阻塞在RouteToPool中的第一个future。</p><h2 id="1-3-相关原理说明"><a href="#1-3-相关原理说明" class="headerlink" title="1.3 相关原理说明"></a>1.3 相关原理说明</h2><h3 id="1-3-1-Tcp连接的关闭"><a href="#1-3-1-Tcp连接的关闭" class="headerlink" title="1.3.1 Tcp连接的关闭"></a>1.3.1 <strong>Tcp连接的关闭</strong></h3><p>Http连接实际上在传输层建立的是tcp连接，最终利用的是socket进行通信。http连接的保持和关闭实际上都和TCP连接的关闭有关。TCP关闭过程如下图：</p><p><img src="./2020-12-23_HttpClient%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE/5.png"></p><p>说明：</p><p> TCP连接程序中使用socket编程进行实现。一条TCP是一条抽象的连接通道，由通信双方的IP+端口号唯一确定，两端分别通过socket实例进行操作，一个socket实例包括一个输入通道和输出通道，一端的输出通道为另一端的输入通道。</p><p> Tcp连接的关闭是连接的两端分别都需要进行关闭（调用close(socket)，该函数执行发送FIN，等待ACK等图示操作）。实际上没有客户端和服务端的区别，只有主动关闭和被动关闭的区别。对于上层的其http连接，实际上也就是http服务端主动关闭或者http客户端主动关闭，而不管谁主动，最终服务端和客户端都需要调用close(socket)关闭连接。</p><p> 主动关闭的一端A调用了close函数之后，若另一端B并没有阻塞着等待着数据，就无法检测到连接的A端已关闭，就没法关闭自身的socket，造成资源的浪费。http连接都是一次请求和响应，之后便交回给连接管理池，因此在http连接池中应当能够移除已过期或者空闲太久的连接，因为他们可能已经被服务器端关闭或者客户端短期内不再使用。</p><p> TIME_WAIT状态：</p><p><strong>可靠地实现TCP全双工连接的终止</strong></p><p>在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，被动关闭端将重发最终的FIN，因此主动关闭端必须维护状态信息允许它重发最终的ACK。如果不维持这个状态信息，那么主动关闭端将发送RST分节（复位），被动关闭端将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。因而，要实现TCP全双工连接的正常终止，主动关闭的客户端必须维持状态信息进入TIME_WAIT状态。</p><p><strong>允许老的重复分节在网络中消逝</strong></p><p>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost duplicate。在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。</p><h1 id="HttpClient最佳实践"><a href="#HttpClient最佳实践" class="headerlink" title="HttpClient最佳实践"></a>HttpClient最佳实践</h1><h2 id="2-1-总原则"><a href="#2-1-总原则" class="headerlink" title="2.1 总原则"></a>2.1 总原则</h2><h3 id="2-1-1-版本"><a href="#2-1-1-版本" class="headerlink" title="2.1.1 版本"></a>2.1.1 <strong>版本</strong></h3><p>原Commons HttpClient：3.x不再升级维护，使用Apache HttpComponents的HttpClient代替。Pom文件修改如下：</p><p>1 原maven依赖：</p><pre><code>&lt;dependency&gt;       &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;       &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;       &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2 替换为：</p><pre><code>&lt;dependency&gt;       &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;       &lt;artifactId&gt;httpclient&lt;/artifactId&gt;       &lt;version&gt;4.2.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2-1-2-使用http连接池管理器"><a href="#2-1-2-使用http连接池管理器" class="headerlink" title="2.1.2 使用http连接池管理器"></a><strong>2.1.2 使用http连接池管理器</strong></h3><p> 编写类继承自DefaultHttpClient(以下假设为SopHttpClient)，覆盖其createClientConnectionManager()方法，方法中创建连接池管理器。</p><p> 开启一个线程（假设为IdleConnectionMonitorThread）用来清除连接池中空闲和过期的连接。</p><h3 id="2-1-3-保持HttpClient单例"><a href="#2-1-3-保持HttpClient单例" class="headerlink" title="2.1.3 保持HttpClient单例"></a><strong>2.1.3 保持HttpClient单例</strong></h3><p>Spring配置中使用默认scope，即单例模式，其他类使用时由Spring配置进行依赖注入，不要使用new方法。SopHttpClient应该提供方法destroy()并配置在Spring销毁该bean前调用，destory()方法中关闭对应连接池管理器和监控线程IdleConnectionMonitorThread。</p><h3 id="2-1-4-异常处理机制（请求和响应）："><a href="#2-1-4-异常处理机制（请求和响应）：" class="headerlink" title="2.1.4 异常处理机制（请求和响应）："></a><strong>2.1.4 异常处理机制（请求和响应）：</strong></h3><p>编写类实现接口HttpRequestRetryHandler（可参照默认实现DefaultHttpRequestRetryHandler），并覆盖AbstractHttpClient中的createHttpRequestRetryHandler()方法创建新的重试处理机制。</p><h3 id="2-1-5-参数可配置"><a href="#2-1-5-参数可配置" class="headerlink" title="2.1.5 参数可配置"></a><strong>2.1.5 参数可配置</strong></h3><p>各参数（连接池默认ip、端口和大小等，超时时间等）尽量都集中在SopHttpClient类中，设置为由Spring进行统一配置，且提供接口在程序中修改。</p><h3 id="2-1-6-保证连接交回至连接池管理器"><a href="#2-1-6-保证连接交回至连接池管理器" class="headerlink" title="2.1.6 保证连接交回至连接池管理器"></a><strong>2.1.6 保证连接交回至连接池管理器</strong></h3><h4 id="2-1-6-1-方式"><a href="#2-1-6-1-方式" class="headerlink" title="2.1.6.1  方式"></a>2.1.6.1  方式</h4><p>HttpResponse response = httpclient.execute(httpMethod);</p><p>HttpEntity entity = response.getEntity();</p><p>这两段代码返回的entity是HttpEntity的实现类BasicManagedEntity。此时与本次请求关联的连接尚未归还至连接管理器。需要调用以下两条语句：</p><p>InputStream instream = entity.getContent();//获得响应具体内容</p><p>//处理响应：代码省略</p><p>instream.close();//关闭输入流同时会将连接交回至连接处理器</p><h4 id="2-1-6-2-使用默认的响应处理器BasicResponseHandler"><a href="#2-1-6-2-使用默认的响应处理器BasicResponseHandler" class="headerlink" title="2.1.6.2  使用默认的响应处理器BasicResponseHandler"></a>2.1.6.2  使用默认的响应处理器BasicResponseHandler</h4><p> HttpClient Jar包中提供BasicResponseHandler。<strong>如果返回的类型能确定需要解码为String类型的话，推荐使用该响应处理器。</strong></p><p> 该处理器解码http连接响应字节流为String类型，对返回码&gt;=300的响应进行了异常封装，并能够保证连接交还给连接池管理器。</p><p> 该处理器将字节解码为字符的过程依次如下：</p><p>1 如果响应http报文Head部分由指定的charset，则使用该charset进行解码，否则进行下一步。例如使用UTF-8解码以下响应：</p><p>17:59:42.051 [main] DEBUG org.apache.http.headers - &lt;&lt; Content-Type: text/html; charset=utf-8</p><p>2 如果响应报文未执行charset，则使用传入EntityUntils.toString()时指定的charset进行解码。否则进行下一步</p><p>3 使用ISO-8859-1进行解码。</p><h4 id="2-1-6-3-BasicManagedEntity关闭连接池管理器原理"><a href="#2-1-6-3-BasicManagedEntity关闭连接池管理器原理" class="headerlink" title="2.1.6.3  BasicManagedEntity关闭连接池管理器原理"></a>2.1.6.3  BasicManagedEntity关闭连接池管理器原理</h4><p><strong>2.1.6.3.1</strong></p><p>BasicManagedEntity实现了三个接口:HttpEntity，ConnectionReleaseTrigger, EofSensorWatcher。</p><p>调用BasicManagedEntity的getContent方法时，实际上初始化了EofSensorInputStream的实例，并将BasicManagedEntity当前对象自身作为EofSensorWatcher传入。</p><pre><code>//BasicManagedEntity类的继承体系，HttpEntityWrapper实现了接口HttpEntitypublic class BasicManagedEntity extends HttpEntityWrapper         implements ConnectionReleaseTrigger, EofSensorWatcher</code></pre><p>BasicManagedEntity的getContent方法：</p><pre><code>@Overridepublic InputStream getContent() throws IOException &#123;    return new EofSensorInputStream(wrappedEntity.getContent(), this);&#125;// EofSensorInputStream构造函数声明public EofSensorInputStream(final InputStream in,final EofSensorWatcher watcher);</code></pre><p><strong>2.1.6.3.2</strong> </p><p>调用EofSensorInputStream的close方法，该方法调用自身的checkClose()方法，checkClose()方法中调入了传入的EofSensorWatcher watcher的streamClosed()方法并关闭输入流，由于上一步骤中实际传入的watcher是BasicManagedEntity的实例，因此实际上调用的是BasicManagedEntity的streamClose()方法。</p><pre><code>//close方法@Overridepublic void close() throws IOException &#123;    // tolerate multiple calls to close()    selfClosed = true;    checkClose();&#125;//checkClose方法protected void checkClose() throws IOException &#123;    if (wrappedStream != null) &#123;        try &#123;            boolean scws = true; // should close wrapped stream?            if (eofWatcher != null)                scws = eofWatcher.streamClosed(wrappedStream);            if (scws)                wrappedStream.close();        &#125; finally &#123;            wrappedStream = null;        &#125;    &#125;&#125;</code></pre><p><strong>2.1.6.3.3</strong> </p><p>BasicManagedEntity的streamClose()方法中将连接交回至连接池管理器。</p><pre><code>public boolean streamClosed(InputStream wrapped) throws IOException &#123;    try &#123;        if (attemptReuse &amp;&amp; (managedConn != null)) &#123;            boolean valid = managedConn.isOpen();            // this assumes that closing the stream will            // consume the remainder of the response body:            try &#123;                wrapped.close();                managedConn.markReusable();            &#125; catch (SocketException ex) &#123;                if (valid) &#123;                    throw ex;                &#125;            &#125;        &#125;    &#125; finally &#123;        releaseManagedConnection();    &#125;    return false;</code></pre><p>}</p><h3 id="2-1-7-其他"><a href="#2-1-7-其他" class="headerlink" title="2.1.7 其他"></a><strong>2.1.7 其他</strong></h3><p>HttpClient 提供了非常灵活的架构，同时提供了很多接口，需要修改时，找到对应接口和默认实现类，参照默认实现类进行修改即可（或继承默认实现类，覆盖其对应方法）。通常需要更改的类有AbstractHttpClient和各种handler以及Strategy</p><p>文章转载自：<a href="https://developer.aliyun.com/article/11893">https://developer.aliyun.com/article/11893</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HttpClient介绍&quot;&gt;&lt;a href=&quot;#HttpClient介绍&quot; class=&quot;headerlink&quot; title=&quot;HttpClient介绍&quot;&gt;&lt;/a&gt;HttpClient介绍&lt;/h1&gt;&lt;p&gt;HttpClient是一个实现了http协议的开源Java客户端工具库，可以通过程序发送http请求。&lt;/p&gt;
&lt;h2 id=&quot;1-1-HttpClient发送请求和接收响应&quot;&gt;&lt;a href=&quot;#1-1-HttpClient发送请求和接收响应&quot; class=&quot;headerlink&quot; title=&quot;1.1 HttpClient发送请求和接收响应&quot;&gt;&lt;/a&gt;1.1 HttpClient发送请求和接收响应&lt;/h2&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/java/basic/java_logo.png" type="image"/>
    
    
    <category term="RPC" scheme="https://blog.fenxiangz.com/categories/RPC/"/>
    
    
    <category term="Java" scheme="https://blog.fenxiangz.com/tags/Java/"/>
    
    <category term="HttpClient" scheme="https://blog.fenxiangz.com/tags/HttpClient/"/>
    
  </entry>
  
  <entry>
    <title>Java Synchronized 原理图</title>
    <link href="https://blog.fenxiangz.com/post/java/basic/2012-12-22_Java_Synchronized%E5%8E%9F%E7%90%86%E5%9B%BE.html"/>
    <id>https://blog.fenxiangz.com/post/java/basic/2012-12-22_Java_Synchronized%E5%8E%9F%E7%90%86%E5%9B%BE.html</id>
    <published>2020-12-22T00:00:00.000Z</published>
    <updated>2020-12-21T16:38:03.850Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./2012-12-22_Java_Synchronized%E5%8E%9F%E7%90%86%E5%9B%BE/11.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;./2012-12-22_Java_Synchronized%E5%8E%9F%E7%90%86%E5%9B%BE/11.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    <content src="https://blog.fenxiangz.com/images/java/basic/java_logo.png" type="image"/>
    
    
    <category term="Java 基础" scheme="https://blog.fenxiangz.com/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://blog.fenxiangz.com/tags/Java/"/>
    
    <category term="同步" scheme="https://blog.fenxiangz.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用JS脚本批量去除文件名中部分关键字</title>
    <link href="https://blog.fenxiangz.com/post/util/2020-12-20_%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8D%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
    <id>https://blog.fenxiangz.com/post/util/2020-12-20_%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8D%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97.html</id>
    <published>2020-12-20T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.984Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> KEY_WORD = <span class="string">&#x27;要去掉的关键字&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> PATH = <span class="string">&#x27;/home/指定目录/&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历目录得到文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> files = fs.readdirSync(path);</span><br><span class="line"> </span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">        f = path + <span class="string">&#x27;/&#x27;</span> + file;</span><br><span class="line">        <span class="keyword">if</span> (fs.statSync(f).isFile()) &#123;</span><br><span class="line">            callback(path, file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目录递归处理</span></span><br><span class="line">            run(f, callRename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改文件名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rename</span>(<span class="params">oldPath, newPath</span>) </span>&#123;</span><br><span class="line">    fs.rename(oldPath, newPath, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callRename</span>(<span class="params">path, fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldPath = path + <span class="string">&#x27;/&#x27;</span> + fileName; <span class="comment">// 源文件路径</span></span><br><span class="line">    <span class="keyword">let</span> newPath = path + <span class="string">&#x27;/&#x27;</span> + fileName.replace(KEY_WORD, <span class="string">&#x27;&#x27;</span>); <span class="comment">// 新文件全路径</span></span><br><span class="line">    <span class="built_in">console</span>.log(newPath);</span><br><span class="line">    rename(oldPath, newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行入口</span></span><br><span class="line">run(PATH, callRename);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    <category term="资源导航" scheme="https://blog.fenxiangz.com/categories/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文件名批量修改" scheme="https://blog.fenxiangz.com/tags/%E6%96%87%E4%BB%B6%E5%90%8D%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>原来 8 张图，就可以搞懂「零拷贝」了</title>
    <link href="https://blog.fenxiangz.com/post/linux/2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86.html"/>
    <id>https://blog.fenxiangz.com/post/linux/2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86.html</id>
    <published>2020-12-16T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.979Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://xie.infoq.cn/article/8d19a4c691918d313e60296d7">https://xie.infoq.cn/article/8d19a4c691918d313e60296d7</a></p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/1.jpeg"></p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/2.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。</p><p>这次，我们就以「文件传输」作为切入点，来分析 I/O 工作方式，以及如何优化传输文件的性能。</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/3.png"></p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="为什么要有-DMA-技术"><a href="#为什么要有-DMA-技术" class="headerlink" title="为什么要有 DMA 技术?"></a>为什么要有 DMA 技术?</h3><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li><p>CPU 发出对应的指令给磁盘控制器，然后返回；</p></li><li><p>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；</p></li><li><p>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</p></li></ul><p>为了方便你理解，我画了一副图：</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/4.png"></p><p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p><p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p><p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<em>直接内存访问（Direct Memory Access）</em> 技术。</p><p>什么是 DMA 技术？简单理解就是，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</p><p>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/5.png"></p><p>具体过程：</p><ul><li><p>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</p></li><li><p>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</p></li><li><p>DMA 进一步将 I/O 请求发送给磁盘；</p></li><li><p>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</p></li><li><p>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；</p></li><li><p>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</p></li><li><p>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</p></li></ul><p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p><p>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。</p><hr><h3 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h3><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">read(file, tmp_buf, len);</span><br><span class="line"></span><br><span class="line">write(socket, tmp_buf, len);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/6.png"></p><p>首先，期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是  <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><p>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</p></li><li><p>第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</p></li><li><p>第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</p></li><li><p>第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</p></li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。</p><hr><h3 id="如何优化文件传输的性能？"><a href="#如何优化文件传输的性能？" class="headerlink" title="如何优化文件传输的性能？"></a>如何优化文件传输的性能？</h3><blockquote><p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p></blockquote><p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>所以，要想减少上下文切换到次数，就要减少系统调用的次数。</p><blockquote><p>再来看看，如何减少「数据拷贝」的次数？</p></blockquote><p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p><p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的。</p><hr><h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li><p>mmap + write</p></li><li><p>sendfile</p></li></ul><p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buf &#x3D; mmap(file, len);</span><br><span class="line"></span><br><span class="line">write(sockfd, buf, len);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/7.png"></p><p>具体过程如下：</p><ul><li><p>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</p></li><li><p>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</p></li><li><p>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</p></li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p> 在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_tsendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/8.png"></p><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ethtool -k eth0 | grep scatter-gather</span><br><span class="line"></span><br><span class="line">scatter-gather: on</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li><p>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</p></li><li><p>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</p></li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/9.png"></p><p>这就是所谓的<em>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</em>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p><p>所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。</p><h4 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h4><p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p><p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <code>transferTo</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Overridepublic</span><br><span class="line"></span><br><span class="line">longtransferFrom(FileChannel fileChannel, long position, long count)throws IOException &#123; </span><br><span class="line"></span><br><span class="line">return fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 Linux 系统支持 <code>sendfile()</code> 系统调用，那么 <code>transferTo()</code> 实际上最后就会使用到 <code>sendfile()</code> 系统调用函数。</p><p>曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，你可以看到下面这张测试数据图，使用了零拷贝能够缩短 <code>65%</code> 的时间，大幅度提升了机器传输数据的吞吐量。</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/10.png"></p><p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    sendfile on</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sendfile 配置的具体意思: </p><ul><li><p>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</p></li><li><p>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</p></li></ul><p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p><hr><h3 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h3><p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<em>磁盘高速缓存（PageCache）</em>。</p><p> 由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p><p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p><p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p><p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p><p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 PageCache 来缓存最近被访问的数据，当空间不足时淘汰最久未被访问的缓存。</p><p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p><p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，PageCache 使用了「预读功能」。</p><p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p><p>所以，PageCache 的优点主要是两个：</p><ul><li><p>缓存最近被访问的数据；</p></li><li><p>预读功能；</p></li></ul><p>这两个做法，将大大提高读写磁盘的性能。</p><p>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</p><p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p><p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p><ul><li><p>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</p></li><li><p>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</p></li></ul><p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p><hr><h3 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h3><p>那针对大文件的传输，我们应该使用什么方式呢？</p><p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/11.png"></p><p>具体过程：</p><ul><li><p>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</p></li><li><p>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</p></li><li><p>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</p></li></ul><p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p><p><img src="./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/12.png"></p><p>它把读操作分为两部分：</p><ul><li><p>前半部分，内核向磁盘发起读请求，但是可以不等待数据就位就可以返回，于是进程此时可以处理其他任务；</p></li><li><p>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据；</p></li></ul><p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p><p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p><p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p><p>于是，在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。</p><p>直接 I/O 应用场景常见的两种：</p><ul><li><p>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</p></li><li><p>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</p></li></ul><p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：</p><ul><li><p>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「合并」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</p></li><li><p>内核也会「预读」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</p></li></ul><p>于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。</p><p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p><ul><li><p>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</p></li><li><p>传输小文件的时候，则使用「零拷贝技术」；</p></li></ul><p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location &#x2F;video&#x2F; &#123; </span><br><span class="line"></span><br><span class="line">    sendfile on; </span><br><span class="line"></span><br><span class="line">    aio on; </span><br><span class="line"></span><br><span class="line">    directio 1024m; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当文件大小大于 <code>directio</code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p><p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p><p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p><p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（<code>sendfile</code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p><p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。</p><p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。</p><p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p><p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p><p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;https://xie.infoq.cn/article/8d19a4c691918d313e60296d7&quot;&gt;https://xie.infoq.cn/article/8d19a4c691918d313e60296d7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/1.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./2020-12-16_%E5%8E%9F%E6%9D%A58%E5%BC%A0%E5%9B%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E6%87%82%E3%80%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%8D%E4%BA%86/2.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/linux.png" type="image"/>
    
    
    <category term="IO" scheme="https://blog.fenxiangz.com/categories/IO/"/>
    
    
    <category term="IO" scheme="https://blog.fenxiangz.com/tags/IO/"/>
    
    <category term="零拷贝" scheme="https://blog.fenxiangz.com/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="异步IO" scheme="https://blog.fenxiangz.com/tags/%E5%BC%82%E6%AD%A5IO/"/>
    
    <category term="直接IO" scheme="https://blog.fenxiangz.com/tags/%E7%9B%B4%E6%8E%A5IO/"/>
    
  </entry>
  
  <entry>
    <title>Redis存储优化</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/Redis/2020_12_08_Redis%E6%B8%85%E7%90%86%E6%96%B9%E6%B3%95.html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/Redis/2020_12_08_Redis%E6%B8%85%E7%90%86%E6%96%B9%E6%B3%95.html</id>
    <published>2020-12-08T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bigkeys-扫描"><a href="#bigkeys-扫描" class="headerlink" title="bigkeys 扫描"></a>bigkeys 扫描</h2><p><code>/redis-cli -h  localhost  -p 6379 --bigkeys</code></p><h2 id="全量扫描"><a href="#全量扫描" class="headerlink" title="全量扫描"></a>全量扫描</h2><p>通过以下脚本扫描 Redis中的全量Keys， Keys存量较大的情况下，可以分多次优化处理。<br>比如：keys.txt文件收集到100MB时，停止，先优化一部分；优化完，再扫描，再优化。<br>脚本如下，注意确保脚本在 ./redis-cli 统计目录，或修改为绝对 redis-cli 绝对路径执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#redis主机IP</span></span></span><br><span class="line">host=$1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#redis端口</span></span></span><br><span class="line">port=$2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#key模式</span></span></span><br><span class="line">pattern=$3</span><br><span class="line">db=$4</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#游标</span></span></span><br><span class="line">cursor=0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#退出信号</span></span></span><br><span class="line">signal=0</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;&gt;~/keys.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#循环获取key并删除</span></span></span><br><span class="line">while [ $signal -ne 1 ]</span><br><span class="line">    do</span><br><span class="line"></span><br><span class="line">        ##将redis scan得到的结果赋值到变量</span><br><span class="line">        re=$(./redis-cli -h $host -p $port -c -n $db scan $cursor count 1000 match $pattern)</span><br><span class="line"></span><br><span class="line">        ##以换行作为分隔符</span><br><span class="line">        IFS=$&#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">        ##转成数组</span><br><span class="line">        arr=($re)</span><br><span class="line"></span><br><span class="line">        ##第一个元素是游标值</span><br><span class="line">        cursor=$&#123;arr[0]&#125;</span><br><span class="line"></span><br><span class="line">        ##打印数组</span><br><span class="line">        len=$&#123;#arr[*]&#125;</span><br><span class="line">        for ((i=1;i&lt;len;i++))</span><br><span class="line">                do</span><br><span class="line">                   a=$&#123;arr[i]&#125;</span><br><span class="line">                   echo $a &gt;&gt; ~/keys.txt</span><br><span class="line">                done</span><br><span class="line"></span><br><span class="line">        ##游标为0表示没有key了</span><br><span class="line">        if [ $cursor -eq 0 ];then</span><br><span class="line">            signal=1</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">echo &#x27;done&#x27;</span><br></pre></td></tr></table></figure><p>得到 keys.txt 文件后，使用 awk, uniq, sort 等命令进行归并排序，脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort keys.txt &gt;&gt; keys-sort.txt</span><br><span class="line">cat keys-sort.txt | awk -F &#x27;:&#x27; &#x27;&#123;print $1&quot;:&quot;$2&quot;:&quot;$3&#125;&#x27; |  uniq -c | sort -rn  </span><br></pre></td></tr></table></figure><p>分隔符和打印内容可以按实际情况调节输出，便于阅读。输出结果后，便可定位具体的Key进行优化了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;bigkeys-扫描&quot;&gt;&lt;a href=&quot;#bigkeys-扫描&quot; class=&quot;headerlink&quot; title=&quot;bigkeys 扫描&quot;&gt;&lt;/a&gt;bigkeys 扫描&lt;/h2&gt;&lt;p&gt;&lt;code&gt;/redis-cli -h  localhost  -p 6379 --bigkeys&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;全量扫描&quot;&gt;&lt;a href=&quot;#全量扫描&quot; class=&quot;headerlink&quot; title=&quot;全量扫描&quot;&gt;&lt;/a&gt;全量扫描&lt;/h2&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/Redis.png" type="image"/>
    
    
    <category term="Redis" scheme="https://blog.fenxiangz.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.fenxiangz.com/tags/Redis/"/>
    
    <category term="优化" scheme="https://blog.fenxiangz.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>猴子管理法则</title>
    <link href="https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-11-28_%E7%8C%B4%E5%AD%90%E7%AE%A1%E7%90%86%E6%B3%95%E5%88%99.html"/>
    <id>https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-11-28_%E7%8C%B4%E5%AD%90%E7%AE%A1%E7%90%86%E6%B3%95%E5%88%99.html</id>
    <published>2020-11-28T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.989Z</updated>
    
    <content type="html"><![CDATA[<p>很多管理者往往遇到这样的情况，当你听完下属员工的工作汇报后发现事情并没有得到彻底解决，而原本计划好今天要做的工作也因此耽误了不少时间。</p><p>猴子管理法则的目的在于帮助经理人确定由适当人选在适当的时间，用正确的方法做正确的事。</p><p>身为经理人要能够让员工去抚养自己的“猴子”，你也有足够的时间去做规划、协调、创新等重要工作。</p><h3 id="责任是一只猴子"><a href="#责任是一只猴子" class="headerlink" title="责任是一只猴子"></a><strong>责任是一只猴子</strong></h3><p>这其中的关键在于，本来该下属员工自行完成的工作，因为逃避责任的缘故， 交由上司处理。</p><p>每个下属都有自己的猴子，如果都交由上司管理，显然，管理者自己的时间将变得十分不够用。</p><p>当你一旦接收部属所该看养的猴子，他们就会以为是你自己要这些猴子的， 因此，你收的愈多，他们给的就愈多。</p><p>于是你饱受堆积如山、永远处理不完的问题所困扰，甚至没有时间照顾自己的猴子，努力将一些不该摆在第一位的事情做得更有效率，平白让自己的成效打了折扣。</p><p>经理人应该将时间投资在最重要的管理层面上，而不是养一大堆别人的猴子。</p><p>当然，这个法则只能运用在有生存价值的猴子身上，不该存活的猴子，就狠心把他杀了吧！</p><h3 id="“猴子”-问题"><a href="#“猴子”-问题" class="headerlink" title="“猴子”=问题"></a><strong>“猴子”=问题</strong></h3><p>你是问题处理高手吗？假如你的下属崇拜你，你或许会相当高兴。但那以后， 他几乎每件事都向你请示，你会觉得如何呢？你是否会感觉自己的时间不够用了，并因此开始检查自己的管理是不是出了什么问题呢？</p><p>有一天，你的一位下属在办公室的走廊与你不期而遇，下属停下脚步问：“老板，有一个问题，我一直想向你请示该怎么办。”</p><p>此时，下属的身上有一只需要照顾的 “猴子”，接下来他如此这般将问题汇报了一番。尽管你有要事在身，但还是不太好意思让急切地想把事情办好的下属失望。</p><p>你非常认真地听着……慢慢地，“猴子”的一只脚已悄悄搭在你的肩膀上。你一直在认真倾听，并不时点头，几分钟后，你对他说这是一个非常不错的问题，很想先听听他的意见，并问：“你觉得该怎么办？”</p><p>“老板，我就是因为想不出办法，才不得不向你求援的呀。”</p><p>“不会吧，你一定能找到更好的方法。”你看了看手表，“这样吧，我现在正好有急事，明天下午四点后我有空，到时你拿几个解决方案来我们一起讨论。”</p><p>告别前，你没有忘记补充一句：“你不是刚刚受过‘头脑风暴’训练吗？实在想不出，找几个搭档来一次‘头脑风暴’，明天我等你们的答案。”</p><p>“猴子”悄悄收回了搭在你身上的那只脚，继续留在此下属的肩膀上。</p><p>第二天，下属如约前来。从脸上表情看得出，他似乎胸有成竹：“老板，按照你的指点，我们已有了 5个觉得还可以的方案，只是不知道哪一个更好，现在就是请你拍板了。”</p><p>即使你一眼就已看出哪一个更好，也不要急着帮他作出决定。不然，他以后对你会有依赖，或者万一事情没办好，他一定会说：“老板，这不能怪我，我都是按照你的意见去办的。”</p><h3 id="关于作决定，记住以下准则"><a href="#关于作决定，记住以下准则" class="headerlink" title="关于作决定，记住以下准则"></a><strong>关于作决定，记住以下准则</strong></h3><p>1、该下属做决定的事，一定要让他们自己学着做决定；</p><p>2、做决定意味着为自己的决定负责任。不想做决定，常常是潜意识里他不想承担责任；</p><p>3、下属不思考问题、不习惯做决定的根源一般有两个：<br>其一是有“托付思想”，依赖上司或别人，这样的下属不堪大用；<br>其二是上司习惯代替下属做决定或喜欢享受别人听命于自己的成就感，这样的上司以及他所带领的团队难以胜任复杂的任务；</p><p>4、让下属自己想办法，做决定，就是训练下属独立思考问题的能力和勇于承担责任的行事风格。</p><p>对话还在继续。你兴奋地说：“太棒了，这么多好方案。你认为，相比较而言哪一个方案更好？”<br>“我觉得 A 方案更好一些。”<br>“这的确是一个不错的方案，不过你有没有考虑过万一出现这种情况，该怎么办？”<br>“噢，有道理，看来用 E 方案更好。”<br>“这方案真的也很好，可是，你有没有想过……” “我明白，应该选择 B 方案。”<br>“非常好，我的想法跟你一样，我看就按你的意见去办吧。”</p><p>凭你的经验，其实你早就知道应该选择 B 方案，你不直接告诉他的目的是想借此又多赢得一次训练部属的机会。</p><p>训练是一个虽慢反快的过程，训练的“慢”是为了将来更快。你这样做的好处不言而喻：</p><ul><li>1、打断下属负面的“依赖”神经链。</li><li>2、训练了下属分析问题、全面思考问题的能力。</li><li>3、让下属产生信心与成就感。他会觉得自己居然也有解决复杂问题的能力。越来越有能力的下属能越来越胜任更重要的任务。</li><li>4、激发下属的行动力。</li><li>5、你将因此不必照看下属的“猴子”而腾出更多的精力去照看自己的“猴子”。</li></ul><h3 id="管理艺术的-5个严格规则"><a href="#管理艺术的-5个严格规则" class="headerlink" title="管理艺术的 5个严格规则"></a><strong>管理艺术的 5个严格规则</strong></h3><p>规则一：“猴子”要么被喂养，要么被杀死。<br>否则，他们会饿死，而经理则要将大量宝贵时间浪费在尸体解剖或试图使他们复活上。</p><p>规则二：“猴子”的数量必须被控制在经理有时间喂养的最大数额以下。下属会尽量找时间喂养猴子，但不应比这更多。饲养一只正常状况的猴子时间不应超过 5～15 分钟。</p><p>规则三：“猴子”只能在约定的时间喂养。</p><p>经理无须四处寻找饥饿的“猴子”，抓到一只喂一只。</p><p>规则四：“猴子”应面对面或通过电话进行喂养，而不要通过邮件。文档处理可能会增加喂养程序，但不能取代喂养。</p><p>规则五：应确定每只“猴子”下次的喂养时间。<br>这可以在任何时间由双方修改并达成一致，但不要模糊不清。否则，“猴子”或者会饿死或者最终回到经理的背上。</p><h3 id="“猴子管理”理论的启示"><a href="#“猴子管理”理论的启示" class="headerlink" title="“猴子管理”理论的启示"></a><strong>“猴子管理”理论的启示</strong></h3><p>1、每一个人都应该照看自己的“猴子”；</p><p>2、不要麻烦别人照看自己的“猴子”；</p><p>3、组织中，每一个人都应该明白自己应该照看哪些“猴子”以及如何照看好它们；</p><p>4、不要试图把自己的“猴子”托付给别人照顾。这里的别人可能是上司、下属、别的部门的同事，也可能是公司、社会乃至上天、命运等；</p><p>5、不要出现没有人照看的“猴子”，也不要出现有两个以上“主人”的“猴子”；</p><p>6、作为上司不仅应明确让下属知道他应该照看好哪些“猴子”，更需要训练下属如何照看好他们的“猴子”。</p><p>7、“猴子管理”并不适用于所有管理。比如说我们在创业初期时，就需要创业者或创业团队背负所有的“猴子”。并主动的帮助其他人背负“猴子”，否则创业不会成功。</p><p>8、“猴子管理”会使人变得自私，类似于各人自扫门前雪，会使团队失去活力。正常的团队应该是抢着“猴子”背负，而不是千方百计的防止别人的“猴子”窜上自己的肩膀。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多管理者往往遇到这样的情况，当你听完下属员工的工作汇报后发现事情并没有得到彻底解决，而原本计划好今天要做的工作也因此耽误了不少时间。&lt;/p&gt;
&lt;p&gt;猴子管理法则的目的在于帮助经理人确定由适当人选在适当的时间，用正确的方法做正确的事。&lt;/p&gt;
&lt;p&gt;身为经理人要能够让员工去抚养自己的“猴子”，你也有足够的时间去做规划、协调、创新等重要工作。&lt;/p&gt;</summary>
    
    
    
    <category term="其他/管理" scheme="https://blog.fenxiangz.com/categories/%E5%85%B6%E4%BB%96-%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="管理" scheme="https://blog.fenxiangz.com/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>『认知升级』是比其他一切都更加重要的思维模型转变</title>
    <link href="https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-11-27_%E3%80%8E%E8%AE%A4%E7%9F%A5%E5%8D%87%E7%BA%A7%E3%80%8F%E6%98%AF%E6%AF%94%E5%85%B6%E4%BB%96%E4%B8%80%E5%88%87%E9%83%BD%E6%9B%B4%E5%8A%A0%E9%87%8D%E8%A6%81%E7%9A%84%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8F%98.html"/>
    <id>https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-11-27_%E3%80%8E%E8%AE%A4%E7%9F%A5%E5%8D%87%E7%BA%A7%E3%80%8F%E6%98%AF%E6%AF%94%E5%85%B6%E4%BB%96%E4%B8%80%E5%88%87%E9%83%BD%E6%9B%B4%E5%8A%A0%E9%87%8D%E8%A6%81%E7%9A%84%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8F%98.html</id>
    <published>2020-11-27T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.989Z</updated>
    
    <content type="html"><![CDATA[<p>我们在过去的时光中，谈了很多关于技术、关于生活、关于工作、关于学习的话题，这次我们来谈谈关于『认知升级』这个话题。</p><p>实际上，<strong>『认知升级』相对来说是个比较抽象的概念，它与掌握一门技术相比不是那么容易看到</strong>。因为技术的进步和成长是任何人都可以看到成效的。比如说，你之前不会Netty或是对Netty不是那么了解，通过学习和实践掌握了Netty的方方面面，那这其中的进步就是非常明显的，也是很容易看到成效的。</p><p>与技术上的成长相比，『认知升级』则属于更加抽象，且更具方法论的一个话题了。那么，到底什么是认知呢？</p><p><strong>我个人认为，所谓认知指的是你对这个世界，对身边环境，对于生活、学习与工作的认识以及所采取的行事方法。</strong></p><p>如果说切实掌握了一项技术属于『硬技能』的话，那么『认知升级』则属于软技能这个领域。不过，<strong>这里千万不要认为只有『硬技能』才是我们需要掌握的；相反，『软技能』的重要性有时还会超越『硬技能』</strong>，为什么这么说呢？</p><p><strong>根据我的经历，诸如『认知』这样的软技能是我们能够切实掌握『硬技能』的一个重要前提和方法论保证</strong>。具体来说，我们在学习任何一项新技术时，每个人所采取的方式与方法都是不尽相同的，你有你的方法，他有他的方法，而我显然也有我的方法。不过，无论中间采取了何种方法，我们的目标是不是都是一样，或是几乎是一样的呢？那我们的目标是什么呢？显然，我们的目标是扎实地掌握所学习的这项技术或是这个框架，并且对于一些重要技术与框架来说，掌握的越深入、越扎实越好。</p><p><strong>既然大家的目标是一样的，即我们所要追求的最终结果几乎是无差别的，那么这中间的过程就会对结果起到很大的影响，有的影响是正向的，有的影响则是负向的。</strong></p><p>从我们准备学习一门技术开始，一直到最终彻底掌握它，这中间会经历很多的过程，也会出现很多反复。因此，如何更好地确保中间过程的效率与效果就会对最终的结果产生极大的影响。</p><p>可以将掌握一门技术的过程分为如下几个步骤：</p><ul><li><ol><li>觉得这门技术挺有用，准备学习。</li></ol></li><li><ol start="2"><li>搜集学习资料，看官方文档、购买相关图书、看相关视频。</li></ol></li><li><ol start="3"><li>不停地遇到各种各样的问题，在网上不停地搜索解决方案。</li></ol></li><li><ol start="4"><li>继续看官方文档、继续看书、继续看视频。</li></ol></li><li><ol start="5"><li>依然会遇到各种问题，心情比较烦躁地搜索关于问题的解决方案。</li></ol></li><li><ol start="6"><li>初步掌握了这项技术。</li></ol></li><li><ol start="7"><li>一段时间没有使用或是没有再看这项技术，开始产生遗忘。</li></ol></li><li><ol start="8"><li>又经过一段时间，发现之前学习的这项技术很多都已经记不清楚了，甚至当时非常清晰的一些细节已经完全回忆不起来了。</li></ol></li><li><ol start="9"><li>重新开始学习这门技术。</li></ol></li><li><ol start="10"><li>历经千辛万苦，终于算是比较深入地掌握了这项技术。</li></ol></li><li><ol start="11"><li>又有一段时间没有再碰这项技术。</li></ol></li><li><ol start="12"><li>当有一天翻看这项技术时，发现又有太多、太多的细节已经完全想不起来了。</li></ol></li><li><ol start="13"><li>感到非常的沮丧。</li></ol></li><li><ol start="14"><li>感到更加的沮丧。</li></ol></li><li><ol start="15"><li>重复上述的步骤9。</li></ol></li></ul><p>是不是上面的这15个步骤感到似曾相识呢？</p><p>原因在于什么？</p><p><strong>根本原因在于，你将太多的精力放在了非核心上面，而对真正的核心之处却从来没有深入思考过。</strong></p><p>经常有人咨询我，为什么我学起一些技术会比较快，而且还比较深入，并且还能将自己的积累很系统地讲出来。但是换作自己，哪怕将一门技术扎实掌握都很难做到呢？其实，这个问题并非个案，而是一个普遍存在的问题。这个普遍存在的问题严重到会成为制约你更好前进的一个巨大障碍。</p><p>正所谓『不识庐山真面目，只缘身在此山中』。我们每个人都上了十多年学，但是很多人甚至连最为重要的学习方法都没有掌握。这里面一方面有学校教育的缺失，另一方面则是作为个体从来没有认真思考过这个问题。</p><p>对于我来说，在上大学时收获的最重要两个方面并非掌握了什么专业知识，而是我在大三时明白了下面两点：</p><ul><li><ol><li>我知道自己热爱的专业是什么：我不喜欢自己当时所在的专业，我更加喜欢计算机专业，因此确定了跨校跨专业考研的目标。</li></ol></li><li><ol start="2"><li>我掌握了适合自己的较为高效的自学方式：这一点在后来的时光中对我产生了巨大的帮助，让我能够走得更加从容不迫。</li></ol></li></ul><p>回到上面的话题，为什么我们在学习一项技术时总是容易遗忘，哪怕当时印象极其深刻的内容，以为自己永远也不会忘记的内容过一阵还是会遗忘呢？</p><p>答案就是『无输出』。</p><p>是的，道理就是如此简单。</p><p>无论你的学习手段是什么，是看官方文档，看书，看文章，还是看视频，这些都是『输入』。是别人的东西灌输到你的脑海中，但它不是你的。</p><p><strong>如何将别人的东西最终变成自己的呢？答案只有一个：输出。即，通过自己的不断输入，在脑海中经过一系列的加工，最终变成自己的输出</strong>。即下面这3个过程：</p><ul><li><ol><li>输入</li></ol></li><li><ol start="2"><li>加工</li></ol></li><li><ol start="3"><li>输出。</li></ol></li></ul><p>很多很多人在学习时，第1个步骤做得都还可以；第2步则因人而异了，有些人会思考，有些人则全盘接受，更可悲的是将网上看来的东西就当作真理一般对待。至于第3步，只有很少很少人才会做。因为，这个步骤是最耗费时间与精力的一个步骤。而且，第3步在你学习的当下你会认为是一个毫无存在必要的步骤，因为你当时自我感觉已经将待学习的这项技术理解的很透彻了。然而，成败就在一念之间。</p><p>对于没有输出的学习，其最终的效果就如同我上面所列出的15个步骤那般。</p><p>为什么总有人说，一项技术只有在项目中实际用过了才能真正掌握，其实这里面暗暗隐含着『输出』这个环节。在项目中实际用过显然就是一种输出方式。但在项目中使用过仅仅是『输出』的一种方式而已，它并非全部，请勿一叶障目，不见树林。</p><p><strong>在项目中使用本质上就是一种『输出』方式，它会令你产生一种错觉：一项技术只有在项目中使用过了才能算真正掌握。</strong></p><p>当下的技术领域如此之多，一个项目充其量只会使用其中很少的一些技术集合。按照上面的理论，难道项目中用不上的技术就不用学了么？答案不言自明。</p><p>其实，在项目中使用会令你加深对一项技术的理解与认识这个观点只不过是对于一种方法论的具体解读而已。</p><p>『输出』的形态其实有很多种：</p><ul><li><ol><li>在项目中使用</li></ol></li><li><ol start="2"><li>形成记录（记录到印象笔记或是有道云笔记上），发表到博客、微信公众号等媒体上</li></ol></li><li><ol start="3"><li>给别人讲</li></ol></li></ul><p>这里面我只列出了自己所钟爱的3种方式，其他方式也有很多。</p><p>因此，你觉得在项目中使用才算掌握一门技术，在我眼里看来，可谓是『认知』尚未升级，因为你并未透过现象看到本质。在项目中使用可以让我们比较好地学会到应用，但是对于技术的深层次掌握是需要额外下功夫的，这通常都是对自己有着较高要求的人才会做的事情。</p><p>给别人讲是一种我特别推崇的学习方式。通过这个过程，你会发现自己在技术理解上的诸多问题，同时会不断加深对技术细节的把控；可以这么说，<strong>将上面3种『输出』方式有机结合起来，会令你真正掌握学习的方法论，也会令你在学习之路上越走越好，越走越踏实</strong>。</p><p>可以举一个例子，目前圣思园正在发布『深入理解JVM』课程。实际上，除了本职工作就是与JVM打交道之外，绝大多数人的日常工作并非天天都会接触到JVM，那为何还要学习呢？因为它重要啊！</p><p>既然无法做到天天与JVM打交道，那该如何学习JVM呢？显然，既然无法做到在项目中直接使用，那我们就完全可以用其余2种方法：形成技术+给别人讲。</p><p>参加圣思园课程学习的不少小伙伴已经在践行我上面所提出的观点，并且均取得了不错的效果，这里我也期望你能将自己的学习观点与认知方式分享出来，欢迎大家的评论。</p><p>原文：<a href="https://blog.csdn.net/ricohzhanglong/article/details/95947294">https://blog.csdn.net/ricohzhanglong/article/details/95947294</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在过去的时光中，谈了很多关于技术、关于生活、关于工作、关于学习的话题，这次我们来谈谈关于『认知升级』这个话题。&lt;/p&gt;
&lt;p&gt;实际上，&lt;strong&gt;『认知升级』相对来说是个比较抽象的概念，它与掌握一门技术相比不是那么容易看到&lt;/strong&gt;。因为技术的进步和成长是任何人都可以看到成效的。比如说，你之前不会Netty或是对Netty不是那么了解，通过学习和实践掌握了Netty的方方面面，那这其中的进步就是非常明显的，也是很容易看到成效的。&lt;/p&gt;
&lt;p&gt;与技术上的成长相比，『认知升级』则属于更加抽象，且更具方法论的一个话题了。那么，到底什么是认知呢？&lt;/p&gt;</summary>
    
    
    
    <category term="其他/管理" scheme="https://blog.fenxiangz.com/categories/%E5%85%B6%E4%BB%96-%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="管理" scheme="https://blog.fenxiangz.com/tags/%E7%AE%A1%E7%90%86/"/>
    
    <category term="认知" scheme="https://blog.fenxiangz.com/tags/%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Jira 修改 Path 路径后的用户管理问题</title>
    <link href="https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-11-26_Jira%E4%BF%AE%E6%94%B9Path%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-11-26_Jira%E4%BF%AE%E6%94%B9Path%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98.html</id>
    <published>2020-11-26T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.988Z</updated>
    
    <content type="html"><![CDATA[<p>Confluence 同步 Jira 的几个相关配置</p><h2 id="1-仅使用外部用户管理"><a href="#1-仅使用外部用户管理" class="headerlink" title="1. 仅使用外部用户管理"></a>1. 仅使用外部用户管理</h2><p><img src="./2020-11-26_Jira%E4%BF%AE%E6%94%B9Path%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/1.png"></p><h2 id="2-Confluence-的-Links-配置"><a href="#2-Confluence-的-Links-配置" class="headerlink" title="2. Confluence 的 Links 配置"></a>2. Confluence 的 Links 配置</h2><p><img src="./2020-11-26_Jira%E4%BF%AE%E6%94%B9Path%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/2.png"></p><h2 id="3-Jira-修改-Context-的-Path-路径后，Confluence账号无法登陆，用户管理问题。"><a href="#3-Jira-修改-Context-的-Path-路径后，Confluence账号无法登陆，用户管理问题。" class="headerlink" title="3. Jira 修改 Context 的  Path 路径后，Confluence账号无法登陆，用户管理问题。"></a>3. Jira 修改 Context 的  Path 路径后，Confluence账号无法登陆，用户管理问题。</h2><p><img src="./2020-11-26_Jira%E4%BF%AE%E6%94%B9Path%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/3.png"></p><p>如果本身是可编辑的就直接编辑，非可编辑状态，需要先下移改成非首选，然后进入编辑页面更新外部用户目录的实际路径。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Confluence 同步 Jira 的几个相关配置&lt;/p&gt;
&lt;h2 id=&quot;1-仅使用外部用户管理&quot;&gt;&lt;a href=&quot;#1-仅使用外部用户管理&quot; class=&quot;headerlink&quot; title=&quot;1. 仅使用外部用户管理&quot;&gt;&lt;/a&gt;1. 仅使用外部用户管理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;./2020-11-26_Jira%E4%BF%AE%E6%94%B9Path%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他/Jira" scheme="https://blog.fenxiangz.com/categories/%E5%85%B6%E4%BB%96-Jira/"/>
    
    
    <category term="Jira" scheme="https://blog.fenxiangz.com/tags/Jira/"/>
    
  </entry>
  
  <entry>
    <title>开发资源导航</title>
    <link href="https://blog.fenxiangz.com/post/util/2020-11-26_%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86.html"/>
    <id>https://blog.fenxiangz.com/post/util/2020-11-26_%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86.html</id>
    <published>2020-11-26T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><ul><li><a href="http://jqfundamentals.com/book/index.html">jQuery Fundamentals</a>  - jQuery 入门教程。</li><li><a href="http://www.cn-cuckoo.com/deconstructed/index.html">JavaScript库 代码解构</a>  - 将JavaScript流行框架源代码条分缕析展现出来</li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解Javascript系列</a> </li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">Script的defer和async的区别</a></li><li><a href="http://coolshell.cn/articles/6441.html">Javascript面向对象基础</a> </li><li><a href="http://github.com/addyosmani/backbone-fundamentals">Backbone.js基础</a> </li><li><a href="http://unixpapa.com/js/key.html">JavaScript Madness: Keyboard Events</a> </li><li><a href="http://dailyjs.com/tags.html#frameworks">Let’s Make Frameworks</a> </li><li>国内公司JS框架：<a href="http://kissyui.com/">Kissy - Taobao</a>  | <a href="http://arale.alipay.net/">Arale - Alipay</a>  | <a href="http://tangram.baidu.com/">Tangram - Baidu</a> </li><li><a href="http://js1k.com/">JS1K, 1k Javascript contest</a> </li><li><a href="http://www.json.org/">JSON Home Page</a> </li><li><a href="http://code.google.com/p/molokoloco-coding-project/wiki/JavascriptBase">NB JS Wiki(CSS、PHP、jQuery、Linux)</a> </li><li><a href="http://birdshome.cnblogs.com/archive/2006/05/28/IE_MemoryLeak.html">理解并解决IE的内存泄漏方式</a> <a href="http://birdshome.cnblogs.com/archive/2006/06/01/ClosureReferences.html">2</a> <a href="http://birdshome.cnblogs.com/archive/2006/06/17/Cross_Page_Leaks.html">3</a> <a href="http://birdshome.cnblogs.com/archive/2006/06/30/Pseudo_Leaks.html">4</a> </li><li><a href="http://msdn.microsoft.com/en-us/library/bb250448.aspx">Understanding and Solving Internet Explorer Leak Patterns</a> </li><li><a href="http://www.cnblogs.com/rubylouvre/archive/2010/01/05/1639541.html">Javscript Bind函数</a> </li><li><a href="http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/">Javscript设计模式</a> </li></ul><h4 id="JSON工具："><a href="#JSON工具：" class="headerlink" title="JSON工具："></a>JSON工具：</h4><ul><li><a href="http://www.jsonlint.com/">JSONLint</a>  - The JSON Validator</li><li><a href="http://undefined.org/python/#simplejson">SimpleJSON</a>  - Python Stuff</li><li><a href="http://jsonformatter.curiousconcept.com/">JSON Formatter (&amp; Validator!)</a> </li><li><a href="http://www.raboof.com/Projects/TidyJson/">Tidy JSON - JSON Pretty Printer/Colorer</a>  - C#(.NET)</li><li><a href="http://www.cerny-online.com/cerny.js/demos/json-pretty-printing">Cerny.js - JSON Pretty Printing Demo</a> </li><li><a href="http://github.com/nicksieger/jsonpretty">jsonpretty(ruby)</a> </li></ul><h4 id="Vim-Json："><a href="#Vim-Json：" class="headerlink" title="Vim Json："></a>Vim Json：</h4><ul><li><a href="http://lumberjaph.net/perl/2009/02/17/tidify-a-json-in-vim.html">tidify a json in Vim</a> </li><li><a href="http://www.vim.org/scripts/script.php?script_id=1945">JSON.vim</a>  - syntax</li><li><a href="http://visibletrap.blogspot.com/2010/05/vim-how-to-format-and-syntax-highlight.html">VIM - How to format and syntax highlight JSON file</a> </li><li><a href="http://bradmontgomery.blogspot.com/2010/01/add-json-syntax-highlighting-in-vim-on.html">Add JSON syntax highlighting in Vim on OS X</a> </li></ul><h4 id="JSONP："><a href="#JSONP：" class="headerlink" title="JSONP："></a>JSONP：</h4><ul><li><a href="http://www.ibm.com/developerworks/cn/web/wa-aj-jsonp1/index.html">使用 JSONP 实现跨域通信，第 1 部分: 结合 JSONP 和 jQuery 快速构建强大的 mashup</a> <a href="http://www.ibm.com/developerworks/cn/web/wa-aj-jsonp2/index.html">第 2 部分: 使用 JSONP、jQuery 和 Yahoo! 查询语言构建 mashup</a> </li><li><a href="http://www.cn-cuckoo.com/2008/09/13/the-origin-of-jsonp-262.html">JSONP的起源</a> </li><li><a href="http://www.ibm.com/developerworks/cn/xml/x-mashups.html">Mashups：Web 应用程序新成员</a> </li></ul><h4 id="Javascript闭包："><a href="#Javascript闭包：" class="headerlink" title="Javascript闭包："></a>Javascript闭包：</h4><ul><li><a href="http://zh.wikipedia.org/zh-cn/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包 (计算机科学)</a> </li><li><a href="http://jibbering.com/faq/notes/closures/">Javascript Closures</a> </li><li><a href="http://roshanca.com/?p=153">什么是闭包</a> </li><li><a href="http://www.jibbering.com/faq/faq_notes/closures.html">Javascript Closures</a> <a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html">中文</a> <a href="http://www.aspxhome.com/examples/javascript/program/483628/javascriptclosures.html">2</a> </li><li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">学习Javascript闭包（Closure）</a> </li><li><a href="http://www.mikkolee.com/81">作用域链 词法作用域 与 闭包（一）</a> <a href="http://www.mikkolee.com/84">（二）</a> </li></ul><h4 id="Javascript工具："><a href="#Javascript工具：" class="headerlink" title="Javascript工具："></a>Javascript工具：</h4><ul><li><a href="http://www.jslint.com/">JSLint</a> </li><li><a href="http://javascriptlint.com/">JavaScript Lint</a> </li><li><a href="http://github.com/rainux/jslint.vim">Fork of hallettj/jslint.vim</a> </li><li><a href="http://varnow.org/?p=174">Google Closure Compiler压缩优化规则初探</a> </li><li><a href="http://www.phpblog.cn/archives/242">使用Google 的Closure Compiler来压缩javascript</a> </li><li><a href="http://www.cnblogs.com/JeffreyZhao/archive/2009/12/09/ikvm-google-closure-compiler.html">在项目中使用Google Closure Compiler</a> </li><li><a href="http://hikejun.com/blog/?p=476&amp;cpage=1">Mac下用Closure compiler</a> </li><li><a href="http://ued.sohu.com/article/611">JS 库浅析之 Google Closure</a> </li><li><a href="http://www.pushiming.com/blog/2010/12/advanced-optimization-in-closure-compiler-and-more/">Closure Compiler 高级模式及更多思考</a> </li><li><a href="http://www.slideshare.net/lifesinger/closure-compiler-vs-yuicompressor">Closure Compiler vs YUICompressor</a> </li><li><a href="http://www.minifyjs.com/">Minify JS</a> </li><li><a href="http://docs.jquery.com/QUnit">QUnit</a> <a href="http://github.com/jquery/qunit">@github</a> </li></ul><ul><li>JsBeautify：<a href="http://jsbeautifier.org/">Online Javascript jsbeautifier</a> <a href="http://github.com/einars/js-beautify">github</a> , <a href="http://www.vim.org/scripts/script.php?script_id=2727">vimscript</a> </li></ul><ul><li><a href="https://code.google.com/p/jsbeautifier/">js beautifier</a>  - plugin for Chrome</li></ul><h4 id="NodeJS："><a href="#NodeJS：" class="headerlink" title="NodeJS："></a>NodeJS：</h4><ul><li><a href="http://nodejs.org/">nodeJS</a>  - 服务器端 JavaScript 编程</li><li><a href="http://simonwillison.net/2009/Nov/23/node/">Node.js is genuinely exciting</a> </li><li><a href="http://blog.csdn.net/fuadam/archive/2010/03/15/5380178.aspx">在cygwin环境下编译node.js</a> </li><li><a href="http://github.com/ry/node_chat">node char</a>  - 用 nodeJS 写的聊天室</li><li><a href="https://no.de/">Joyent Node</a>  | <a href="http://mattn.no.de/">mattn.no.de</a> </li></ul><h2 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h2><ul><li><a href="http://wiki.hotoo.me/CSS-Hacks.html">CSS Hacks &amp; Expression</a> </li><li><a href="http://www.digitalmediaminute.com/reference/entity/">XHTML Character Entity Reference HTML实体字符引用</a> </li><li><a href="http://blog.bingo929.com/css-frameworks-15.html">精选15个国外CSS框架</a> </li><li><a href="http://nicolasgallagher.com/pure-css-speech-bubbles/demo/">Pure Css Speech Bubbles</a> </li></ul><h4 id="CSS栅格系统-Grid-System-："><a href="#CSS栅格系统-Grid-System-：" class="headerlink" title="CSS栅格系统(Grid System)："></a>CSS栅格系统(Grid System)：</h4><ul><li><a href="http://1kbgrid.com/">The 1Kb CSS Grid</a>  - 拖放各个阈值并直接下载自动生成的CSS。</li><li><a href="http://www.spry-soft.com/grids/">Variable Grid System</a>  - 可直接修改各个阈值并预览效果。</li><li><a href="http://grid.mindplay.dk/">Grid Designer</a> </li><li><a href="http://builder.yaml.de/">YAML Builder</a>  - A tool for visual development of YAML based CSS layouts. </li><li><a href="http://960.gs/">960 Grid System</a> <a href="http://github.com/nathansmith/960-Grid-System">960-Grid-System@github</a> </li><li><a href="http://ued.taobao.com/blog/2008/09/17/grid_systems/">网页的栅格系统设计</a>  - 青云</li><li><a href="http://www.gracecode.com/archives/2363/">我的栅格系统</a>  - 明城</li><li><a href="http://www.markboulton.co.uk/journal/comments/five-simple-steps-to-designing-grid-systems-part-1">Five simple steps to designing grid systems</a> <a href="http://www.markboulton.co.uk/journal/comments/five-simple-steps-to-designing-grid-systems-part-2">2</a> <a href="http://www.markboulton.co.uk/journal/comments/five-simple-steps-to-designing-grid-systems-part-3">3</a> <a href="http://www.markboulton.co.uk/journal/comments/five-simple-steps-to-designing-grid-systems-part-4">4</a> <a href="http://www.markboulton.co.uk/journal/comments/five-simple-steps-to-designing-grid-systems-part-5">5</a> </li></ul><h4 id="CSS疑难杂症："><a href="#CSS疑难杂症：" class="headerlink" title="CSS疑难杂症："></a>CSS疑难杂症：</h4><ul><li><a href="http://www.smallni.com/haslayout-block-formatting-contexts/">HasLayout和BFC(Block Formatting Contexts)的区别完整对比</a> </li><li><a href="http://rebuildpattern.com/node/44">Block Formatting Contexts的特性</a> </li><li><a href="http://haslayout.net/">hasLayout.net</a> </li><li><a href="http://www.satzansatz.de/cssd/onhavinglayout.html">On having layout</a> <a href="http://www.blueidea.com/tech/site/2006/3698.asp">中文版</a> </li><li><a href="http://www.positioniseverything.net/explorer/expandingboxbug.html">Internet Explorer 6 and the Expanding Box Problem</a> </li><li><a href="http://www.qianduan.net/universal-to-remove-floating-style.html">万能清除浮动样式</a> </li><li><a href="http://ued.taobao.com/blog/2010/08/04/css-border%E4%BD%BF%E7%94%A8%E5%B0%8F%E5%88%86%E4%BA%AB/">CSS Border使用小分享</a> </li><li><a href="http://www.cnblogs.com/eazon/archive/2008/07/04/1235268.html">表格樣式集錦</a> </li><li><a href="http://www.zhangxinxu.com/wordpress/?p=56">复选框单选框与文字对齐问题的研究与解决</a> </li><li><a href="http://www.blueidea.com/tech/web/2008/6313.asp">连续字符自动换行的解决方案</a> </li><li><a href="http://www.cnblogs.com/yizuierguo/archive/2010/08/04/1792287.html">三谈Iframe自适应高度</a>  | <a href="http://www.cnblogs.com/MaxIE/archive/2008/08/13/1266597.html">再谈iframe自适应高度</a> </li><li><a href="http://www.qianduan.net/cross-browser-inline-block.html">跨浏览器的inline-block</a> <a href="http://blog.mozilla.com/webdev/2009/02/20/cross-browser-inline-block/">en</a> </li><li><a href="http://www.planabc.net/2007/03/11/display_inline-block/">display:inline-block的深入理解</a> </li></ul><h2 id="HTML5-amp-CSS3"><a href="#HTML5-amp-CSS3" class="headerlink" title="HTML5 &amp; CSS3"></a>HTML5 &amp; CSS3</h2><ul><li><a href="http://diveintohtml5.info/">Dive Into HTML5</a> </li><li><a href="http://blog.bingo929.com/google-enjoy-html5-drag-drop-filereaderenren.html">HTML5训练营</a> </li><li><a href="http://blog.bingo929.com/html5-websockets.html">HTML5 WebSockets</a> </li><li><a href="http://blog.bingo929.com/html5-ie-enabling-script.html">IE支持HTML5</a> </li><li><a href="http://blog.bingo929.com/power-of-html5-css3-div-css.html">感受HTML5&amp;CSS3</a> </li><li>用JavaScript玩转计算机图形学：<a href="http://www.cnblogs.com/miloyip/archive/2010/03/29/1698953.html">(一)光线追踪入门</a> <a href="http://www.cnblogs.com/miloyip/archive/2010/04/02/1702768.html">(二)基本光源</a> </li></ul><h4 id="Canvas："><a href="#Canvas：" class="headerlink" title="Canvas："></a>Canvas：</h4><ul><li><a href="http://zh.wikipedia.org/wiki/Canvas_%28HTML%E5%85%83%E7%B4%A0%29">Canvas (HTML元素)</a> </li><li><a href="http://billmill.org/static/canvastutorial/index.html">Canvas Tutorial</a> </li><li><a href="https://developer.mozilla.org/cn/Canvas_tutorial">Canvas 教程</a> <a href="https://developer.mozilla.org/en/Canvas_tutorial">en</a> </li><li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element">The canvas element</a> </li><li><a href="http://blog.bingo929.com/html-5-canvas-the-basics-html5.html">HTML5 Canvas</a> </li></ul><h4 id="Canvas使用教程："><a href="#Canvas使用教程：" class="headerlink" title="Canvas使用教程："></a>Canvas使用教程：</h4><ul><li><a href="http://jiachen.blogbus.com/logs/29567413.html">开题</a> </li><li><a href="http://jiachen.blogbus.com/logs/29569584.html">基本语法</a> </li><li><a href="http://jiachen.blogbus.com/logs/29596111.html">图形绘制</a> </li><li><a href="http://jiachen.blogbus.com/logs/32827552.html">图片应用</a> </li></ul><h4 id="Canvas-Games："><a href="#Canvas-Games：" class="headerlink" title="Canvas Games："></a>Canvas Games：</h4><ul><li><a href="http://henrikfalck.com/unrealsoccer/">Unreal Soccer</a> </li><li><a href="http://www.benjoffe.com/code/demos/canvascape/">Canvascape</a> </li><li><a href="http://dave-webster.com/projects/index.php?page=incs/plasma_demo1">Plasma demo using the HTML Canvas element</a> </li><li><a href="http://www.student.kuleuven.be/~m0216922/CG/plasma.html">Lodes Computer Graphics Tutorial</a> </li><li><a href="http://alteredqualia.com/cubeout/">CubeOut</a>  - 3D 俄罗斯方块</li><li><a href="http://canvasrider.com/tracks/all">自行车越野</a> </li><li><a href="http://box2d-js.sourceforge.net/index2.html">Box2DJS</a> </li><li><a href="http://www.effectgames.com/demos/canvascycle/?sound=1">Canvas Cycles</a> </li><li><a href="http://agent8ball.com/">Agent 8 Ball</a>  - 台球</li></ul><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><ul><li><a href="http://www.css3generator.com/">CSS3 Generator</a> </li><li><a href="http://gradients.glrzad.com/">CSS3 Gradient Generator</a> </li><li><a href="http://css-tricks.com/examples/ButtonMaker/">CSS3 Button Maker</a> </li><li><a href="http://css3please.com/">CSS3 Please!</a>  - The Cross-Browser CSS3 Rule Generator</li></ul><h4 id="Framework："><a href="#Framework：" class="headerlink" title="Framework："></a>Framework：</h4><ul><li><a href="http://www.jgraph.com/mxgraph.html">mxGraph - the AJAX diagramming soluting</a> </li><li><a href="http://code.google.com/p/svgweb/">Scalable Vector Graphics Web Browser using Flash</a> </li><li><a href="http://code.google.com/p/explorercanvas/">HTML5 Canvas for Internet Explorer</a> </li><li><a href="http://code.google.com/p/svg2vml/">Library that provides support for SVG and VML with an SVG style interface</a> </li><li><a href="http://www.walterzorn.com/jsgraphics/jsgraphics_e.htm">DHTML: Draw Line, Ellipse, Oval, Circle, Polyline, Plygon, Triangle, with JavaScript</a> </li><li><a href="http://www.cnblogs.com/webgis8/articles/1529588.html">翻译Browser Drawing一篇:Canvas/SVG/VML Drawing Roundup</a> </li><li><a href="http://github.com/mrdoob/three.js">Three.js</a> </li><li><a href="http://raphaeljs.com/">Rapha?l</a>  - 非常棒的跨平台 JavaScript 图形库 | <a href="http://github.com/DmitryBaranovskiy/raphael">raphael@github</a>  | <a href="http://dmitry.baranovskiy.com/">blog</a> </li><li><a href="http://code.google.com/p/uupaa-js-spinoff/">uupaa.js spin-off projects</a> </li></ul><h4 id="Demo："><a href="#Demo：" class="headerlink" title="Demo："></a>Demo：</h4><ul><li><a href="http://www.alexbuga.com/v9/">Alex Buga Livingroom</a> </li><li><a href="http://guciek.net/test/burn">burn-canvas-test</a>  - 画图</li><li><a href="http://webdesignledger.com/inspiration/10-html5-demos-to-make-you-forget-about-flash">10 HTML5 Demos to Make You Forget About Flash</a> <a href="http://designlol.net/archives/1418">cn</a> </li><li><a href="http://muro.deviantart.com/">deviantART Muro</a> </li><li><a href="http://www.phoboslab.org/biolab/">Biolab Disaster</a>  - Game</li><li><a href="http://labs.codecomputerlove.com/FlashVsHtml5/">乒乓球游戏：左边用Flash，右边用HTML5</a> </li><li><a href="http://www.20thingsilearned.com/">20 Things I Learned About Browsers and the Web</a> </li><li><a href="http://www.subcide.com/experiments/fail-whale/">Pure CSS Twitter ‘Fail Whale’</a> </li><li><a href="http://www.optimum7.com/css3-man/animation.html">CSS3-Man</a> </li><li><a href="http://knb.im/css3/">A啦多梦告诉你浏览器对 CSS3 的支持程度</a> </li></ul><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><ul><li><a href="http://www.w3.org/">World Wide Web Consortium</a> </li><li><a href="http://www.webstandards.org/">The Web Standards Project</a> </li><li><a href="http://www.w3schools.com/">W3Schools Online Web Tutorials</a> </li><li><a href="http://www.google.com/support/webmasters/bin/answer.py?hl=cn&amp;answer=40132">HTTP 状态代码</a> </li><li><a href="http://www.floatfly.cn/default/web-error-info.html">网页错误代码详解</a> </li><li><a href="http://www.w3school.com.cn/">w3school - 在线教程</a> </li><li><a href="http://zh.wikipedia.org/zh-cn/REST">REST介绍</a> </li><li><a href="http://aliceui.com/category/solutions/">浏览器兼容解决方案</a> (AliceUI) | <a href="http://aliceui.com/w3c-docs/">W3C 标准文档</a> (AliceUI)</li><li>Microformats：<a href="http://microformats.org/wiki/Main_Page">Microformats</a>  | <a href="http://www.blueidea.com/tech/web/2009/6471.asp">什么是微格式及经典实例演示</a>  | <a href="http://zh.wikipedia.org/zh/%E5%BE%AE%E6%A0%BC%E5%BC%8F">微格式 - Wikipedia</a> <a href="http://en.wikipedia.org/wiki/Microformat">en</a>  | <a href="http://suda.co.uk/projects/microformats/cheatsheet/">Microformats Cheat Sheat</a>  | <a href="http://www.ued163.com/?p=470">微格式全功略Hcard、 hCalendar、hReview、XFN 轻松掌握</a>  | <a href="http://tommyfan.com/blog/skill/microformats_hcard/">微格式 Microformats ? hCard</a>  | <a href="http://www.mijia.org/blog/?p=152">使用微格式来丰富网站语义：简介</a>  | <a href="http://www.ablognotlimited.com/articles/getting-semantic-with-microformats-introduction/">Getting Semantic With Microformats, Introduction</a> </li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/">简明Python教程</a> </li><li><a href="http://woodpecker.org.cn/diveintopython/">Dive Into Python中文版</a> </li><li><a href="http://woodpecker.org.cn/diveintopython3/">Dive Into Python3中文版</a> </li><li><a href="http://wiki.woodpecker.org.cn/moin/">啄木鸟社区Wiki</a> </li><li><a href="http://wiki.woodpecker.org.cn/moin/PyAbsolutelyZipManual">Python绝对简明手册</a> </li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a> <a href="http://help.locoy.com/Document/Learn_Regex_For_30_Minutes.htm">2</a> </li><li><a href="http://www.regexlab.com/zh/">正则表达式工作室</a>  | <a href="http://www.regexlab.com/zh/regref.htm">揭开正则表达式的神秘面纱</a>  | <a href="http://www.regexlab.com/zh/regtopic.htm">正则表达式话题</a> |  <a href="http://www.regexlab.com/zh/deelx/introidx.htm">DEELX 正则引擎性能与特点</a> </li><li><a href="http://blog.chinaunix.net/u3/112728/showart_2207101.html">各种工具之正则表达式语法比较</a> <a href="http://hi.baidu.com/libk/blog/item/b5eb710e6c636dc37acbe107.html">2</a> </li><li><a href="http://www.phpx.com/man/Regular_Expression/">Regular_Expression 入门</a> </li><li><a href="http://java.sun.com/docs/books/tutorial/essential/regex/">Lesson: Regular Expressions(Java)</a> </li><li><a href="http://docs.python.org/library/re.html">Regular expression operations(Python)</a> </li><li><a href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科</a> </li><li><a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/RegExp#Special_characters_in_regular_expressions">RegExp - Mozilla</a> </li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-103-7/?ca=drs-tp4608">学习 Linux，101: 使用正则表达式搜索文本文件</a> </li><li><a href="http://www.ibm.com/developerworks/cn/java/wa-regexp/index.html">构建用于正则表达式的抽象 Java API</a> </li><li><a href="http://www.greenend.org.uk/rjk/2002/06/regexp.html">Regexp Syntax Summary</a> </li><li><a href="http://blog.stevenlevithan.com/archives/javascript-regex-and-unicode">JavaScript, Regex, and Unicode</a> </li><li><a href="http://blog.csdn.net/myan/archive/2007/03/03/1520033.aspx">《理解正则表达式（程序员第3期文章）》</a> </li><li><a href="http://tech.idv2.com/2006/05/08/parse-regex-with-dfa/">利用有限自动机分析正则表达式</a> </li><li><a href="http://book.51cto.com/art/200902/111541.htm">《Linux系统最佳实践工具：命令行技术》</a> </li><li><a href="http://iregex.org/links">我爱正则表达式</a> </li><li><a href="http://regex.me/">正则表达式论坛</a> </li><li>正则表达式工具：<a href="http://regexpal.com/">Regexpal (online)</a> <a href="http://www.microidc.com/usr/tools/regexpal/index.html">2</a>  | <a href="http://gskinner.com/RegExr/">RegExr</a>  | <a href="http://www.regexbuddy.com/">RegexBuddy</a>  | <a href="http://www.ultrapico.com/Expresso.htm">Expresso (free, open-source)</a>  | <a href="http://www.regexlab.com/zh/mtracer/">Match Tracer</a>  | <a href="http://www.gethifi.com/tools/regex">HiFi Regex Tester</a>  | <a href="http://www.redfernplace.com/software-projects/regex-builder/">RegEx Builder</a> </li></ul><h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><ul><li><p><a href="http://markdown.tw/">MarkDown语法</a> </p></li><li><p><a href="http://114.xixik.com/character/">HTML转义</a> </p></li><li><p>OAuth</p></li><li><p><a href="http://oauth.net/">OAuth</a> </p></li><li><p><a href="http://www.rollingcode.org/blog/f/oauth-core-1.0-final-cn.html">OAuth核心</a> </p></li><li><p><a href="http://code.google.com/apis/accounts/docs/OAuth.html">OAtuh for Web Application</a> </p></li><li><p><a href="https://github.com/mattn/vim-oauth">Vim-oauth</a> </p></li><li><p><a href="https://github.com/mattn/webapi-vim">webapi-vim</a><br>&amp; OAuth在线测试：<a href="http://term.ie/oauth/example/index.php">服务端</a>  | <a href="http://term.ie/oauth/example/client.php">客户端</a> </p></li><li><p>国内开源镜像站：<a href="http://mirrors.sohu.com/">Sohu.com</a>  | <a href="http://mirrors.163.com/">163.com</a> </p></li><li><p>在线IDE：<a href="http://www.coderun.com/ide/">CodeRun</a>  | <a href="http://jsfiddle.net/">jsFiddle</a>  | <a href="http://jsbin.com/">JS Bin</a>  | <a href="http://code.wanz.im/">小可<Little Code /></a> </p></li><li><p>优良的文本处理工具：SED &amp; AWK</p></li><li><p><a href="http://sed.sourceforge.net/">sed.sf.net</a>  | <a href="http://en.wikipedia.org/wiki/AWK">AWK @wikipedia</a> <a href="http://zh.wikipedia.org/wiki/AWK">中文</a> </p></li><li><p><a href="http://gnuwin32.sourceforge.net/packages/gawk.htm">Gawk for Windows</a>  | <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">Sed for Windows</a> </p></li><li><p><a href="http://blog.chinaunix.net/u/13392/showart.php?id=133128">sed-非交互式文本编辑器(L.E.McMahon 著,中文翻译)</a> <a href="http://cm.bell-labs.com/7thEdMan/vol2/sed">En</a>  | <a href="http://blog.chinaunix.net/u/13392/showart.php?id=134410">awk-模式扫描与处理语言(Aho,Kernighan,Weinberger著,中文翻译)(第二版)</a> <a href="http://cm.bell-labs.com/7thEdMan/vol2/awk">En</a> </p></li><li><p>详解注明的AWK oneliner：<a href="http://roylez.heroku.com/2010/04/11/awk-oneliner-translation-1.html">一：空行、行号和计算</a>  | <a href="http://roylez.heroku.com/2010/04/28/awk-oneliner-translation-2.html">二：文本替换</a>  | <a href="http://roylez.heroku.com/2010/05/15/awk-oneliner-translation-3.html">三：选择性输出特定行</a>  | <a href="http://roylez.heroku.com/2010/07/29/awk-oneliner-translation-4.html">四：定义字符串和数组</a> </p></li><li><p>详解AWK oneliner原文：<a href="http://www.catonmat.net/blog/awk-one-liners-explained-part-one/">Famous Awk One-Liners Explained</a>  | <a href="http://www.catonmat.net/blog/update-on-famous-awk-one-liners-explained">Update on Famous Awk One-Liners Explained: String and Array Creation</a> </p></li><li><p><a href="http://panweizeng.com/archives/522">sed和awk的简单使用 - 潘魏增</a> </p></li><li><p>参考书籍：<a href="http://cm.bell-labs.com/cm/cs/awkbook/">The AWK Programming Language</a>  | <a href="http://oreilly.com/catalog/9780596000707/">Effective awk Programming, Third Edition</a>  | <a href="http://oreilly.com/catalog/9781565922259">sed &amp; awk, Second Edition</a>  | <a href="http://oreilly.com/catalog/9780596003524">sed and awk Pocket Reference, Second Edition</a> </p></li></ul><h4 id="函数式编程："><a href="#函数式编程：" class="headerlink" title="函数式编程："></a>函数式编程：</h4><ul><li><p><a href="http://en.wikipedia.org/wiki/Functional_programming">@wikipedia</a> <a href="http://zh.wikipedia.org/zh-cn/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">中文</a> </p></li><li><p><a href="http://www.aqee.net/2010/03/08/a-brief-history-of-object-functional-programming/">对象-函数式编程简史</a> <a href="http://news.csdn.net/a/20100311/217407.html">2</a> </p></li><li><p><a href="http://www.ibm.com/developerworks/cn/web/wa-javascript.html">用函数式编程技术编写优美的 JavaScript</a> </p></li><li><p><a href="http://blog.zhaojie.me/tag/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>  - 老赵</p></li><li><p><a href="http://chenzhongke.com/wi/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>  - czk wiki</p></li><li><p><a href="http://wfp.group.javaeye.com/">函数式编程の道</a> </p></li><li><p><a href="http://blog.csdn.net/xuejx/archive/2009/08/12/4440105.aspx">哪种语言将统治多核时代 再看函数式语言特性</a> </p></li><li><p><a href="http://www.canonical.org/~kragen/tao-of-programming.html">The Tao Of Programming</a> ,<a href="http://osiris.urbanna.net/tao.html">2</a> ,<a href="http://livecn.huasing.org/tao_of_programming.htm">《编程之道》</a>  文言文版 by Livecn，<a href="http://202.118.74.32/doc/Science/Computer/TaoOfProg.pdf">2</a>  白话文版 by 小赵</p></li><li><p>代码高亮：<a href="http://mihai.bazon.net/projects/javascript-syntax-highlighting-engine">DlHightLight代码高亮组件</a>  | <a href="http://code.google.com/p/google-code-prettify/">Google Code Prettify</a> </p></li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul><li><a href="http://blog.csdn.net/vagrxie/archive/2009/09/23/4582457.aspx">版本控制系统（RCS）的选择与比较</a> </li><li><a href="http://blog.csdn.net/tony1130/archive/2008/10/25/3137494.aspx">拥抱Mercurial—选择分布式版本控制工具</a> </li><li><a href="http://blog.csdn.net/meteor1113/archive/2009/07/16/4350408.aspx">几个分布式vcs比较</a> </li><li><a href="http://en.wikipedia.org/wiki/Comparison_of_revision_control_software">Comparison of revision control software</a> <h4 id="代码片段管理："><a href="#代码片段管理：" class="headerlink" title="代码片段管理："></a>代码片段管理：</h4></li><li><a href="http://gist.github.com/">gist@github</a> </li><li><a href="http://notepad.cc/">notepad.cc</a> </li><li><a href="http://snipt.org/">Snipt.org</a> </li><li><a href="http://paste.ubuntu.org.cn/">Ubuntu Paste</a> </li><li><a href="http://pastebin.com/">Pastebin</a> </li><li><a href="http://paste.pocoo.org/">Lodge It!</a> </li></ul><h4 id="SVN相关："><a href="#SVN相关：" class="headerlink" title="SVN相关："></a>SVN相关：</h4><ul><li><a href="http://svnbook.red-bean.com/">Subversion 与版本控制</a> </li><li><a href="http://www.iusesvn.com/subversion/tortoisesvn_doc/1.4/">TortoiseSVN 中文帮助手册(v1.4.1)</a> <a href="http://tortoisesvn.net/docs/release/TortoiseSVN_zh_CN/index.html">v1.6.8</a> </li><li><a href="http://tortoisesvn.tigris.org/">Tigris.org</a>  - for Windows. </li><li><a href="http://www.subversion.org.cn/">Subversive中文站</a> </li><li><a href="http://subclipse.tigris.org/">Subclipse</a> </li><li><a href="http://www.eclipse.org/subversive/">Subversive</a> </li><li><a href="http://rabbitvcs.org/">RabbitVCS</a>  - for Linux. </li><li><a href="http://xuming.net/2010/04/rabbitvcs.html">Ubuntu下最好用的SVN客户端</a> </li><li><a href="http://www.open.collab.net/scdocs/ddUsingSVN_command-line.html.zh-cn">SVN 命令行</a> </li></ul><h4 id="Mercurial相关："><a href="#Mercurial相关：" class="headerlink" title="Mercurial相关："></a>Mercurial相关：</h4><ul><li><a href="http://mercurial.selenic.com/">Mercurial</a>  | <a href="http://mercurial.selenic.com/wiki/ChineseTutorial">Mercurial 使用教程</a> </li><li><a href="http://hginit.com/">Hg Init: a Mercurial tutorial</a> </li><li><a href="http://hgbook.red-bean.com/">Mercurial: The Definitive Guide</a> <a href="http://hgbook.red-bean.com/read/">read</a> </li><li><a href="http://leeiio.me/googlecode-converting-svn-to-hg/">在Google Code上用 Mercurial 取代 Subversion 管理你的项目</a> </li><li><a href="http://www.cn-cuckoo.com/2010/03/20/distributed-version-control-is-here-to-stay-baby-1436.html">乔尔谈软件终结篇：分布式版本控制系统的时代到来了</a>  - 讲到了分布式版本控制的精髓：管理变更，而不是管理版本。</li><li><a href="http://stevelosh.com/blog/2010/08/a-git-users-guide-to-mercurial-queues/">A Git User’s Guide to Mercurial Queues</a> </li></ul><ul><li>Mercurial托管服务：<a href="http://bitbucket.org/">Mercurial hosting - bitbucket.org</a>  | <a href="http://www.fogcreek.com/kiln/">KilnHg</a> </li></ul><h4 id="Git相关："><a href="#Git相关：" class="headerlink" title="Git相关："></a>Git相关：</h4><ul><li><a href="http://git-scm.com/">Git</a>  - the Fast Version Control System. </li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/index.html">Stanford出品的Git Magic教程</a> </li><li>最详细Git介绍：<a href="http://progit.org/">Pro Git</a>  (<a href="http://progit.org/book/">book</a> , <a href="http://progit.org/book/zh/">中文版</a> )</li><li><a href="http://help.github.com/">Git官方帮助文档</a> </li><li>简明教程：<a href="http://blog.csdn.net/chinalinuxzend/archive/2008/11/14/3292896.aspx">git 之五分钟教程</a>  | <a href="http://wangcong.org/blog/?p=283">进一步学习 Git</a>  | <a href="http://www.ibm.com/developerworks/cn/linux/l-git/">使用 Git 管理源代码</a>  | <a href="http://www.elias.cn/Develop/GitMini">分布式版本控制工具Git简明笔记</a>  | <a href="http://labs.chinamobile.com/mblog/225_2822">译文:GIT日常命令20来条</a> </li><li><a href="http://blog.leezhong.com/translate/2010/10/30/a-successful-git-branch.html">Git开发管理之道</a> </li><li>Git讨论：<a href="http://zh-cn.whygitisbetterthanx.com/">Why Git is Better than X</a>  | <a href="http://www.ibm.com/developerworks/cn/web/wa-git/">Git 改变了分布式 Web 开发规则</a>  | <a href="http://www.joomlagate.com/article/joomla-review/why-subversion-will-be-replaced-by-git-for-version-control/">为什么说 Git 将取代 SVN 做软件版本控制？</a> </li><li><a href="http://rubynroll.javaeye.com/blog/203133">SVN+GIT=鱼与熊掌兼得</a> </li><li>面向 Subversion 用户的 Git：<a href="http://www.ibm.com/developerworks/cn/linux/l-git-subversion-1/">一: 入门指南</a>  | <a href="http://www.ibm.com/developerworks/cn/linux/l-git-subversion-2/">面向 Subversion 用户的 Git，第 2 部分: 实施控制</a> </li><li><a href="http://www.jeffkit.info/2010/12/885/">Git的推广心得</a>  | <a href="http://www.jeffkit.info/2010/12/860/">你为神马不用git-flow呢?</a>  | <a href="http://www.jeffkit.info/2010/12/842/">开始实践git-flow</a> </li><li><a href="http://github.com/">github</a>  | <a href="http://jekyllrb.com/">jekyll</a>  | <a href="https://github.com/mojombo/jekyll">codes</a>  | <a href="https://github.com/mojombo/mojombo.github.com">demos</a>  | <a href="https://github.com/blog/272-github-pages">GitHub Pages</a>  | <a href="http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/">Publishing a Blog with GitHub Pages and Jekyll</a> </li></ul><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><ul><li><a href="http://xbeta.info/win-run.htm">用win+r启动程序和文档</a> </li><li><a href="http://lamp.linux.gov.cn/Linux/LFS-6.2/index.html">Linux彻底定制指南(Linux From Scratch)</a> </li><li><a href="http://www.douban.com/group/topic/14530790/">服务器和架构方面的一些文章</a> </li><li><a href="http://www.cnblogs.com/stephen-liu74/archive/2011/12/20/2285454.html">Linux Shell常用技巧(目录)</a> </li><li><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/04/2285640.html">Linux Shell高级技巧(目录)</a> </li><li><a href="http://wiki.ubuntu.org.cn/%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95">Ubuntu新手入门指引</a>  | <a href="http://wiki.ubuntu.org.cn/Ubuntu%E6%A1%8C%E9%9D%A2%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97">Ubuntu桌面入门指南</a> </li><li>终端(Terminal)：<a href="http://www.zsh.org/">zsh</a>  | <a href="http://zsh.sourceforge.net/">zsh.sf.net</a>  | <a href="http://linuxtoy.org/archives/zsh.html">终极Shell——Zsh</a>  | <a href="http://sofish.de/1685">把 Mac 上的 bash 换成 zsh</a>  | <a href="http://leeiio.me/bash-to-zsh-for-mac/">zsh – 给你的Mac不同体验的Terminal！</a>  | <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh@github</a> </li><li>网络监控：<a href="http://www.fiddler2.com/fiddler2/">Fiddler 2</a>  | <a href="http://www.httpwatch.com/">HttpWatch</a>  | <a href="http://www.charlesproxy.com/">Charles</a> </li></ul><h4 id="远程控制："><a href="#远程控制：" class="headerlink" title="远程控制："></a>远程控制：</h4><ul><li>SSH技巧详解：<a href="http://matt.might.net/articles/ssh-hacks/">SSH: More than secure shell</a> </li><li>SSH：<a href="http://fuse.sourceforge.net/sshfs.html">SSH Filesystem</a>  | <a href="http://wowubuntu.com/sshfs.html">在 Ubuntu 上使用 sshfs 映射远程 ssh 文件系统为本地磁盘</a>  | <a href="http://code.google.com/p/macfuse/">MacFUSE</a>  | <a href="http://www.macupdate.com/app/mac/23721/sshfs-for-mac-os-x">sshfs for Mac OS X</a> </li><li>SecureCRT：<a href="http://www.vandyke.com/products/securecrt/index.html">SecureCRT</a>  | <a href="http://www.cnblogs.com/ztf2008/archive/2009/09/11/1564979.html">SecureCRT 常用命令</a> </li><li>PuTTY：<a href="http://www.putty.org/">PuTTY</a>  | <a href="http://code.google.com/p/puttycn/">PuTTY 中文版</a>  | <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY: A Free Telnet/SSH Client</a>  | <a href="http://chaifeng.com/blog/2007/06/putty_200611.html">PuTTY 中文教程</a>  | <a href="https://docs.google.com/View?docid=ajbgz6fp3pjh_2dwwwwt">@google docs</a>  | <a href="http://blog.csdn.net/niuniuchou/archive/2010/03/16/5387250.aspx">转</a>  | <a href="http://zh.wikipedia.org/wiki/PuTTY">@wikipedia</a> </li><li>cURL：<a href="http://curl.haxx.se/">cURL and libcurl</a>  | <a href="http://curl.haxx.se/docs/">docs</a>  | <a href="http://php.net/manual/en/book.curl.php">PHP: cURL - Manual</a>  | <a href="http://www.vimer.cn/2010/03/libcurl%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.html">libcurl的使用总结（一）</a>  | <a href="http://www.vimer.cn/2010/03/libcurl%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.html">libcurl的使用总结（二）</a> </li><li>rsync：<a href="http://rsync.samba.org/">rsync</a>  | <a href="http://zh.wikipedia.org/zh-cn/Rsync">zh@wikipedia</a>  | <a href="http://en.wikipedia.org/wiki/Rsync">en@wikipedia</a>  | <a href="http://everythinglinux.org/rsync/">A Tutorial on Using</a>  | <a href="http://www.itefix.no/i2/node/10650">cwrsync - Rsync for Windows</a>  | <a href="http://wowubuntu.com/rsync.html">如何用 Rsync 来备份 Linux 文件</a>  | <a href="http://www.dbanotes.net/techmemo/aix_rsync.html">AIX 上配置 rsync 简记</a>  | <a href="http://www.dbanotes.net/techmemo/rsync_cwrsync_backup_dreamhost_to_windows.html">用 Rsync(cwRsync)备份 Dreamhost 到 Windows 上</a>  | <a href="http://www.dbanotes.net/techmemo/rsync_openssh.html">Rsync 与 OpenSSH 结合运用进行文件同步</a> </li></ul><h4 id="Email相关："><a href="#Email相关：" class="headerlink" title="Email相关："></a>Email相关：</h4><ul><li><a href="http://htmlemailboilerplate.com/">HTML Email Boilerplate - Email模板</a> </li><li><a href="http://blog.miniasp.com/post/2008/02/06/How-to-send-Email-with-embedded-picture-image.aspx">如何發送內嵌圖片的 E-mail ( Inline Attachment )</a> </li><li><a href="http://www.tzwhx.com/newOperate/html/1/11/112/18550.html">发送内嵌图片邮件的正确方法</a> </li><li><a href="http://www.oschina.net/bbs/thread/8428">使用 Commons-Email 在邮件内容中直接嵌入图片</a> </li><li><a href="http://www.iteedu.com/webtech/j2ee/springdiary/93.php">内嵌图片或附档</a> </li><li><a href="http://inlinestyler.torchboxapps.com/">HTML email inline styler</a> </li><li><a href="http://www.ajaxapp.com/2009/03/01/css-to-inline-styles-converter/">CSS to inline styles converter</a> </li></ul><h2 id="设计相关"><a href="#设计相关" class="headerlink" title="设计相关"></a>设计相关</h2><h4 id="图片、图标-Icons-："><a href="#图片、图标-Icons-：" class="headerlink" title="图片、图标(Icons)："></a>图片、图标(Icons)：</h4><ul><li><a href="http://speckyboy.com/2011/12/12/top-50-web-development-design-and-application-icon-sets-from-2011/">2011年50个最佳图标设计集合</a> </li><li><a href="http://findicons.com/">FindIcons图标搜索引擎</a> </li><li><a href="http://www.iconarchive.com/">Icon Archive</a> </li><li><a href="http://www.iconspedia.com/">PNG icons &amp; Icons Picks Download</a> </li><li><a href="http://dryicons.com/">DryIcons - Free Icons and Vector Graphics</a> </li><li><a href="http://www.iconeasy.com/">Icon Easy</a> </li><li><a href="http://www.tutorial9.net/">Tutorial9 | Photoshop Tutorials, Photography Tuts, and Resources</a> </li><li><a href="http://thedesignmag.com/16-sketchy-hand-drawn-icon-sets.html">16 Sketchy Hand Drawn Icon Sets</a> </li><li><a href="http://people.freedesktop.org/~jimmac/icons/">Gnome Icon Theme</a> </li><li><a href="http://www.dutchicon.com/">dutch icon?</a> </li><li><a href="http://openiconlibrary.sourceforge.net/">开源图标库</a> </li><li>PhotoShop：<a href="http://www.blueidea.com/tech/graph/2003/672.asp">PhotoShop通道白解</a>  | <a href="http://zhidao.baidu.com/question/293029002.html">PhotoShop CS5序列号</a> </li></ul><h4 id="字体："><a href="#字体：" class="headerlink" title="字体："></a>字体：</h4><ul><li><a href="http://zh.wikipedia.org/wiki/%E8%A1%AC%E7%BA%BF%E4%BD%93">什么是衬线体</a> </li><li><a href="http://wenq.org/">文泉驿</a>  - 开源字体。开彼源兮，斯流永继。</li><li><a href="http://www.cnbeta.com/articles/102609.htm">让代码更美:10大编程字体</a> </li><li><a href="http://www.typeisbeautiful.com/">Type is Beautiful</a>  - 字体排版</li><li><a href="http://code.google.com/webfonts">Google Font Directory</a> </li><li><a href="http://www.network-science.de/ascii/">ASCII Generator</a> </li><li>假文填充：<a href="http://zh.wikipedia.org/zh-cn/Lorem_ipsum">Lorem ipsum</a>  | <a href="http://more.handlino.com/">中文假文MoreText.js</a> <a href="http://github.com/c9s/more.vim">MoreText的Vim插件</a>  | <a href="http://www.richyli.com/tool/loremipsum/">亂數假文產生器 Chinese Lorem Ipsum</a> </li></ul><h4 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h4><ul><li><a href="http://article.yeeyan.org/view/155461/108136">15个优秀的表格设计技巧</a> </li><li><a href="http://www.askthecssguy.com/2007/08/creating_a_table_with_dynamica.html">Creating a table with dynamically highlighted columns like Crazy Eggs pricing table</a> </li><li><a href="http://www.junchenwu.com/2007/02/redesign_a_simple_table.html">越减越妙：简单表格的再设计</a> </li><li><a href="http://blog.bingo929.com/15-jquery-plugins-for-better-table-manipulation.html/comment-page-1">15款提高表格操作的jQuery插件</a> </li></ul><h4 id="资源："><a href="#资源：" class="headerlink" title="资源："></a>资源：</h4><ul><li><a href="http://dribbble.com/">Dribble：著名设计师聚合网站</a> </li><li><a href="http://www.zcool.com.cn/">站酷：交流设计、分享快乐</a> </li><li><a href="http://www.quanjing.com/">全景：创意图片库</a> </li><li><a href="http://designlol.net/">Designlol：全球设计精享</a> </li><li><a href="http://cn.designboom.com/">Designboom</a> </li><li>配色方案：<a href="http://www.colorschemer.com/">Color Schemer</a>  | <a href="http://kuler.adobe.com/">kuler</a>  | <a href="http://color.aurlien.net/">Piknik Color Picker</a> </li><li><a href="http://www.qianduan.net/80-more-absolutely-beautiful-dual-screen-wallpaper.html">80多个绝对漂亮的双屏壁纸</a> </li></ul><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><ul><li><a href="http://blog.longwin.com.tw/2009/03/choose-vim-color-scheme-2009/">配置挑选Vim颜色(Color Scheme)</a> </li><li><a href="http://scmbob.org/vim_fdm.html">VIM折叠简介</a> </li><li><a href="http://freewind.me/blog/20110912/102.html">FuzzyFinder快速查找文件</a> </li></ul><p>转自：<a href="https://www.luxiaolei.com/wiki">https://www.luxiaolei.com/wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Javascript&quot;&gt;&lt;a href=&quot;#Javascript&quot; class=&quot;headerlink&quot; title=&quot;Javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jqfundamentals.com/book/index.html&quot;&gt;jQuery Fundamentals&lt;/a&gt;  - jQuery 入门教程。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cn-cuckoo.com/deconstructed/index.html&quot;&gt;JavaScript库 代码解构&lt;/a&gt;  - 将JavaScript流行框架源代码条分缕析展现出来&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html&quot;&gt;深入理解Javascript系列&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html&quot;&gt;Script的defer和async的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/6441.html&quot;&gt;Javascript面向对象基础&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/addyosmani/backbone-fundamentals&quot;&gt;Backbone.js基础&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://unixpapa.com/js/key.html&quot;&gt;JavaScript Madness: Keyboard Events&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dailyjs.com/tags.html#frameworks&quot;&gt;Let’s Make Frameworks&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;国内公司JS框架：&lt;a href=&quot;http://kissyui.com/&quot;&gt;Kissy - Taobao&lt;/a&gt;  | &lt;a href=&quot;http://arale.alipay.net/&quot;&gt;Arale - Alipay&lt;/a&gt;  | &lt;a href=&quot;http://tangram.baidu.com/&quot;&gt;Tangram - Baidu&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://js1k.com/&quot;&gt;JS1K, 1k Javascript contest&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.json.org/&quot;&gt;JSON Home Page&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/molokoloco-coding-project/wiki/JavascriptBase&quot;&gt;NB JS Wiki(CSS、PHP、jQuery、Linux)&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://birdshome.cnblogs.com/archive/2006/05/28/IE_MemoryLeak.html&quot;&gt;理解并解决IE的内存泄漏方式&lt;/a&gt; &lt;a href=&quot;http://birdshome.cnblogs.com/archive/2006/06/01/ClosureReferences.html&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;http://birdshome.cnblogs.com/archive/2006/06/17/Cross_Page_Leaks.html&quot;&gt;3&lt;/a&gt; &lt;a href=&quot;http://birdshome.cnblogs.com/archive/2006/06/30/Pseudo_Leaks.html&quot;&gt;4&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb250448.aspx&quot;&gt;Understanding and Solving Internet Explorer Leak Patterns&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/rubylouvre/archive/2010/01/05/1639541.html&quot;&gt;Javscript Bind函数&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;Javscript设计模式&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;JSON工具：&quot;&gt;&lt;a href=&quot;#JSON工具：&quot; class=&quot;headerlink&quot; title=&quot;JSON工具：&quot;&gt;&lt;/a&gt;JSON工具：&lt;/h4&gt;</summary>
    
    
    
    <category term="资源导航" scheme="https://blog.fenxiangz.com/categories/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="工具" scheme="https://blog.fenxiangz.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Wiki" scheme="https://blog.fenxiangz.com/tags/Wiki/"/>
    
    <category term="整理" scheme="https://blog.fenxiangz.com/tags/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>V2ray 配置</title>
    <link href="https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-10-25_V2ray%E9%85%8D%E7%BD%AE.html"/>
    <id>https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-10-25_V2ray%E9%85%8D%E7%BD%AE.html</id>
    <published>2020-10-25T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><p>下载软件：</p><p><a href="https://github.com/yanue/V2rayU/releases/download/2.1.0/V2rayU.dmg">https://github.com/yanue/V2rayU/releases/download/2.1.0/V2rayU.dmg</a></p><p>配置教程：<br><a href="https://github.com/yanue/V2rayU/wiki/V2rayU%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">https://github.com/yanue/V2rayU/wiki/V2rayU%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E</a></p><h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><p>下载软件：<br><a href="https://github.com/2dust/v2rayN/releases/download/3.13/v2rayN-Core.zip">https://github.com/2dust/v2rayN/releases/download/3.13/v2rayN-Core.zip</a></p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>下载软件：<a href="https://github.com/2dust/v2rayNG/releases/download/1.2.4/v2rayNG_1.2.4.apk">https://github.com/2dust/v2rayNG/releases/download/1.2.4/v2rayNG_1.2.4.apk</a></p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>AppStore： Shadowrocket<br>教程：<br><a href="https://www.hijk.pw/shadowrocket-config-v2ray-tutorial/">https://www.hijk.pw/shadowrocket-config-v2ray-tutorial/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Mac&quot;&gt;&lt;a href=&quot;#Mac&quot; class=&quot;headerlink&quot; title=&quot;Mac&quot;&gt;&lt;/a&gt;Mac&lt;/h1&gt;&lt;p&gt;下载软件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yanue/V2rayU/releases/download/2.1.0/V2rayU.dmg&quot;&gt;https://github.com/yanue/V2rayU/releases/download/2.1.0/V2rayU.dmg&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他/V2ray" scheme="https://blog.fenxiangz.com/categories/%E5%85%B6%E4%BB%96-V2ray/"/>
    
    
    <category term="V2ray" scheme="https://blog.fenxiangz.com/tags/V2ray/"/>
    
  </entry>
  
  <entry>
    <title>MySQL什么时候会使用内部临时表?</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8.html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8.html</id>
    <published>2020-09-13T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.948Z</updated>
    
    <content type="html"><![CDATA[<p>1.union执行过程</p><p>首先我们创建一个表t1</p><pre><code>create table t1(id int primary key, a int, b int, index(a));delimiter ;;create procedure idata()begin  declare i int;  set i=1;  while(i&lt;=1000)do    insert into t1 values(i, i, i);    set i=i+1;  end while;end;;delimiter ;call idata();</code></pre><p>然后我们执行一下这条语句</p><pre><code>explain select 1000 as f union (select id from t1 order by id desc limit 2)</code></pre><p>首先说下union的语义，union的语义是取两个结果的并集，重复的保留一行,然后我们来看下explain的结果，第二行的key=PRIMARY，说明用到了主键索引。</p><p>第三行的Extra的Using temporary说明用到了临时表</p><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/1.png"></p><p>下面我们看下这条语句的执行流程：</p><p>1.创建一个临时表，只有f一个字段，且为主键</p><p>2.将1000这个数据插入临时表</p><p>3.子查询中步骤:</p><pre><code>       1.插入1000进入临时表,因为主键冲突，插入失败       2.插入第二行900，插入成功</code></pre><p>4.将临时表数据作为结果返回，并删除临时表</p><p>这个过程的流程图如下：<br><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/2.jpg"></p><p>如果我们把union改成union all，就不需要使用临时表了，因为union all是重复的也保留，</p><p>大家可以看到extra这一列已经没有了Using temporary</p><pre><code>explain select 1000 as f union all (select id from t1 order by id desc limit 2)</code></pre><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/3.png"></p><p>2.group by执行过程</p><p>我们来看下面这条语句:</p><pre><code>explain select id%10 as m, count(*) as c from t1 group by m;</code></pre><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/4.png"><br>可以看到explain结果</p><p>Using index(使用到了覆盖索引a，不需要回表); Using temporary(用到了临时表); Using filesort(对数据进行了排序)</p><p>这条语句的意思是将id%10进行分组统计，并按照m进行排序</p><p>执行流程如下:</p><p>1.创建临时表，增加m,c字段，m是主键</p><p>2.计算id%10的结果记为x</p><p>3.如果临时表里面没有主键为x的行，则插入(x,1)，如果有的话，就将该行的c值加1</p><p>4.遍历完成后，按照m字段排序返回结果给客户端</p><p>流程图如下</p><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/5.jpg"><br>接下来我们看下这条语句的执行结果</p><pre><code>explain select id%10 as m, count(*) as c from t1 group by m</code></pre><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/6.jpg"><br>其实，如果我们不需要对查询结果进行排序，我们可以加一个order by null</p><p>我们执行一下这条语句</p><pre><code>explain select id%10 as m, count(*) as c from t1 group by m order by null</code></pre><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/7.jpg"><br>可以看到这里没有进行排序，由于扫描是从表t的id是从1开始的，所以第一行是1</p><p>如果我们执行下列语句，会发生什么呢？</p><p>我们上面说的临时表，其实是内存临时表，如果我们把内存临时表的容量改的比我们要查询的数据的容量小，那么就会使用到磁盘临时表，磁盘临时表的默认引擎是innodb</p><pre><code>set tmp_table_size=1024;select id%100 as m, count(*) as c from t1 group by m order by null limit 10</code></pre><p>group by 优化方法–直接排序</p><p>其实在上面的关于从内存临时表转化成磁盘临时表是很浪费时间的，也就是说mysql，在执行过程中发现空间不够了，在转成磁盘临时表，但是如果我们直接告诉mysql，我要查询的数据很大，那么mysql优化器就会想到，既然你告诉我数据很大，那么我就直接用sort_buffer进行排序，如果sort_buffer内存不够大，会用到磁盘临时表辅助排序。</p><pre><code>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</code></pre><p><img src="./2020-09-13_MySQL%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/8.jpg"><br>小结一下:</p><p>1.如果我们不需要对统计结果进行排序，可以加上order by null省去排序流程。</p><p>2.尽量让排序过程用上内存临时表，可以通过适当调大tmp_table_size的值来避免用到磁盘临时表。</p><p>3.如果数据量实在太大，使用SQL_BIG_RESULT告诉优化器，直接使用排序算法。</p><p>原文：<a href="https://zhuanlan.zhihu.com/p/66847189">https://zhuanlan.zhihu.com/p/66847189</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.union执行过程&lt;/p&gt;
&lt;p&gt;首先我们创建一个表t1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table t1(id int primary key, a int, b int, index(a));
delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i&amp;lt;=1000)do
    insert into t1 values(i, i, i);
    set i=i+1;
  end while;
end;;
delimiter ;
call idata();&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/MySQL.png" type="image"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/tags/MySQL/"/>
    
    <category term="优化" scheme="https://blog.fenxiangz.com/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="临时表" scheme="https://blog.fenxiangz.com/tags/%E4%B8%B4%E6%97%B6%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 中的 Character Set 与 Collation</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-12_MySQL%E4%B8%AD%E7%9A%84Character_Set%E4%B8%8ECollation.html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-12_MySQL%E4%B8%AD%E7%9A%84Character_Set%E4%B8%8ECollation.html</id>
    <published>2020-09-12T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MySQL 应该算是目前最流行的数据库之一，经常建库建表的同学应该对 Character Set 和 Collation 这两个词不陌生。</p><p>虽然一直有接触，但我还是挺云里雾里的。直到前些天特地做了功课，才敢说有个比较清晰的了解，所以就有了这篇文章。</p><h2 id="Character-Set-与-Collation"><a href="#Character-Set-与-Collation" class="headerlink" title="Character Set 与 Collation"></a>Character Set 与 Collation</h2><p>简单地说，Character Set 是字符集，而 Collation 是比对方法，是两个不同维度的概念。</p><p>我们经常看到的 utf8、gbk、ascii 都是相互独立的字符集，即对 <a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/Unicode">Unicode</a> 的一套编码。看到一个比较有趣的解释，摘抄过来。</p><blockquote><p>打个比方，你眼前有一个苹果，苹果在英文里称之为「Apple」，在中文里称之为「苹果」。苹果这个实体的概念就是 Unicode，而 utf8 之类的可以认为是不同语言对苹果的不同称谓，本质上都是描述苹果这个实体。</p></blockquote><p>每套字符集有一系列与之对应的比对方法，比如 utf8 字符集对应 utf8_general_ci、utf8_unicode_ci 等比对方法，不同的比对方法下得到的搜索结果、排序结果不尽相同。</p><h2 id="utf8-与-utf8mb4"><a href="#utf8-与-utf8mb4" class="headerlink" title="utf8 与 utf8mb4"></a>utf8 与 utf8mb4</h2><p>抛开数据库，标准的 UTF-8 字符集编码是可以用 1 ~ 4 个字节去编码 21 位字符，这几乎包含了世界上所有能看见的语言。</p><p>然而 MySQL 中实现的 utf8 最长只使用了 3 个字节，也就是只支持到了 Unicode 中的 <a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/Unicode%25E5%25AD%2597%25E7%25AC%25A6%25E5%25B9%25B3%25E9%259D%25A2%25E6%2598%25A0%25E5%25B0%2584">基本多文本平面</a>。任何不在基本多文本平面的 Unicode 字符，都无法使用 MySQL 的 utf8 字符集存储。包括 Emoji 表情、一些不常用的汉字，以及任何新增的 Unicode 字符等等。</p><p>为了解决这个问题，MySQL 在 5.5.3 之后增加了 <code>utf8mb4</code> 字符编码，mb4 即 most bytes 4。简单说 utf8mb4 是 utf8 的超集并完全兼容 utf8，能够用四个字节存储更多的字符。<a href="https://link.zhihu.com/?target=https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html">官方手册</a> 中也有提到 utf8mb4 的解释，我摘抄部分过来。</p><blockquote><p>The <code>utfmb4</code> character set has these characteristics:</p></blockquote><ul><li>Supports BMP and supplementary characters.</li><li>Requires a maximum of four bytes per multibyte character.</li></ul><p><code>utf8mb4</code> contrasts with the <code>utf8mb3</code> character set, which supports only BMP characters and uses a maximum of three bytes per character:</p><ul><li>For a BMP character, <code>utf8mb4</code> and <code>utf8mb3</code> have identical storage characteristics: same code values, same encoding, same length.</li><li>For a supplementary character, <code>utf8mb4</code> requires four bytes to store it, whereas <code>utf8mb3</code> cannot store the character at all. When converting <code>utf8mb3</code> columns to <code>utf8mb4</code>, you need not worry about converting supplementary characters because there will be none.</li></ul><h2 id="utf8mb4-general-ci-与-utf8mb4-unicode-ci"><a href="#utf8mb4-general-ci-与-utf8mb4-unicode-ci" class="headerlink" title="utf8mb4_general_ci 与 utf8mb4_unicode_ci"></a>utf8mb4_general_ci 与 utf8mb4_unicode_ci</h2><p>utf8mb4 对应的比对方法中，常用的有 <code>utf8mb4_general_ci</code> 和 <code>utf8mb4_unicode_ci</code>。关于这两个的区别，可以看下 StackOverflow 上有一个相关的热门讨论：<a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/766809/whats-the-difference-between-utf8-general-ci-and-utf8-unicode-ci">What’s the difference between utf8_general_ci and utf8_unicode_ci</a>，这边引用一下 <a href="https://link.zhihu.com/?target=http://seanlook.com/">Sean’s Notes</a> 的翻译：</p><p>主要从排序准确性和性能两方面看：</p><ul><li><p>准确性</p></li><li><p><code>utf8mb4_unicode_ci</code> 基于标准的 Unicode 来排序和比较，能够在各种语言之间精确排序。</p></li><li><p><code>utf8mb4_general_ci</code> 没有实现 Unicode 排序规则，在遇到某些特殊语言或字符时，排序结果可能不是所期望的。</p></li><li><p>但是在绝大多数情况下，这种特殊字符的顺序可能不需要那么精确。比如 <code>*_unicode_ci</code> 把 <code>ß</code>、<code>Œ</code> 当成 <code>ss</code> 和 <code>OE</code> 来看，而 <code>*_general_ci</code> 会把它们当成 <code>s</code>、<code>e</code>，再如 <code>ÀÁÅåāă</code> 各自都与 <code>A</code> 相等。</p></li><li><p>性能</p></li><li><p><code>utf8mb4_general_ci</code> 在比较和排序的时候更快。</p></li><li><p><code>utf8mb4_unicode_ci</code> 在特殊情况下，Unicode 排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。</p></li><li><p>但是在绝大多数情况下，不会发生此类复杂比较。<code>*_general_ci</code> 理论上比 <code>*_unicode_ci</code> 可能快些，但相比现在的 CPU 来说，它远远不足以成为考虑性能的因素，索引涉及、SQL 设计才是。 我个人推荐是 <code>utf8mb4_unicode_ci</code>，将来 8.0 里也极有可能使用变为默认的规则。相比选择哪一种 collation，使用者应该更关心字符集与排序规则在数据库里的统一性。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>出于兼容性的考虑，对存储空间和性能没有特殊要求的场合下，建议使用 <code>utf8mb4</code> 字符集和 <code>utf8mb4_unicode_ci</code> 对比方法。</p><p>原文：<a href="https://zhuanlan.zhihu.com/p/64570524">https://zhuanlan.zhihu.com/p/64570524</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;MySQL 应该算是目前最流行的数据库之一，经常建库建表的同学应该对 Character Set 和 Collation 这两个词不陌生。&lt;/p&gt;
&lt;p&gt;虽然一直有接触，但我还是挺云里雾里的。直到前些天特地做了功课，才敢说有个比较清晰的了解，所以就有了这篇文章。&lt;/p&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/MySQL.png" type="image"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/tags/MySQL/"/>
    
    <category term="字符集" scheme="https://blog.fenxiangz.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
    <category term="Collation" scheme="https://blog.fenxiangz.com/tags/Collation/"/>
    
  </entry>
  
  <entry>
    <title>高性能 MySQL 阅读笔记 (2)</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-11_%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(2).html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-11_%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(2).html</id>
    <published>2020-09-11T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scheme与数据类型优化"><a href="#Scheme与数据类型优化" class="headerlink" title="Scheme与数据类型优化"></a>Scheme与数据类型优化</h2><h3 id="选择合适的类型"><a href="#选择合适的类型" class="headerlink" title="选择合适的类型"></a>选择合适的类型</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>更小的通常更好：尽可能把列的大小指定在合理的范围；</li><li>简单，例如：能用整型就用整型；避免字符串表示日期，应该用内建的日期和时间类型；ip应转成long存储等；</li><li>尽量避免默认值为 <code>NULL</code>，尤其是当需要在该列上创建索引的时候；</li><li>例外情况：如果是稀疏数据，比如很多行都为<code>NULL</code>，只有少部分数据为<code>NULL</code>，使用<code>NULL</code>可以很好的提高空间利用率；</li></ul><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li>有符号和无符号类型使用相同的存储空间，并具有相同的性能；</li><li>整数计算一般使用64位 <code>BIGINT</code>整数（一些聚合函数除外，它们使用 <code>DECIMAL</code> 或 <code>DOUBLE</code> 进行计算）；</li><li>整型可以指定宽度，例如：<code>INT(11)</code> ，对大多数应用没有意义：它不会影响合法范围，只是给一些交互功工具（例如：MySQL命令行终端）用来提示显示字符宽度。不影响存储和计算；</li></ul><h3 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h3><ul><li>高精度计算：<code>DECIMAL</code>  ，非CPU直接计算，通过MySQL服务器自身实现高精度计算，性能不如：<code>FLOAT</code>、<code>DOUBLE</code>；</li><li>大整数：<code>BIGINT</code>，可以把小数乘以小数位数（按精度需要，提高相应的倍数）来存储，可以提高计算性能；</li><li>浮点相对精度较低：<code>FLOAT</code>、<code>DOUBLE</code>，CPU直接支持浮点计算，精度不一定很高，但运算更快；</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><code>VARCHAR</code> ： 变长，省空间，更新时需要做更多额外的工作，容易碎片化；<br> <code>CHAR</code>：定长，占用固定的空间，不容易产生碎片；</p><ul><li>存储和存储引擎具体的实现有关；</li><li><code>VARCHAR</code> 需要额外1或2个字节记录字符串长度；</li><li>虽然<code>VARCHAR</code> 是变长存储，但也要控制好长度，例如：<code>VARCHAR(5)</code>和<code>VARCHAR(200)</code>对于存储 <code>hello</code> 来讲，空间开销是一样的，但在内存中保存时，通常会分配固定的大小来保持。在使用“内存临时表”进行排序或操作时会影响存储性能，在使用“磁盘临时表”进行排序时也一样，所以应该正确的分配空间；</li></ul><h3 id="BLOB-和-TEXT"><a href="#BLOB-和-TEXT" class="headerlink" title="BLOB 和 TEXT"></a><code>BLOB</code> 和 <code>TEXT</code></h3><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><code>BLOB</code>： 二进制存储，没有排序规则或字符集<br><code>TEXT</code>：有字符集和排序规则 （参考：<a href="https://tech.fenxiangz.com/topic/121/mysql-%E4%B8%AD%E7%9A%84-character-set-%E4%B8%8E-collation">MySQL 中的 Character Set 与 Collation</a>）</p><h4 id="查询和排序问题"><a href="#查询和排序问题" class="headerlink" title="查询和排序问题"></a>查询和排序问题</h4><ul><li>涉及变量：max_sort_length </li><li><code>BLOB</code> 和 <code>TEXT</code> 列的查询会使用磁盘临时表，严重影响性能，应该避免查询列（排序列）使用 <code>BLOB</code>  和  <code>TEXT</code> ；<br>如果无法避免时，通过使用 <code>SUBSTRING(column, length) </code> 将列值转换为字符串（ORDER BY 也同样适用），这样可以适用内存临时表进行计算，但要确保子串足够短，避免超过  <code>max_heap_table_size</code>  或  <code>tmp_table_size</code> ，超过以后又会使用磁盘临时表。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Scheme与数据类型优化&quot;&gt;&lt;a href=&quot;#Scheme与数据类型优化&quot; class=&quot;headerlink&quot; title=&quot;Scheme与数据类型优化&quot;&gt;&lt;/a&gt;Scheme与数据类型优化&lt;/h2&gt;&lt;h3 id=&quot;选择合适的类型&quot;&gt;&lt;a href=&quot;#选择合适的类型&quot; class=&quot;headerlink&quot; title=&quot;选择合适的类型&quot;&gt;&lt;/a&gt;选择合适的类型&lt;/h3&gt;&lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/MySQL.png" type="image"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/tags/MySQL/"/>
    
    <category term="性能优化" scheme="https://blog.fenxiangz.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="阅读笔记" scheme="https://blog.fenxiangz.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>高性能 MySQL - MySQL慢查询日志总结</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-10_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93.html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-10_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93.html</id>
    <published>2020-09-10T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.947Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.cnblogs.com/kerrycode/p/5593204.html">https://www.cnblogs.com/kerrycode/p/5593204.html</a></p><h2 id="慢查询日志概念"><a href="#慢查询日志概念" class="headerlink" title="慢查询日志概念"></a>慢查询日志概念</h2><pre><code> MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</code></pre><p>官方文档，关于慢查询的日志介绍如下（部分资料，具体参考官方相关链接）：</p><p>The slow query log consists of SQL statements that took more than long_query_time seconds to execute and required at least min_examined_row_limit rows to be examined. The minimum and default values of long_query_time are 0 and 10, respectively. The value can be specified to a resolution of microseconds. For logging to a file, times are written including the microseconds part. For logging to tables, only integer times are written; the microseconds part is ignored.</p><p>By default, administrative statements are not logged, nor are queries that do not use indexes for lookups. This behavior can be changed usinglog_slow_admin_statements and log_queries_not_using_indexes, as described later.</p><h2 id="慢查询日志相关参数"><a href="#慢查询日志相关参数" class="headerlink" title="慢查询日志相关参数"></a>慢查询日志相关参数</h2><p>MySQL 慢查询的相关参数解释：</p><p>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。</p><p>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p><p>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p><p>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p><p>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</p><p>log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p><h2 id="慢查询日志配置"><a href="#慢查询日志配置" class="headerlink" title="慢查询日志配置"></a>慢查询日志配置</h2><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p><pre><code>mysql&gt; show variables  like &#39;%slow_query_log%&#39;;+---------------------+-----------------------------------------------+| Variable_name       | Value                                         |+---------------------+-----------------------------------------------+| slow_query_log      | OFF                                           || slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |+---------------------+-----------------------------------------------+2 rows in set (0.00 sec)mysql&gt; set global slow_query_log=1;Query OK, 0 rows affected (0.09 sec)mysql&gt; show variables like &#39;%slow_query_log%&#39;;+---------------------+-----------------------------------------------+| Variable_name       | Value                                         |+---------------------+-----------------------------------------------+| slow_query_log      | ON                                            || slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |+---------------------+-----------------------------------------------+2 rows in set (0.00 sec)</code></pre><p>使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）。例如如下所示：</p><pre><code>mysql&gt; show variables like &#39;slow_query%&#39;;+---------------------+-----------------------------------------------+| Variable_name       | Value                                         |+---------------------+-----------------------------------------------+| slow_query_log      | OFF                                           || slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |+---------------------+-----------------------------------------------+2 rows in set (0.01 sec)</code></pre><p><img src="./2020-09-10_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/1.png"></p><p>修改my.cnf文件，增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器，如下所示</p><p>slow_query_log =1</p><p>slow_query_log_file=/tmp/mysql_slow.log</p><p><img src="./2020-09-10_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/2.png"></p><pre><code>mysql&gt; show variables like &#39;slow_query%&#39;;+---------------------+---------------------+| Variable_name       | Value               |+---------------------+---------------------+| slow_query_log      | ON                  || slow_query_log_file | /tmp/mysql_slow.log |+---------------------+---------------------+2 rows in set (0.00 sec)</code></pre><p>关于慢查询的参数slow_query_log_file ，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log（如果没有指定参数slow_query_log_file的话）</p><pre><code>mysql&gt; show variables like &#39;slow_query_log_file&#39;;+---------------------+-----------------------------------------------+| Variable_name       | Value                                         |+---------------------+-----------------------------------------------+| slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |+---------------------+-----------------------------------------------+1 row in set (0.00 sec)</code></pre><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？ 这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。关于运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。从MySQL 5.1开始，long_query_time开始以微秒记录SQL语句运行时间，之前仅用秒为单位记录。如果记录到表里面，只会记录整数部分，不会记录微秒部分。</p><pre><code>mysql&gt; show variables like &#39;long_query_time%&#39;;+-----------------+-----------+| Variable_name   | Value     |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec)mysql&gt; set global long_query_time=4;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &#39;long_query_time&#39;;+-----------------+-----------+| Variable_name   | Value     |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec)</code></pre><p>如上所示，我修改了变量long_query_time，但是查询变量long_query_time的值还是10，难道没有修改到呢？注意：使用命令 set global long_query_time=4修改后，需要重新连接或新开一个会话才能看到修改值。你用show variables like ‘long_query_time’查看是当前会话的变量值，你也可以不用重新连接会话，而是用show global variables like ‘long_query_time’; 如下所示：</p><p><img src="./2020-09-10_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/3.png"></p><p>在MySQL里面执行下面SQL语句，然后我们去检查对应的慢查询日志，就会发现类似下面这样的信息。</p><pre><code>mysql&gt; select sleep(3);+----------+| sleep(3) |+----------+|        0 |+----------+1 row in set (3.00 sec)[root@DB-Server ~]# more /tmp/mysql_slow.log/usr/sbin/mysqld, Version: 5.6.20-enterprise-commercial-advanced-log (MySQL Enterprise Server - Advanced Edition (Commercial)). started with:Tcp port: 0  Unix socket: (null)Time                 Id Command    Argument/usr/sbin/mysqld, Version: 5.6.20-enterprise-commercial-advanced-log (MySQL Enterprise Server - Advanced Edition (Commercial)). started with:Tcp port: 0  Unix socket: (null)Time                 Id Command    Argument# Time: 160616 17:24:35# User@Host: root[root] @ localhost []  Id:     5# Query_time: 3.002615  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0SET timestamp=1466069075;select sleep(3);</code></pre><p><img src="./2020-09-10_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/4.png"></p><p>log_output 参数是指定日志的存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p><pre><code>mysql&gt; show variables like &#39;%log_output%&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| log_output    | FILE  |+---------------+-------+1 row in set (0.00 sec)mysql&gt; set global log_output=&#39;TABLE&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &#39;%log_output%&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| log_output    | TABLE |+---------------+-------+1 row in set (0.00 sec)mysql&gt; select sleep(5) ;+----------+| sleep(5) |+----------+|        0 |+----------+1 row in set (5.00 sec)mysql&gt; mysql&gt; select * from mysql.slow_log;+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+| start_time          | user_host                 | query_time | lock_time | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text        | thread_id |+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+| 2016-06-16 17:37:53 | root[root] @ localhost [] | 00:00:03   | 00:00:00  |         1 |             0 |    |              0 |         0 |         1 | select sleep(3) |         5 || 2016-06-16 21:45:23 | root[root] @ localhost [] | 00:00:05   | 00:00:00  |         1 |             0 |    |              0 |         0 |         1 | select sleep(5) |         2 |+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+2 rows in set (0.00 sec)mysql&gt; </code></pre><p>系统变量log-queries-not-using-indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用full index scan的sql也会被记录到慢查询日志。</p><p>This option does not necessarily mean that no index is used. For example, a query that uses a full index scan uses an index but would be logged because the index would not limit the number of rows.</p><pre><code>mysql&gt; show variables like &#39;log_queries_not_using_indexes&#39;;+-------------------------------+-------+| Variable_name                 | Value |+-------------------------------+-------+| log_queries_not_using_indexes | OFF   |+-------------------------------+-------+1 row in set (0.00 sec)mysql&gt; set global log_queries_not_using_indexes=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &#39;log_queries_not_using_indexes&#39;;+-------------------------------+-------+| Variable_name                 | Value |+-------------------------------+-------+| log_queries_not_using_indexes | ON    |+-------------------------------+-------+1 row in set (0.00 sec)</code></pre><p>系统变量log_slow_admin_statements表示是否将慢管理语句例如ANALYZE TABLE和ALTER TABLE等记入慢查询日志</p><pre><code>mysql&gt; show variables like &#39;log_slow_admin_statements&#39;;+---------------------------+-------+| Variable_name             | Value |+---------------------------+-------+| log_slow_admin_statements | OFF   |+---------------------------+-------+1 row in set (0.00 sec)mysql&gt; </code></pre><p>系统变量log_slow_slave_statements 表示</p><p>By default, a replication slave does not write replicated queries to the slow query log. To change this, use thelog_slow_slave_statements system variable.</p><p>When the slow query log is enabled, this variable enables logging for queries that have taken more than long_query_time seconds to execute on the slave. This variable was added in MySQL 5.7.1. Setting this variable has no immediate effect. The state of the variable applies on all subsequent START SLAVE statements.</p><p>参数–log-short-format </p><p>The server writes less information to the slow query log if you use the –log-short-format option.<br>H2M_LI_HEADER<br><strong>Command-Line Format</strong><code>--log-short-format</code><strong>Permitted Values**</strong>Type**<code>boolean</code><strong>Default</strong><code>FALSE</code></p><p>另外，如果你想查询有多少条慢查询记录，可以使用系统变量。</p><pre><code>mysql&gt; show global status like &#39;%Slow_queries%&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| Slow_queries  | 2104  |+---------------+-------+1 row in set (0.00 sec)mysql&gt; </code></pre><p>日志分析工具mysqldumpslow</p><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow</p><p>查看mysqldumpslow的帮助信息：</p><pre><code>[root@DB-Server ~]# mysqldumpslow --helpUsage: mysqldumpslow [ OPTS... ] [ LOGS... ]Parse and summarize the MySQL slow query log. Options are  --verbose    verbose  --debug      debug  --help       write this text to standard output  -v           verbose  -d           debug  -s ORDER     what to sort by (al, at, ar, c, l, r, t), &#39;at&#39; is default                al: average lock time                ar: average rows sent                at: average query time                 c: count                 l: lock time                 r: rows sent                 t: query time    -r           reverse the sort order (largest last instead of first)  -t NUM       just show the top n queries  -a           don&#39;t abstract all numbers to N and strings to &#39;S&#39;  -n NUM       abstract numbers with at least n digits within names  -g PATTERN   grep: only consider stmts that include this string  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),               default is &#39;*&#39;, i.e. match all  -i NAME      name of server instance (if using mysql.server startup script)  -l           don&#39;t subtract lock time from total time</code></pre><p>-s, 是表示按照何种方式排序，</p><blockquote><p>c : 访问计数</p><p>l : 锁定时间</p><p>r : 返回记录</p><p>t : 查询时间</p><p>al : 平均锁定时间</p><p>ar : 平均返回记录数</p><p>at : 平均查询时间</p></blockquote><p>-t, 是top n的意思，即为返回前面多少条的数据；</p><p>-g, 后边可以写一个正则匹配模式，大小写不敏感的；</p><p>比如</p><p>得到返回记录集最多的10个SQL。</p><p>mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log</p><p>得到访问次数最多的10个SQL</p><p>mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log</p><p>得到按照时间排序的前10条里面含有左连接的查询语句。</p><p>mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log</p><p>另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。</p><p>mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more</p><p><strong>参考资料：</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_long_query_time">https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_long_query_time</a></p><p>作者：<a href="http://www.cnblogs.com/kerrycode/">潇湘隐者</a></p><p>出处：<a href="http://www.cnblogs.com/kerrycode/">http://www.cnblogs.com/kerrycode/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/5593204.html&quot;&gt;https://www.cnblogs.com/kerrycode/p/5593204.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;慢查询日志概念&quot;&gt;&lt;a href=&quot;#慢查询日志概念&quot; class=&quot;headerlink&quot; title=&quot;慢查询日志概念&quot;&gt;&lt;/a&gt;慢查询日志概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt; MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/MySQL.png" type="image"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/tags/MySQL/"/>
    
    <category term="性能优化" scheme="https://blog.fenxiangz.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="慢查" scheme="https://blog.fenxiangz.com/tags/%E6%85%A2%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>高性能 MySQL 阅读笔记 (1)</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-09_%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(1).html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/mysql/2020-09-09_%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(1).html</id>
    <published>2020-09-09T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="什么是性能？"><a href="#什么是性能？" class="headerlink" title="什么是性能？"></a>什么是性能？</h3><p>完成某件任务所需要的时间度量，也就是响应时间。</p><h3 id="什么是优化？"><a href="#什么是优化？" class="headerlink" title="什么是优化？"></a>什么是优化？</h3><p>在一定的工作负载下，尽可能地降低响应时间。</p><p>核心：找到时间花在哪里，这很重要。</p><h3 id="如何找？"><a href="#如何找？" class="headerlink" title="如何找？"></a>如何找？</h3><p>通过测量，所以测量是性能优化的关键方法。</p><h3 id="如何测量？"><a href="#如何测量？" class="headerlink" title="如何测量？"></a>如何测量？</h3><p>找到系统的可测量点，但首先需要系统可测量化的支持，然而实际情况是系统很少可以做到可测量化。</p><p>因为很难进行系统内部测量，所以我们只能尽可能通过外部去测量系统。</p><p>另外需要注意是的，无论是内部测量还是外部测量，数据都不一定是百分之百准确的。</p><p>举例：如果<code>SQL</code>慢查了，花费了10s，如果9.6s都在等待磁盘IO，那么追究其他的0.4s就没什么意义。</p><h1 id="理解性能优剖析"><a href="#理解性能优剖析" class="headerlink" title="理解性能优剖析"></a>理解性能优剖析</h1><h3 id="什么是值得优化的查询"><a href="#什么是值得优化的查询" class="headerlink" title="什么是值得优化的查询"></a>什么是值得优化的查询</h3><pre><code>1. 占系统总体性能影响比重大的；2. 投入成本低于优化后的收入；</code></pre><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>系统内部的异常</p><h3 id="未知的未知"><a href="#未知的未知" class="headerlink" title="未知的未知"></a>未知的未知</h3><p>性能优化过程发现了“丢失的时间”，比如：程序内部测量点发现耗时10s，但<code>MySQL</code>内部测量发现耗时是8s，那么丢失的2s可能就是没有测量到的，需要注意。</p><h3 id="注意平均值问题"><a href="#注意平均值问题" class="headerlink" title="注意平均值问题"></a>注意平均值问题</h3><p>平均值往往掩盖一些频率小但有性能问题的点</p><h1 id="对应用程序剖析"><a href="#对应用程序剖析" class="headerlink" title="对应用程序剖析"></a>对应用程序剖析</h1><p>增加测量点本身一定程度上会增加部分开销，但这部分开销如果远小于性能优化的贡献。<br>轻量级监控：为了尽可能降低性能监控开销，可以增加灰度测量点，只针对n%的概率进行监控。</p><h1 id="剖析MySQL"><a href="#剖析MySQL" class="headerlink" title="剖析MySQL"></a>剖析MySQL</h1><p>× 慢查日志</p><p>× 剖析单条查询</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h3 id=&quot;什么是性能？&quot;&gt;&lt;a href=&quot;#什么是性能？&quot; class=&quot;headerlink&quot; title=&quot;什么是性能？&quot;&gt;&lt;/a&gt;什么是性能？&lt;/h3&gt;&lt;p&gt;完成某件任务所需要的时间度量，也就是响应时间。&lt;/p&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/MySQL.png" type="image"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.fenxiangz.com/tags/MySQL/"/>
    
    <category term="性能优化" scheme="https://blog.fenxiangz.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="阅读笔记" scheme="https://blog.fenxiangz.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MSSQL · 最佳实践 ·  SQL Server备份策略</title>
    <link href="https://blog.fenxiangz.com/post/dateabase/MSSQL/2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5.html"/>
    <id>https://blog.fenxiangz.com/post/dateabase/MSSQL/2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5.html</id>
    <published>2020-09-08T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在上一期月报中我们分享了SQL Server三种常见的备份技术及工作方式，本期月报将分享如何充分利用三者的优点来制定SQL Server数据库的备份和还原策略以达到数据库快速灾难恢复能力。</p><p><a href="http://mysql.taobao.org/monthly/2017/11/03/">上期月报：MSSQL · 最佳实践 · SQL Server三种常见备份</a></p><h1 id="三个术语"><a href="#三个术语" class="headerlink" title="三个术语"></a>三个术语</h1><p>在详细介绍SQL Server的灾备策略之前，我们先简要介绍三个重要的术语：</p><ul><li>RTO (Recovery Time Objective)恢复时间目标，是指出现灾难后多长时间能成功恢复数据库，即企业可容许服务中断的最大时间长度。比如说灾难发生后一天内恢复成功，则RTO值就是二十四小时；</li><li>RPO (Recovery Point Objective)恢复点目标，是指服务恢复后，恢复回来的数据所对应的最新时间点。比如企业每天凌晨零晨进行完全备份一次，那么这个全备恢复回来的系统数据只会是最近灾难发生当天那个凌晨零时的资料；</li><li>ERT(Estimated Recovery Time)预估恢复时间，是指根据备份链路的长度和备份文件的大小以及设备的还原效率来估算的服务恢复时间。<br>从以上的三个术语解释来看，最优的灾备方案是RTO极小，即出现故障能够立马恢复数据；RPO无线接近故障时间点，即最少的数据丢失；ERT最小，即可快速恢复服务。但是，现实场景中的灾备方案往往很难达到如此优化的方案。</li></ul><h1 id="制定灾备策略"><a href="#制定灾备策略" class="headerlink" title="制定灾备策略"></a>制定灾备策略</h1><p>以上三个术语是衡量灾备方案和还原策略优劣的重要指标，我们的灾备策略的目标也是无限的靠近RTO、RPO和ERT的最优值。以下我们列举一个典型的灾备场景来分析和解答：<br>假设某个企业对SQL Server数据库DBA提出的灾难恢复要求是数据丢失不超过一小时（RPO不超过一小时），在尽可能短的时间内（RTO尽可能短）恢复应用数据库服务，且灾备策略必须具备任意时间点还原的能力。<br>综合上一期月报分享，我们先抛开灾备策略的优劣来看，我们看看三种典型的灾备策略方案是否可以实现RPO？</p><ul><li>每个小时一次完全备份：备份文件过大，备份还原效率低下，这种方案无法实现任意时间点的还原；</li><li>每天一个完全备份 + 每小时一个日志备份：解决了备份文件过大和效率问题，也可以实现任意时间点还原，但是拉长了日志还原链条；</li><li>每天一个完全备份 + 每六个小时一个差异备份 + 每小时一个日志备份：具备任意时间点还原的能力，综合了备份文件大小、效率和备份链条长度。<br>从这个分析来看，也恰好应证了上一期的月报中的结论，即：完全备份集是所有备份的基础，但数据量大且备份耗时；事务日志备份集相对较小且快速，但会拉长备份文件还原链条，增大还原时间开销；差异备份解决了事务日志备份链条过长的问题。</li></ul><h1 id="时间点恢复"><a href="#时间点恢复" class="headerlink" title="时间点恢复"></a>时间点恢复</h1><p>我们假设备份数据增量为每小时1GB，初始完全备份大小为100GB，按照时间维度计算每小时产生的备份集大小，统计如下：<br><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/1.png"></p><h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><p>假设我们非常重要的订单数据库，在13:30被人为的错误删除掉了，灾备系统在14:00进行了一个事务日志备份。那么，这个事务日志备份对我们业务的灾难恢复就非常关键和重要了，它使得我们有能力将数据库还原到13:29:59这个时间点。如此，我们只会丢失13:30 - 14:00之间的这半个小时的数据（实际上我们也有能力找回13:30 - 14:00）。但是，如果没有14:00这个事务日志备份文件，但存在13:00的事务日志备份文件的话，我们的系统数据会丢失13:00 - 14:00之间这一个小时的数据，一个小时的数据丢失是公司不被允许的。场景如下图展示：</p><p><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/2.png"></p><h2 id="模拟备份策略"><a href="#模拟备份策略" class="headerlink" title="模拟备份策略"></a>模拟备份策略</h2><p>我们可以使用以下方法模拟灾备方案和灾难恢复的步骤：</p><ul><li>第一步：创建测试数据库并修改为FULL模式</li><li>第二步：创建一个完全备份</li><li>第三步：每一个小时做一次事务日志备份</li><li>第四步：每六个小时做一个差异备份</li></ul><p>详细的模拟方法和语句如下所示：</p><pre><code>-- Create testing DBIF DB_ID(&#39;TestDR&#39;) IS NULL    CREATEDATABASE TestDR;GO-- Change Database to FULL Recovery Mode -- for time point recovery supportingALTERDATABASE [TestDR] SETRECOVERYFULLWITH NO_WAITGOUSE TestDRGO-- Create Testing TableIF OBJECT_ID(&#39;dbo.tb_DR&#39;, &#39;U&#39;) ISNOTNULLDROPTABLE dbo.tb_DRGOCREATETABLE dbo.tb_DR(    IDINTIDENTITY(1,1) NOTNULL PRIMARY KEY,    CommentVARCHAR(100) NULL,    Indate DATETIME NOTNULLDEFAULT(GETDATE()));GOUSE TestDRGO-- Init dataINSERTINTO dbo.tb_DR(Comment)SELECT&#39;Full Backup @ 00:00&#39;;-- Take Full BackupBACKUPDATABASE [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@00:00_FULL.bak&#39;WITH COMPRESSION,INIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 01:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@01:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 02:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@02:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 03:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@03:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 04:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@04:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 05:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@05:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;DIFF Backup @ 06:00&#39;;-- Take DIFF BackupBACKUPDATABASE [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@06:00_DIFF.bak&#39;WITH DIFFERENTIAL,COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 07:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@07:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 08:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@08:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 09:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@09:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 10:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@10:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 11:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@11:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;DIFF Backup @ 12:00&#39;;-- Take DIFF BackupBACKUPDATABASE [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@12:00_DIFF.bak&#39;WITH DIFFERENTIAL,COMPRESSION,NOINIT,STATS=5;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 13:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@13:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;-- This record is similate for point time recoveryINSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 13:29:59&#39;;WAITFOR DELAY &#39;00:00:02&#39;INSERTINTO dbo.tb_DR(Comment)SELECT&#39;Transaction Log Backup @ 14:00&#39;;-- Take TRN BackupBACKUPLOG [TestDR] TO DISK =N&#39;C:\Temp\TestDR_20171217@14:00_LOG.trn&#39;WITH COMPRESSION,NOINIT,STATS=5;-- Query DataSELECT * FROM dbo.tb_DR;</code></pre><p>我们看看测试表的数据情况，方框选中的这条数据是需要我们恢复出来的：<br><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/3.png"></p><p>我们也可以再次检查数据库备份历史记录，来确保灾备信息准确性：</p><pre><code>SELECTbs.database_name AS&#39;Database Name&#39;,bs.backup_start_date AS&#39;Backup Start&#39;,bs.backup_finish_date AS&#39;Backup Finished&#39;,DATEDIFF(MINUTE, bs.backup_start_date, bs.backup_finish_date) AS&#39;Duration (min)&#39;,bmf.physical_device_name AS&#39;Backup File&#39;,CASEWHEN bs.[type] = &#39;D&#39;THEN&#39;Full Backup&#39;WHEN bs.[type] = &#39;I&#39;THEN&#39;Differential Database&#39;WHEN bs.[type] = &#39;L&#39;THEN&#39;Log&#39;WHEN bs.[type] = &#39;F&#39;THEN&#39;File/Filegroup&#39;WHEN bs.[type] = &#39;G&#39;THEN&#39;Differential File&#39;WHEN bs.[type] = &#39;P&#39;THEN&#39;Partial&#39;WHEN bs.[type] = &#39;Q&#39;THEN&#39;Differential partial&#39;ENDAS&#39;Backup Type&#39;FROM msdb.dbo.backupmediafamily bmf WITH(NOLOCK)    INNERJOIN msdb..backupset bs WITH(NOLOCK)    ON bmf.media_set_id = bs.media_set_idWHERE bs.database_name = &#39;TestDR&#39;ORDERBY bs.backup_start_date ASC</code></pre><p>查询的灾备历史记录展示如下：<br><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/4.png"></p><p>从这个备份历史记录来看，和我们的测试表中的数据是吻合且对应起来的。</p><h2 id="灾难恢复步骤"><a href="#灾难恢复步骤" class="headerlink" title="灾难恢复步骤"></a>灾难恢复步骤</h2><p>接下来，我们需要根据TestDR数据库的备份文件，将数据库恢复到模拟时间点2017-12-17 23:04:45.130（即真实场景中的发生人为操作失误的时间点13:30），为了包含ID为15的这条数据，我们就恢复到2017-12-17 23:04:46.130时间点即可，然后检查看看ID等于15的这条记录是否存在，如果这条记录存在，说明我们备份和还原策略工作正常，否则无法实现公司的要求。为了试验的目的，我们先把TestDR数据库删除掉（真实环境，请不要随意删除数据库，这很危险）：</p><pre><code>-- for testing, drop db first.USE [master]GOALTERDATABASE [TestDR] SET  SINGLE_USER WITHROLLBACKIMMEDIATEGODROPDATABASE [TestDR]GO</code></pre><h3 id="恢复方案一：全备-日志备份"><a href="#恢复方案一：全备-日志备份" class="headerlink" title="恢复方案一：全备 + 日志备份"></a>恢复方案一：全备 + 日志备份</h3><p>为了实现灾难恢复，我们需要先把完全备份文件恢复，然后一个接一个的事务日志备份按时间升序恢复，在最后一个事务日志恢复的时候，使用STOPAT关键字恢复到时间点并把数据库Recovery回来带上线，详细的代码如下：</p><pre><code>USE [master]GO-- restore from full backupRESTOREDATABASE TestDRFROM DISK = &#39;C:\Temp\TestDR_20171217@00:00_FULL.bak&#39;WITH NORECOVERY, REPLACE-- restore from log backupRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@01:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@02:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@03:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@04:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@05:00_LOG.trn&#39;WITH NORECOVERY-- skip diff backup at 06:00RESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@07:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@08:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@09:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@10:00_LOG.trn&#39;WITH NORECOVERYRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@11:00_LOG.trn&#39;WITH NORECOVERY-- skip diff backup at 12:00RESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@13:00_LOG.trn&#39;WITH NORECOVERY-- restore from log and stop at 2017-12-17 23:04:46.130RESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@14:00_LOG.trn&#39;WITH STOPAT = &#39;2017-12-17 23:04:46.130&#39;, RECOVERY-- Double check test dataUSE TestDRGOSELECT * FROM dbo.tb_DR</code></pre><p>从测试表中的数据展示来看，我们已经成功的将ID为15的这条数据还原回来，即发生人为失误导致的数据丢失（灾难）已经恢复回来了。<br><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/5.png"></p><p>细心的你一定发现了这个恢复方案，使用的是完全备份 + 很多个事务日志备份来恢复数据的，这种方案的恢复链条十分冗长，在这里，恢复到第13个备份文件才找回了我们想要的数据。有没有更为简单，恢复更为简洁的灾难恢复方案呢？请看恢复方案二。</p><h3 id="恢复方案二：全备-差备-日志备份"><a href="#恢复方案二：全备-差备-日志备份" class="headerlink" title="恢复方案二：全备 + 差备 + 日志备份"></a>恢复方案二：全备 + 差备 + 日志备份</h3><p>为了解决完全备份 +  日志备份恢复链条冗长的问题，我们接下来采取一种更为简洁的恢复方案，即采用完全备份 + 差异备份 + 事务日志备份的方法来实现灾难恢复，方法如下：</p><pre><code>--=========FULL + DIFF + TRN LOGUSE [master]GO-- restore from full backupRESTOREDATABASE TestDRFROM DISK = &#39;C:\Temp\TestDR_20171217@00:00_FULL.bak&#39;WITH NORECOVERY, REPLACE-- restore from diff backupRESTOREDATABASE TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@12:00_DIFF.bak&#39;WITH NORECOVERY-- restore from trn logRESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@13:00_LOG.trn&#39;WITH NORECOVERY-- restore from log and stop at 2017-12-17 23:04:46.130RESTORELOG TestDR FROM DISK = &#39;C:\Temp\TestDR_20171217@14:00_LOG.trn&#39;WITH STOPAT = &#39;2017-12-17 23:04:46.130&#39;, RECOVERY-- Double check test dataUSE TestDRGOSELECT * FROM dbo.tb_DR</code></pre><p>从这个灾难恢复链路来看，将灾难恢复的步骤从13个备份文件减少到4个备份文件，链路缩短，方法变得更为简洁快速。当然同样可以实现相同的灾难恢复效果，满足公司的对数据RPO的要求。</p><p><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/6.png"></p><h3 id="恢复方案三：使用SSMS"><a href="#恢复方案三：使用SSMS" class="headerlink" title="恢复方案三：使用SSMS"></a>恢复方案三：使用SSMS</h3><p>当然灾难恢复的方法除了使用脚本以外，微软的SSMS工具通过IDE UI操作也是可以达到相同的效果，可以实现相同的功能，方法如下：右键点击你需要还原的数据库 =&gt; Tasks =&gt; Restore =&gt; Database，如下如所示：<br><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/7.png"><br> 选择Timeline =&gt; Specific date and time =&gt; 设置你需要还原到的时间点（这里选择2017-12-17 23:04:46） =&gt; 确定。<br><img src="./2020-09-08_MSSQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5_SQL_Server%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/8.png"><br>时间点恢复还原时间消耗取决于你数据库备份文件的大小，在我的例子中，一会功夫，就已经还原好你想要的数据库了。</p><h1 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h1><p>本期月报是继前一个月分享SQL Server三种常见的备份技术后的深入，详细讲解了如何制定灾备策略来满足企业对灾难恢复能力的要求，并以一个具体的例子来详细阐述了SQL Server灾备的策略和灾难恢复的方法，使企业在数据库灾难发生时，数据损失最小化。但是，这里还是有一个疑问暂时留给读者：为什么我们可以使用多种灾难恢复（我们这里只谈到了两种，实际上还有其他方法）的方法呢？到底底层的原理是什么的？预知后事如何，我们下期月报分享。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sqlbak.com/academy/point-in-time-recovery/">典型场景中的场景图</a></p><p><a href="https://sqlbak.com/academy/point-in-time-recovery/">Point-in-time recovery</a></p><p>原文：<a href="https://developer.aliyun.com/article/379022">https://developer.aliyun.com/article/379022</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;在上一期月报中我们分享了SQL Server三种常见的备份技术及工作方式，本期月报将分享如何充分利用三者的优点来制定SQL Server数据库的备份和还原策略以达到数据库快速灾难恢复能力。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mysql.taobao.org/monthly/2017/11/03/&quot;&gt;上期月报：MSSQL · 最佳实践 · SQL Server三种常见备份&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/MSSQL.png" type="image"/>
    
    
    <category term="MSSQL" scheme="https://blog.fenxiangz.com/categories/MSSQL/"/>
    
    
    <category term="备份" scheme="https://blog.fenxiangz.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
    <category term="MSSQL" scheme="https://blog.fenxiangz.com/tags/MSSQL/"/>
    
  </entry>
  
  <entry>
    <title>How to learn Spring Cloud – the practical way</title>
    <link href="https://blog.fenxiangz.com/post/java/spring/2020-09-02_How-to-learn-Spring-Cloud.html"/>
    <id>https://blog.fenxiangz.com/post/java/spring/2020-09-02_How-to-learn-Spring-Cloud.html</id>
    <published>2020-09-02T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.971Z</updated>
    
    <content type="html"><![CDATA[<p>I have recently spoken at a meetup about <a href="https://www.e4developer.com/2018/02/20/practical-choreography-with-spring-cloud-presentation/">Practical Choreography with Spring Cloud Stream</a>. It was a great event where I was asked many questions after the talk. One question got me thinking: <em>“What book about Spring Cloud do you recommend?” *which as it turns out boils down to *“How do you learn Spring Cloud?”.</em> I heard that question posed a few times before in different ways. Here, I will give you my answer on what I think is the best way of learning Spring Cloud.</p><p>With Spring Cloud being probably the hottest framework on JVM for integrating microservices, the interest in it is growing. Most people interested in the microservices are already familiar with Spring Boot. If you haven’t heard of it before, check out my <a href="https://www.e4developer.com/2018/01/16/microservices-toolbox-spring-boot/">Spring Boot introduction</a> blog post, and definitely see the <a href="https://projects.spring.io/spring-boot/">official site</a>– it has some very good <em>Getting Started Guides</em>.</p><p>With that out of the way, let’s look at learning Spring Cloud!</p><h3 id="Understand-the-Scope"><a href="#Understand-the-Scope" class="headerlink" title="Understand the Scope"></a>Understand the Scope</h3><p>The first thing to do when trying to learn something so big and diverse is understanding the scope. Learning Spring Cloud can mean many things. First of all, the Spring Cloud currently contains:</p><ul><li>Spring Cloud Config</li><li>Spring Cloud Netflix</li><li>Spring Cloud Bus</li><li>Spring Cloud for Cloud Foundry</li><li>Spring Cloud Cloud Foundry Service Broker</li><li>Spring Cloud Cluster</li><li>Spring Cloud Consul</li><li>Spring Cloud Security</li><li>Spring Cloud Sleuth</li><li>Spring Cloud Data Flow</li><li>Spring Cloud Stream</li><li>Spring Cloud Stream App Starters</li><li>Spring Cloud Task</li><li>Spring Cloud Task App Starters</li><li>Spring Cloud Zookeeper</li><li>Spring Cloud for Amazon Web Services</li><li>Spring Cloud Connectors</li><li>Spring Cloud Starters</li><li>Spring Cloud CLI</li><li>Spring Cloud Contract</li><li>Spring Cloud Gateway</li></ul><p>Wow! This is a lot to take in! Clearly, the number of different projects here means that you can’t learn it by simply going through them one by one with a hope of understanding or mastering Spring Cloud by the end of it.</p><p>So, what is the best strategy for learning such an extensive framework (or a <a href="https://www.e4developer.com/2018/01/22/spring-cloud-blueprint-for-successful-microservices/">microservice blueprint</a>, as I describe it in another article)? I think the most sensible ways of learning is understanding what you would like to use Spring Cloud for. Setting yourself a learning goal.</p><h3 id="Goal-Oriented-Learning"><a href="#Goal-Oriented-Learning" class="headerlink" title="Goal Oriented Learning"></a>Goal Oriented Learning</h3><p>What kind of learning goals are we talking about here? Let me give you a few ideas:</p><ul><li>Set up communication between microservices based on Spring Cloud Stream</li><li>Build microservices that use configuration provided by Spring Cloud Config</li><li>Build a small microservices system based on Orchestration- what is needed and how to use it</li><li>Test microservices with Spring Cloud Contract</li><li>Use Spring Cloud Data Flow to take data from one place, modify it and store it in Elastic Search</li></ul><p>If you are interested in learning some parts of Spring Cloud, think of an absolutely tiny project and build it! Once you have done it, you know that you understood at least the basics and you validated it by having something working. I will quote Stephen R. Covey here (author of  <em>“The 7 Habits of Highly Effective People”</em>):</p><blockquote><p>“to learn and not to do is really not to learn. To know and not to do is really not to know.”</p></blockquote><p>With topics as complex and broad as Spring Cloud, this quote rings very true!</p><h3 id="Study"><a href="#Study" class="headerlink" title="Study"></a>Study</h3><p>You picked your goal and you want to get started. What resources can help you? I will give you a few ideas here, but remember- the goal is to learn only as much as necessary in order to achieve your goal. Don’t learn much more just yet, as you may end up overwhelmed and move further away from completing your goal. There will be time to learn more in depth. Let’s assume that your goal is <em>Using Spring Cloud Config correctly</em> in your personal project. Here are the resources I recommend:</p><ul><li>Official <a href="https://cloud.spring.io/spring-cloud-config/#quick-start">Spring Cloud Config Quickstart</a> to get a basic idea</li><li>If you enjoy books and want to learn more Spring Cloud in the future – <a href="https://www.manning.com/books/spring-microservices-in-action">Spring Microservices in Action</a> is a great reference. Don’t read it all yet! Check out the chapters on Spring Cloud Configuration and read as much as necessary to know what to do.</li><li>If you use Pluralsight, then check out <a href="https://app.pluralsight.com/library/courses/java-microservices-spring-cloud-developing-services">Java Microservices with Spring Cloud: Developing Services</a> – a very good introduction! Again, start with the chapters on Spring Cloud Config.</li><li>You can google the topic and find articles like <a href="http://www.baeldung.com/spring-cloud-configuration">Quick Intro to Spring Cloud Configuration</a></li><li>You can even find <a href="https://www.youtube.com/watch?v=b2ih5RCuxTM">YouTube videos about Spring Cloud Config</a></li></ul><p>I really want to make a point here. There is a huge amount of resources out there, free or paid of very high quality. You can spend weeks just reviewing them, but this is a mistake. Chose what works for you and get moving towards your goal!</p><h3 id="Do-something-–-achieve-your-goal"><a href="#Do-something-–-achieve-your-goal" class="headerlink" title="Do something – achieve your goal"></a>Do something – achieve your goal</h3><p>Once you identified the resources you need, get on with your goal! If your goal was to learn about Spring Cloud Config- set up the server, get the clients connecting and experiment with it.</p><p>You should have enough information to complete your simple task. If you find that something is not working- great! That shows that you need to revisit the resources and correct your understanding.</p><p>If you completed your goal, but you want to experiment more with the tech- go for it! You have something working and playing with it is much more fun than reading dry tech documentation.</p><p>By playing with the technology you start to notice nuances and develop a deeper understanding. Understanding that will not be easily acquired by reading countless articles, as most things would just fly over your head.</p><h3 id="Study-Again"><a href="#Study-Again" class="headerlink" title="Study Again"></a>Study Again</h3><p>Once you completed your goal and played a little with the tech you should have a much better idea what you are dealing with. Now is the time to go deep! Read all you can around the area that you explored. See what you could have done differently, how it is used and what are the best practices.</p><p>Now, all the reading you will do will make much more sense and will be more memorable. Suddenly dry documentation turns into fascinating discoveries of what you could have done better. And the best of all- if something sounds really great- you have your test-bed to try it.</p><h3 id="Teach"><a href="#Teach" class="headerlink" title="Teach"></a>Teach</h3><p>Teaching others really helps with memorizing and understanding the subject. This is one of the reasons why I am writing this blog. You not only get a chance of sharing your knowledge but also learn yourself by teaching.</p><p>If blogging is not your thing, you can talk to your colleagues or friends about what you have been tinkering with. You may be confronted with questions or perspectives that you did not consider before- great! Another chance to make the learning more complete.</p><p>One thing to remember is- don’t be afraid to teach. Even if what you have just learned seems basic to you- it was not so basic before you started learning it! If you were in this position, then so must be countless others!</p><p>There is a value to the unique way you can explain the subject in your own way. Especially given your practical experience gained from the goal that you achieved.</p><h3 id="Staying-up-to-Date"><a href="#Staying-up-to-Date" class="headerlink" title="Staying up to Date"></a>Staying up to Date</h3><p>Spring Cloud is constantly changing and growing. If your ultimate goal is becoming an expert in this ecosystem, then you need to think about ways of staying up to date.</p><p>One thing that is pretty much a must is working with it. If you are not lucky enough to use it on your day job- make sure that you use it in your spare time. You could be building a personal project making use of the tech or simply tinker with it and try different things. What matters is that you actually get that hands-on experience.</p><p>The second part of staying fresh is knowing whats coming and reading other people experiences. Some of the sources I really enjoy following are:</p><ul><li>The <a href="https://spring.io/blog">Spring.io</a> blog with a very good newsletter</li><li><a href="http://www.baeldung.com/">Baeldung</a> – an amazing source of Spring related articles and a weekly newsletter</li><li><a href="https://www.infoq.com/microservices/">InfoQ Microservices</a> – huge and very active website maintained by multiple authors</li><li>Using Twitter to stay up to date and see what people are reading. I share plenty of articles on that topic with my <a href="https://twitter.com/bartoszjd">@bartoszjd</a> account.</li></ul><p>These are just some of the sources that I follow. There are countless others. The point is to choose some that you enjoy reading and keep an eye for exciting stuff.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Spring Cloud is a huge and fascinating set of tools for building microservices. It can’t be learned as a “single thing”. Using different goals is the best way of approaching this learning.</p><p>The idea presented here can be used for learning any technical concept. I found it extremely beneficial for myself and used it with success. I really recommend checking out SimpleProgrammer’s <a href="https://simpleprogrammer.com/learning-to-learn/">Learning to learn</a> article which describes very similar idea for learning new technologies or frameworks.</p><p>Happy learning!</p><p>原文：<a href="https://www.e4developer.com/2018/03/06/how-to-learn-spring-cloud-the-practical-way/">https://www.e4developer.com/2018/03/06/how-to-learn-spring-cloud-the-practical-way/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;I have recently spoken at a meetup about &lt;a href=&quot;https://www.e4developer.com/2018/02/20/practical-choreography-with-spring-cloud-presentation/&quot;&gt;Practical Choreography with Spring Cloud Stream&lt;/a&gt;. It was a great event where I was asked many questions after the talk. One question got me thinking: &lt;em&gt;“What book about Spring Cloud do you recommend?” *which as it turns out boils down to *“How do you learn Spring Cloud?”.&lt;/em&gt; I heard that question posed a few times before in different ways. Here, I will give you my answer on what I think is the best way of learning Spring Cloud.&lt;/p&gt;
&lt;p&gt;With Spring Cloud being probably the hottest framework on JVM for integrating microservices, the interest in it is growing. Most people interested in the microservices are already familiar with Spring Boot. If you haven’t heard of it before, check out my &lt;a href=&quot;https://www.e4developer.com/2018/01/16/microservices-toolbox-spring-boot/&quot;&gt;Spring Boot introduction&lt;/a&gt; blog post, and definitely see the &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;official site&lt;/a&gt;– it has some very good &lt;em&gt;Getting Started Guides&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;With that out of the way, let’s look at learning Spring Cloud!&lt;/p&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/java/spring-framework.png" type="image"/>
    
    
    <category term="Spring Cloud" scheme="https://blog.fenxiangz.com/categories/Spring-Cloud/"/>
    
    
    <category term="Java" scheme="https://blog.fenxiangz.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://blog.fenxiangz.com/tags/Spring/"/>
    
    <category term="Spring Cloud" scheme="https://blog.fenxiangz.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>字符集知识点</title>
    <link href="https://blog.fenxiangz.com/post/java/advance/2020-06-29_%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://blog.fenxiangz.com/post/java/advance/2020-06-29_%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2020-06-28T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="获取系统支持的字符集"><a href="#获取系统支持的字符集" class="headerlink" title="获取系统支持的字符集"></a><strong>获取系统支持的字符集</strong></h3><pre><code>Charset.availableCharsets();  // Java</code></pre><h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a><strong>编解码</strong></h3><p>编码：字符 -&gt; 字节 ；<br>解码：字节 -&gt; 字符；</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a><strong>字符集</strong></h3><h3 id="ASCII-American-Standard-Code-for-Information-Interchange"><a href="#ASCII-American-Standard-Code-for-Information-Interchange" class="headerlink" title="ASCII : American Standard Code for Information Interchange"></a>ASCII : American Standard Code for Information Interchange</h3><p>7 bit来表示一个字符，共计可以表示 128 种字符。</p><h3 id="IOS-8859-1"><a href="#IOS-8859-1" class="headerlink" title="IOS-8859-1"></a>IOS-8859-1</h3><p>8 bit来表示一个字符，一个字节表示一个字符，基于 ASCII 向后扩展，完全兼容 ASCII，共计可以表示 256 种字符。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>2个字节（16位）表示一个汉字。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>扩展了 GB2312， 增加生僻字。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>继续扩展了GBK。</p><h3 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h3><p>台湾，繁体字。</p><h3 id="Unicode-编码方式"><a href="#Unicode-编码方式" class="headerlink" title="Unicode 编码方式"></a>Unicode 编码方式</h3><p>全球统一字符，两个字节表示一个字符，256^2 个字符。</p><h3 id="UTF-Unicode-Translation-Format"><a href="#UTF-Unicode-Translation-Format" class="headerlink" title="UTF: Unicode Translation Format"></a>UTF: Unicode Translation Format</h3><p>由于 Unicode 存储问题（2个字节），诞生了 UTF，本质上 UTF 是一种存储方式，而不是编码方式。<br>UTF 存在： UTF-8，UTF-16 （UTF-16LE，UTF-16BE），UTF-32 。<br>UTF-16 ：ZERO WIDTH NO-BREAK SPACE : 0xFEFF (BE) ,  0xFFFE (LE)。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>变长字节表示形式，兼容： IOS-8859-1；<br>通过3个字节表示一个中文；</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>Byte Order Mark ， Windows遗留问题，BOM是用来判断文本文件是哪一种Unicode编码的标记，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。</p><p>在不同的Unicode编码中，对应的bom的二进制字节如下：</p><pre><code>FE FF     -- UTF16BEFF FE     -- UTF16LEEF BB BF  -- UTF8</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;获取系统支持的字符集&quot;&gt;&lt;a href=&quot;#获取系统支持的字符集&quot; class=&quot;headerlink&quot; title=&quot;获取系统支持的字符集&quot;&gt;&lt;/a&gt;&lt;strong&gt;获取系统支持的字符集&lt;/strong&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Charset.availableCharsets();  // Java&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;编解码&quot;&gt;&lt;a href=&quot;#编解码&quot; class=&quot;headerlink&quot; title=&quot;编解码&quot;&gt;&lt;/a&gt;&lt;strong&gt;编解码&lt;/strong&gt;&lt;/h3&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/java/basic/java_logo.png" type="image"/>
    
    
    <category term="Java 进阶" scheme="https://blog.fenxiangz.com/categories/Java-%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="字符集" scheme="https://blog.fenxiangz.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM-内存模型（jmm）和GC</title>
    <link href="https://blog.fenxiangz.com/post/java/advance/2020-06-28_java_jvm.html"/>
    <id>https://blog.fenxiangz.com/post/java/advance/2020-06-28_java_jvm.html</id>
    <published>2020-06-28T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.963Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.jianshu.com/p/76959115d486">https://www.jianshu.com/p/76959115d486</a></p><h2 id="1-CPU和内存的交互"><a href="#1-CPU和内存的交互" class="headerlink" title="1 CPU和内存的交互"></a>1 CPU和内存的交互</h2><p>了解jvm内存模型前，了解下cpu和计算机内存的交互情况。【因为Java虚拟机内存模型定义的访问操作与计算机十分相似】</p><p>有篇很棒的文章，从cpu讲到内存模型:<a href="https://www.jianshu.com/p/bf158fbb2432">什么是java内存模型</a></p><hr><p>在计算机中，cpu和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。</p><p>但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种情况。现在cpu和内存的交互大致如下。</p><p><img src="./2020-06-28_java_jvm/1.png"></p><p>cpu上加入了高速缓存这样做解决了处理器和内存的矛盾(一快一慢)，但是引来的新的问题 </p><p><strong>缓存一致性</strong></p><p>在多核cpu中，每个处理器都有各自的高速缓存(L1,L2,L3)，而主内存确只有一个 。</p><p>以我的pc为例,因为cpu成本高，缓存区一般也很小。</p><p><img src="./2020-06-28_java_jvm/2.png"></p><pre><code>CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找，每个cpu有且只有一套自己的缓存。</code></pre><blockquote><p>如何保证多个处理器运算涉及到同一个内存区域时，多线程场景下会存在缓存一致性问题，那么运行时保证数据一致性？</p><p>为了解决这个问题，各个处理器需遵循一些协议保证一致性。【如MSI，MESI啥啥的协议。。】</p></blockquote><p>大概如下</p><p><img src="./2020-06-28_java_jvm/3.png"></p><p>|-cpu与内存-|</p><p>在CPU层面，内存屏障提供了个充分必要条件</p><h3 id="1-1-1-内存屏障-Memory-Barrier"><a href="#1-1-1-内存屏障-Memory-Barrier" class="headerlink" title="1.1.1 内存屏障(Memory Barrier)"></a>1.1.1 内存屏障(Memory Barrier)</h3><p>CPU中，每个CPU又有多级缓存【上图统一定义为高速缓存】，一般分为L1,L2,L3，因为这些缓存的出现，提高了数据访问性能，避免每次都向内存索取，但是弊端也很明显，不能实时的和内存发生信息交换，分<strong>在不同CPU执行的不同线程对同一个变量的缓存值不同。</strong></p><ul><li>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。【内存屏障是硬件层的】</li></ul><h5 id="为什么需要内存屏障"><a href="#为什么需要内存屏障" class="headerlink" title="为什么需要内存屏障"></a>为什么需要内存屏障</h5><pre><code>由于现代操作系统都是多处理器操作系统，每个处理器都会有自己的缓存，可能存再不同处理器缓存不一致的问题，而且由于操作系统可能存在重排序，导致读取到错误的数据，因此，操作系统提供了一些内存屏障以解决这种问题.简单来说:1.在不同CPU执行的不同线程对同一个变量的缓存值不同，为了解决这个问题。2.用volatile可以解决上面的问题，不同硬件对内存屏障的实现方式不一样。java屏蔽掉这些差异，通过jvm生成内存屏障的指令。对于读屏障:在指令前插入读屏障，可以让高速缓存中的数据失效，强制从主内存取。</code></pre><h5 id="内存屏障的作用"><a href="#内存屏障的作用" class="headerlink" title="内存屏障的作用"></a>内存屏障的作用</h5><pre><code>cpu执行指令可能是无序的，它有两个比较重要的作用1.阻止屏障两侧指令重排序2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</code></pre><h4 id="volatile型变量"><a href="#volatile型变量" class="headerlink" title="volatile型变量"></a>volatile型变量</h4><p>当我们声明某个变量为volatile修饰时，这个变量就有了线程可见性，volatile通过在读写操作前后添加内存屏障。</p><p>用代码可以这么理解</p><pre><code>//相当于读写时加锁，保证及时可见性，并发时不被随意修改。publicclassSynchronizedInteger&#123;privatelong value;publicsynchronizedintget()&#123;return value;&#125;publicsynchronizedvoidset(long value)&#123;this.value = value;&#125;&#125;</code></pre><p>volatile型变量拥有如下特性</p><pre><code>可见性，对于一个该变量的读，一定能看到读之前最后的写入。防止指令重排序，执行代码时,为了提高执行效率,会在不影响最后结果的前提下对指令进行重新排序,使用volatile可以防止，比如单例模式双重校验锁的创建中有使用到，如(https://www.jianshu.com/p/b30a4d568be4)注意的是volatile不具有原子性，如volatile++这样的复合操作,这里感谢大家的指正。</code></pre><p>至于volatile底层是怎么实现保证不同线程可见性的，这里涉及到的就是硬件上的，被volatile修饰的变量在进行写操作时，会生成一个特殊的汇编指令，该指令会触发mesi协议，会存在一个总线嗅探机制的东西，简单来说就是这个cpu会不停检测总线中该变量的变化，如果该变量一旦变化了，由于这个嗅探机制，其它cpu会立马将该变量的cpu缓存数据清空掉，重新的去从主内存拿到这个数据。简单画了个图。</p><p><img src="./2020-06-28_java_jvm/4.png"></p><h2 id="2-Java内存区域"><a href="#2-Java内存区域" class="headerlink" title="2. Java内存区域"></a>2. Java内存区域</h2><blockquote><p>前提:本文讲的基本都是以Sun HotSpot虚拟机为基础的，Oracle收购了Sun后目前得到了两个【Sun的HotSpot和JRockit(以后可能合并这两个),还有一个是IBM的IBMJVM】</p></blockquote><p>之所以扯了那么多计算机内存模型，是因为java内存模型的设定符合了计算机的规范。</p><p><strong>Java程序内存的分配是在JVM虚拟机内存分配机制下完成</strong>。</p><p><strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><blockquote><p>简要言之，jmm是jvm的一种规范，定义了jvm的内存模型。它屏蔽了各种硬件和操作系统的访问差异，不像c那样直接访问硬件内存，相对安全很多，它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性。</p></blockquote><p>从下面这张图可以看出来，Java数据区域分为五大数据区域。这些区域各有各的用途，创建及销毁时间。</p><pre><code>其中方法区和堆是所有线程共享的，栈，本地方法栈和程序虚拟机则为线程私有的。</code></pre><p>根据java虚拟机规范，java虚拟机管理的内存将分为下面五大区域。</p><p><img src="./2020-06-28_java_jvm/5.png"></p><p>|-jmm-|</p><h3 id="2-1-五大内存区域"><a href="#2-1-五大内存区域" class="headerlink" title="2.1 五大内存区域"></a>2.1 五大内存区域</h3><h4 id="2-1-1-程序计数器"><a href="#2-1-1-程序计数器" class="headerlink" title="2.1.1 程序计数器"></a>2.1.1 程序计数器</h4><pre><code>程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。</code></pre><p><strong>为什么需要程序计数器</strong></p><blockquote><p>我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p><p>注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。<strong>这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域</strong>。</p></blockquote><h4 id="2-1-2-Java栈（虚拟机栈）"><a href="#2-1-2-Java栈（虚拟机栈）" class="headerlink" title="2.1.2 Java栈（虚拟机栈）"></a>2.1.2 Java栈（虚拟机栈）</h4><p>同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，<strong>栈描述的是Java方法执行的内存模型</strong>。</p><p><strong>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出，下图栈1先进最后出来】</strong></p><p>对于栈帧的解释参考 <a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/noKing/p/8167700.html">Java虚拟机运行时栈帧结构</a></p><pre><code>栈帧: 是用来存储数据和部分过程结果的数据结构。栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; here[在这里]栈帧大小确定时间: 编译期确定，不受运行期数据影响。</code></pre><p>通常有人将java内存区分为栈和堆，实际上java内存比这复杂，这么区分可能是因为我们最关注，与对象内存分配关系最密切的是这两个。</p><p><strong>平时说的栈一般指局部变量表部分。</strong></p><blockquote><p>局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。</p><p>reference类型:与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。</p><p>returnAddress类型:指向一条字节码指令的地址【深入理解Java虚拟机】<a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/29056872">怎么理解returnAddress</a></p></blockquote><p><img src="./2020-06-28_java_jvm/6.png"></p><p><strong>需要注意的是，局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。</strong></p><blockquote><p>Java虚拟机栈可能出现两种类型的异常：</p><ol><li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。</li><li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。</li></ol></blockquote><h4 id="2-1-3-本地方法栈"><a href="#2-1-3-本地方法栈" class="headerlink" title="2.1.3 本地方法栈"></a>2.1.3 本地方法栈</h4><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。</p><h4 id="2-1-4-堆"><a href="#2-1-4-堆" class="headerlink" title="2.1.4 堆"></a>2.1.4 堆</h4><p>对于大多数应用来说，<strong>堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制</strong>。因此需要重点了解下。</p><p>java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。</p><blockquote><p>即时编译器:可以把把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)</p><p>逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。</p><p><a href="https://www.jianshu.com/p/20bd2e9b1f03">参考逃逸分析</a></p></blockquote><blockquote><p>注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。</p><p>根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。</p><p>当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</p></blockquote><h4 id="2-1-5-方法区"><a href="#2-1-5-方法区" class="headerlink" title="2.1.5 方法区"></a>2.1.5 方法区</h4><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。</p><p>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。</p><blockquote><p>运行时常量池</p><p>是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。</p></blockquote><p>在老版jdk，方法区也被称为永久代【因为没有强制要求方法区必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。】</p><pre><code>jdk1.7开始逐步去永久代。从String.interns()方法可以看出来String.interns()native方法:作用是如果字符串常量池已经包含一个等于这个String对象的字符串，则返回代表池中的这个字符串的String对象，在jdk1.6及以前常量池分配在永久代中。可通过 -XX:PermSize和-XX:MaxPermSize限制方法区大小。publicclassStringIntern&#123;//运行如下代码探究运行时常量池的位置publicstaticvoidmain(String[] args)throwsThrowable&#123;//用list保持着引用 防止full gc回收常量池List&lt;String&gt; list =newArrayList&lt;String&gt;();int i =0;while(true)&#123;            list.add(String.valueOf(i++).intern());&#125;&#125;&#125;//如果在jdk1.6环境下运行 同时限制方法区大小 将报OOM后面跟着PermGen space说明方法区OOM，即常量池在永久代//如果是jdk1.7或1.8环境下运行 同时限制堆的大小  将报heap space 即常量池在堆中</code></pre><p><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/yingsong/p/5896207.html">idea设置相关内存大小设置</a></p><p>这边不用全局的方式，设置main方法的vm参数。</p><p>做相关设置，比如说这边设定堆大小。（-Xmx5m -Xms5m -XX:-UseGCOverheadLimit）</p><pre><code>这边如果不设置UseGCOverheadLimit将报java.lang.OutOfMemoryError: GC overhead limit exceeded，这个错是因为GC占用了多余98%（默认值）的CPU时间却只回收了少于2%（默认值）的堆空间。目的是为了让应用终止，给开发者机会去诊断问题。一般是应用程序在有限的内存上创建了大量的临时对象或者弱引用对象，从而导致该异常。虽然加大内存可以暂时解决这个问题，但是还是强烈建议去优化代码，后者更加有效，也可通过UseGCOverheadLimit避免[不推荐，这里是因为测试用，并不能解决根本问题]</code></pre><p><img src="./2020-06-28_java_jvm/7.png"></p><p><img src="./2020-06-28_java_jvm/8.png"></p><p><strong>jdk8真正开始废弃永久代，而使用元空间(Metaspace)</strong></p><blockquote><p>java虚拟机对方法区比较宽松，除了跟堆一样可以不存在连续的内存空间，定义空间和可扩展空间，还可以选择不实现垃圾收集。</p></blockquote><h4 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h4><p>在HotSpot虚拟机中。对象在内存中存储的布局分为</p><pre><code>1.对象头2.实例数据3.对齐填充</code></pre><h5 id="2-2-1-对象头【markword】"><a href="#2-2-1-对象头【markword】" class="headerlink" title="2.2.1 对象头【markword】"></a>2.2.1 对象头【markword】</h5><p>在32位系统下，对象头8字节，64位则是16个字节【未开启压缩指针，开启后12字节】。</p><pre><code>markword很像网络协议报文头，划分为多个区间，并且会根据对象的状态复用自己的存储空间。为什么这么做:省空间，对象需要存储的数据很多，32bit/64bit是不够的，它被设计成非固定的数据结构以便在极小的空间存储更多的信息，假设当前为32bit，在对象未被锁定情况下。25bit为存储对象的哈希码、4bit用于存储分代年龄，2bit用于存储锁标志位，1bit固定为0。</code></pre><p>不同状态下存放数据</p><p><img src="./2020-06-28_java_jvm/9.png"></p><p>这其中锁标识位需要特别关注下。<strong>锁标志位与是否为偏向锁对应到唯一的锁状态</strong>。</p><p>锁的状态分为四种<code>无锁状态</code>、<code>偏向锁</code>、<code>轻量级锁</code>和<code>重量级锁</code></p><p>不同状态时对象头的区间含义，如图所示。</p><p><img src="./2020-06-28_java_jvm/10.png"></p><p>|-对象头-|</p><p>HotSpot底层通过markOop实现Mark Word，具体实现位于<code>markOop.hpp</code>文件。</p><pre><code>markOop中提供了大量方法用于查看当前对象头的状态，以及更新对象头的数据，为synchronized锁的实现提供了基础。[比如说我们知道synchronized锁的是对象而不是代码，而锁的状态保存在对象头中，进而实现锁住对象]。</code></pre><p>关于对象头和锁之间的转换，网上大神总结</p><p><img src="./2020-06-28_java_jvm/11.png"></p><p>|-偏向锁轻量级锁重量级锁-|</p><h5 id="2-2-2-实例数据"><a href="#2-2-2-实例数据" class="headerlink" title="2.2.2 实例数据"></a>2.2.2 实例数据</h5><pre><code>存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。分配策略:相同宽度的字段总是放在一起，比如double和long</code></pre><h5 id="2-2-3-对齐填充"><a href="#2-2-3-对齐填充" class="headerlink" title="2.2.3 对齐填充"></a>2.2.3 对齐填充</h5><p>这部分没有特殊的含义，仅仅起到占位符的作用满足JVM要求。</p><pre><code>由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。</code></pre><h4 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h4><p>java程序需要通过引用(ref)数据来操作堆上面的对象，那么如何通过引用定位、访问到对象的具体位置。</p><pre><code>对象的访问方式由虚拟机决定，java虚拟机提供两种主流的方式1.句柄访问对象2.直接指针访问对象。(Sun HotSpot使用这种方式)</code></pre><p>参考<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/u011080472/article/details/51321769">Java对象访问定位</a></p><h5 id="2-3-1-句柄访问"><a href="#2-3-1-句柄访问" class="headerlink" title="2.3.1 句柄访问"></a>2.3.1 句柄访问</h5><blockquote><p>简单来说就是java堆划出一块内存作为句柄池,引用中存储对象的句柄地址,句柄中包含对象实例数据、类型数据的地址信息。</p><h5 id="优点-引用中存储的是稳定的句柄地址-在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。"><a href="#优点-引用中存储的是稳定的句柄地址-在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。" class="headerlink" title="优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。"></a>优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。</h5></blockquote><p><img src="./2020-06-28_java_jvm/12.png"></p><p>|-访问方式2-|</p><h5 id="2-3-2-直接指针"><a href="#2-3-2-直接指针" class="headerlink" title="2.3.2 直接指针"></a>2.3.2 直接指针</h5><blockquote><p>与句柄访问不同的是，ref中直接存储的就是对象的实例数据,但是类型数据跟句柄访问方式一样。</p><p>优点:优势很明显，就是速度快，<strong>相比于句柄访问少了一次指针定位的开销时间</strong>。【可能是出于Java中对象的访问时十分频繁的,平时我们常用的JVM HotSpot采用此种方式】</p></blockquote><p><img src="./2020-06-28_java_jvm/13.png"></p><p>|-访问方式1-|</p><h2 id="3-内存溢出"><a href="#3-内存溢出" class="headerlink" title="3.内存溢出"></a>3.内存溢出</h2><pre><code>两种内存溢出异常[注意内存溢出是error级别的]1.StackOverFlowError:当请求的栈深度大于虚拟机所允许的最大深度2.OutOfMemoryError:虚拟机在扩展栈时无法申请到足够的内存空间[一般都能设置扩大]</code></pre><p>java -verbose:class -version 可以查看刚开始加载的类，可以发现这两个类并不是异常出现的时候才去加载，而是jvm启动的时候就已经加载。这么做的原因是在vm启动过程中我们把类加载起来，并创建几个没有堆栈的对象缓存起来，只需要设置下不同的提示信息即可，当需要抛出特定类型的OutOfMemoryError异常的时候，就直接拿出缓存里的这几个对象就可以了。</p><p>比如说OutOfMemoryError对象，jvm预留出4个对象【固定常量】，这就为什么最多出现4次有堆栈的OutOfMemoryError异常及大部分情况下都将看到没有堆栈的OutOfMemoryError对象的原因。</p><p><a href="https://links.jianshu.com/go?to=http://lovestblog.cn/blog/2016/08/29/oom/">参考OutOfMemoryError解读</a></p><p>Snip20180904_8.png</p><p>两个基本的例子</p><pre><code>publicclassMemErrorTest&#123;publicstaticvoidmain(String[] args)&#123;try&#123;List&lt;Object&gt; list =newArrayList&lt;Object&gt;();for(;;)&#123;                list.add(newObject());//创建对象速度可能高于jvm回收速度&#125;&#125;catch(OutOfMemoryError e)&#123;            e.printStackTrace();&#125;try&#123;hi();//递归造成StackOverflowError 这边因为每运行一个方法将创建一个栈帧，栈帧创建太多无法继续申请到内存扩展&#125;catch(StackOverflowError e)&#123;            e.printStackTrace();&#125;&#125;publicstaticvoidhi()&#123;hi();&#125;&#125;</code></pre><p><img src="./2020-06-28_java_jvm/14.png"></p><h2 id="4-GC简介"><a href="#4-GC简介" class="headerlink" title="4.GC简介"></a>4.GC简介</h2><blockquote><p>GC(Garbage Collection)：即垃圾回收器，诞生于1960年MIT的Lisp语言，主要是用来回收，释放垃圾占用的空间。</p></blockquote><hr><p>java GC泛指java的垃圾回收机制，该机制是java与C/C++的主要区别之一，我们在日常写java代码的时候，一般都不需要编写内存回收或者垃圾清理的代码，也不需要像C/C++那样做类似delete/free的操作。</p><h2 id="4-1-为什么需要学习GC"><a href="#4-1-为什么需要学习GC" class="headerlink" title="4.1.为什么需要学习GC"></a>4.1.为什么需要学习GC</h2><blockquote><p>对象的内存分配在java虚拟机的自动内存分配机制下，一般不容易出现内存泄漏问题。但是写代码难免会遇到一些特殊情况，比如OOM神马的。。尽管虚拟机内存的动态分配与内存回收技术很成熟，可万一出现了这样那样的内存溢出问题，那么将难以定位错误的原因所在。</p></blockquote><p>对于本人来说，由于水平有限，而且作为小开发，并没必要深入到GC的底层实现，但至少想要说学会看懂gc及定位一些内存泄漏问题。</p><p>从三个角度切入来学习GC</p><blockquote><p>1.哪些内存要回收</p><p>2.什么时候回收</p><p>3.怎么回收</p></blockquote><p>哪些内存要回收</p><blockquote><p>java内存模型中分为五大区域已经有所了解。我们知道<code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code>，由线程而生，随线程而灭，其中栈中的栈帧随着方法的进入顺序的执行的入栈和出栈的操作，一个栈帧需要分配多少内存取决于具体的虚拟机实现并且在编译期间即确定下来【忽略JIT编译器做的优化，基本当成编译期间可知】，当方法或线程执行完毕后，内存就随着回收，因此无需关心。</p><p>而<code>Java堆</code>、<code>方法区</code>则不一样。方法区存放着类加载信息，但是一个接口中多个实现类需要的内存可能不太一样，一个方法中多个分支需要的内存也可能不一样【只有在运行期间才可知道这个方法创建了哪些对象没需要多少内存】，这部分内存的分配和回收都是动态的，gc关注的也正是这部分的内存。</p></blockquote><pre><code>Java堆是GC回收的“重点区域”。堆中基本存放着所有对象实例，gc进行回收前，第一件事就是确认哪些对象存活，哪些死去[即不可能再被引用]</code></pre><h2 id="4-2-堆的回收区域"><a href="#4-2-堆的回收区域" class="headerlink" title="4.2 堆的回收区域"></a>4.2 堆的回收区域</h2><pre><code>为了高效的回收，jvm将堆分为三个区域1.新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小2.老年代（Old Generation）3.永久代（Permanent Generation）【1.8以后采用元空间，就不在堆中了】</code></pre><p><a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/53613423/answer/135743258">GC为什么要分代-R大的回答</a></p><p><a href="https://links.jianshu.com/go?to=http://lovestblog.cn/blog/2016/10/29/metaspace/">关于元空间</a></p><h2 id="5-判断对象是否存活算法"><a href="#5-判断对象是否存活算法" class="headerlink" title="5 判断对象是否存活算法"></a>5 判断对象是否存活算法</h2><pre><code>1.引用计数算法早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。2.可达性分析算法目前主流的商用语言[如java、c#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。</code></pre><p><img src="./2020-06-28_java_jvm/15.png"></p><p>|-gc-|</p><p>可作为GC Roots的对象有四种</p><pre><code>①虚拟机栈(栈桢中的本地变量表)中的引用的对象，就是平时所指的java对象，存放在堆中。②方法区中的类静态属性引用的对象，一般指被static修饰引用的对象，加载类的时候就加载到内存中。③方法区中的常量引用的对象,④本地方法栈中JNI（native方法)引用的对象</code></pre><p>即使可达性算法中不可达的对象，也不是一定要马上被回收，还有可能被抢救一下。网上例子很多，基本上和深入理解JVM一书讲的一样<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/lwang_IT/article/details/78650168">对象的生存还是死亡</a></p><pre><code>要真正宣告对象死亡需经过两个过程。1.可达性分析后没有发现引用链2.查看对象是否有finalize方法，如果有重写且在方法内完成自救[比如再建立引用]，还是可以抢救一下，注意这边一个类的finalize只执行一次，这就会出现一样的代码第一次自救成功第二次失败的情况。[如果类重写finalize且还没调用过，会将这个对象放到一个叫做F-Queue的序列里，这边finalize不承诺一定会执行，这么做是因为如果里面死循环的话可能会时F-Queue队列处于等待，严重会导致内存崩溃，这是我们不希望看到的。]</code></pre><p><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/onlinemf/p/7044953.html">HotSpot虚拟机如何实现可达性算法</a></p><h2 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5 垃圾收集算法"></a>5 垃圾收集算法</h2><blockquote><p>jvm中，可达性分析算法帮我们解决了哪些对象可以回收的问题，垃圾收集算法则关心怎么回收。</p></blockquote><h3 id="5-1-三大垃圾收集算法"><a href="#5-1-三大垃圾收集算法" class="headerlink" title="5.1 三大垃圾收集算法"></a>5.1 三大垃圾收集算法</h3><pre><code>1.标记/清除算法【最基础】2.复制算法3.标记/整理算法jvm采用`分代收集算法`对不同区域采用不同的回收算法。</code></pre><p><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/fangfuhai/p/7203468.html?utm_source=itdadao&utm_medium=referral">参考GC算法深度解析</a></p><p><strong>新生代采用复制算法</strong></p><p>新生代中因为对象都是”朝生夕死的”，【深入理解JVM虚拟机上说98%的对象,不知道是不是这么多，总之就是存活率很低】，适用于复制算法【复制算法比较适合用于存活率低的内存区域】。它优化了标记/清除算法的效率和内存碎片问题，且JVM不以5:5分配内存【由于存活率低，不需要复制保留那么大的区域造成空间上的浪费，因此不需要按1:1【原有区域:保留空间】划分内存区域，而是将内存分为一块Eden空间和From Survivor、To Survivor【保留空间】，三者默认比例为8:1:1，优先使用Eden区，若Eden区满，则将对象复制到第二块内存区上。但是不能保证每次回收都只有不多于10%的对象存货，所以Survivor区不够的话，则会依赖老年代年存进行分配】。</p><p>GC开始时，对象只会存于Eden和From Survivor区域，To Survivor【保留空间】为空。</p><p>GC进行时，Eden区所有存活的对象都被复制到To Survivor区，而From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阈值(默认15是因为对象头中年龄战4bit，新生代每熬过一次垃圾回收，年龄+1)，则移到老年代，没有达到则复制到To Survivor。</p><p><strong>老年代采用<code>标记/清除算法</code>或<code>标记/整理算法</code></strong></p><p>由于老年代存活率高，没有额外空间给他做担保，必须使用这两种算法。</p><h3 id="5-2-枚举根节点算法"><a href="#5-2-枚举根节点算法" class="headerlink" title="5.2 枚举根节点算法"></a>5.2 枚举根节点算法</h3><p><code>GC Roots</code> 被虚拟机用来判断对象是否存活</p><blockquote><p>可作为GC Roos的节点主要是在一些全局引用【如常量或静态属性】、执行上下文【如栈帧中本地变量表】中。那么如何在这么多全局变量和本地变量表找到【枚举】根节点将是个问题。</p></blockquote><p>可达性分析算法需考虑</p><p>1.如果方法区几百兆，一个个检查里面的引用，将耗费大量资源。</p><p>2.在分析时，需保证这个对象引用关系不再变化，否则结果将不准确。【因此GC进行时需停掉其它所有java执行线程(Sun把这种行为称为‘Stop the World’)，即使是号称几乎不会停顿的CMS收集器，枚举根节点时也需停掉线程】</p><p>解决办法:实际上当系统停下来后JVM不需要一个个检查引用，而是通过OopMap数据结构【HotSpot的叫法】来标记对象引用。</p><p>虚拟机先得知哪些地方存放对象的引用，在类加载完时。HotSpot把对象内什么偏移量什么类型的数据算出来，在jit编译过程中，也会在特定位置记录下栈和寄存器哪些位置是引用，这样GC在扫描时就可以知道这些信息。【目前主流JVM使用准确式GC】</p><p>OopMap可以帮助HotSpot快速且准确完成GC Roots枚举以及确定相关信息。但是也存在一个问题，可能导致引用关系变化。</p><p>这个时候有个safepoint(安全点)的概念。</p><p>HotSpot中GC不是在任意位置都可以进入，而只能在safepoint处进入。 GC时对一个Java线程来说，它要么处在safepoint,要么不在safepoint。</p><p>safepoint不能太少，否则GC等待的时间会很久</p><p>safepoint不能太多，否则将增加运行GC的负担</p><p>安全点主要存放的位置</p><pre><code>1:循环的末尾 2:方法临返回前/调用方法的call指令后 3:可能抛异常的位置</code></pre><p>参考:<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/ITer_ZC/article/details/41847887">关于安全点safepoint</a></p><h2 id="6-垃圾收集器"><a href="#6-垃圾收集器" class="headerlink" title="6.垃圾收集器"></a>6.垃圾收集器</h2><pre><code>如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。年轻代收集器Serial、ParNew、Parallel Scavenge老年代收集器Serial Old、Parallel Old、CMS收集器特殊收集器G1收集器[新型，不在年轻、老年代范畴内]</code></pre><p><img src="./2020-06-28_java_jvm/16.png"></p><p>|-收集器，连线代表可结合使用-|</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h3 id="6-1-Serial"><a href="#6-1-Serial" class="headerlink" title="6.1 Serial"></a>6.1 Serial</h3><p>最基本、发展最久的收集器，在jdk3以前是gc收集器的唯一选择，Serial是单线程收集器，Serial收集器只能使用一条线程进行收集工作，在收集的时候必须得停掉其它线程，等待收集工作完成其它线程才可以继续工作。</p><pre><code>虽然Serial看起来很坑，需停掉别的线程以完成自己的gc工作，但是也不是完全没用的，比如说Serial在运行在Client模式下优于其它收集器[简单高效,不过一般都是用Server模式，64bit的jvm甚至没Client模式]</code></pre><p><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/wxw7blog/p/7221756.html">JVM的Client模式与Server模式</a></p><p>优点:对于Client模式下的jvm来说是个好的选择。适用于单核CPU【现在基本都是多核了】</p><p>缺点:收集时要暂停其它线程，有点浪费资源，多核下显得。</p><h3 id="6-2-ParNew收集器"><a href="#6-2-ParNew收集器" class="headerlink" title="6.2 ParNew收集器"></a>6.2 ParNew收集器</h3><p>可以认为是Serial的升级版，因为它支持多线程[GC线程]，而且收集算法、Stop The World、回收策略和Serial一样，就是可以有多个GC线程并发运行，它是HotSpot第一个真正意义实现并发的收集器。默认开启线程数和当前cpu数量相同【几核就是几个，超线程cpu的话就不清楚了 - -】，如果cpu核数很多不想用那么多，可以通过*-XX:ParallelGCThreads*来控制垃圾收集线程的数量。</p><pre><code>优点:1.支持多线程，多核CPU下可以充分的利用CPU资源2.运行在Server模式下新生代首选的收集器【重点是因为新生代的这几个收集器只有它和Serial可以配合CMS收集器一起使用】缺点: 在单核下表现不会比Serial好，由于在单核能利用多核的优势，在线程收集过程中可能会出现频繁上下文切换，导致额外的开销。</code></pre><h3 id="6-3-Parallel-Scavenge"><a href="#6-3-Parallel-Scavenge" class="headerlink" title="6.3 Parallel Scavenge"></a>6.3 Parallel Scavenge</h3><p>采用复制算法的收集器，和ParNew一样支持多线程。</p><p>但是该收集器重点关心的是吞吐量【吞吐量 = 代码运行时间 / (代码运行时间 + 垃圾收集时间)  如果代码运行100min垃圾收集1min，则为99%】</p><p>对于用户界面，适合使用GC停顿时间短,不然因为卡顿导致交互界面卡顿将很影响用户体验。</p><p>对于后台</p><p>高吞吐量可以高效率的利用cpu尽快完成程序运算任务，适合后台运算</p><blockquote><p>Parallel Scavenge注重吞吐量，所以也成为”吞吐量优先”收集器。</p></blockquote><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h2 id="6-4-Serial-Old"><a href="#6-4-Serial-Old" class="headerlink" title="6.4 Serial Old"></a>6.4 Serial Old</h2><p>和新生代的Serial一样为单线程，Serial的老年代版本，不过它采用”标记-整理算法”，这个模式主要是给Client模式下的JVM使用。</p><p>如果是Server模式有两大用途</p><p>1.jdk5前和Parallel Scavenge搭配使用，jdk5前也只有这个老年代收集器可以和它搭配。</p><p>2.作为CMS收集器的后备。</p><h2 id="6-5-Parallel-Old"><a href="#6-5-Parallel-Old" class="headerlink" title="6.5 Parallel Old"></a>6.5 Parallel Old</h2><p>支持多线程，Parallel Scavenge的老年版本，jdk6开始出现， 采用”标记-整理算法”【老年代的收集器大都采用此算法】</p><p>在jdk6以前，新生代的Parallel Scavenge只能和Serial Old配合使用【根据图，没有这个的话只剩Serial Old，而Parallel Scavenge又不能和CMS配合使用】，而且Serial Old为单线程Server模式下会拖后腿【多核cpu下无法充分利用】，这种结合并不能让应用的吞吐量最大化。</p><blockquote><p>Parallel Old的出现结合Parallel Scavenge，真正的形成“吞吐量优先”的收集器组合。</p></blockquote><h3 id="6-6-CMS"><a href="#6-6-CMS" class="headerlink" title="6.6 CMS"></a>6.6 CMS</h3><p>CMS收集器(Concurrent Mark Sweep)是以一种获取最短回收停顿时间为目标的收集器。【重视响应，可以带来好的用户体验，被sun称为并发低停顿收集器】</p><pre><code>启用CMS：-XX:+UseConcMarkSweepGC</code></pre><p>正如其名，CMS采用的是”标记-清除”(Mark Sweep)算法，而且是支持并发(Concurrent)的</p><p>它的运作分为4个阶段</p><pre><code>1.初始标记:标记一下GC Roots能直接关联到的对象，速度很快2.并发标记:GC Roots Tarcing过程，即可达性分析3.重新标记:为了修正因并发标记期间用户程序运作而产生变动的那一部分对象的标记记录，会有些许停顿，时间上一般 初始标记 &lt; 重新标记 &lt; 并发标记4.并发清除</code></pre><p>以上初始标记和重新标记需要stw(停掉其它运行java线程)</p><p>之所以说CMS的用户体验好，是因为CMS收集器的内存回收工作是可以和用户线程一起并发执行。</p><p>总体上CMS是款优秀的收集器，但是它也有些缺点。</p><blockquote><p>1.cms堆cpu特别敏感，cms运行线程和应用程序并发执行需要多核cpu，如果cpu核数多的话可以发挥它并发执行的优势，但是cms默认配置启动的时候垃圾线程数为 (cpu数量+3)/4，它的性能很容易受cpu核数影响，当cpu的数目少的时候比如说为为2核，如果这个时候cpu运算压力比较大，还要分一半给cms运作，这可能会很大程度的影响到计算机性能。</p><p>2.cms无法处理浮动垃圾，可能导致Concurrent Mode Failure（并发模式故障）而触发full GC</p><p>3.由于cms是采用”标记-清除“算法,因此就会存在垃圾碎片的问题，为了解决这个问题cms提供了 <strong>-XX:+UseCMSCompactAtFullCollection</strong>选项，这个选项相当于一个开关【默认开启】，用于CMS顶不住要进行full GC时开启内存碎片合并，内存整理的过程是无法并发的，且开启这个选项会影响性能(比如停顿时间变长)</p></blockquote><pre><code>浮动垃圾:由于cms支持运行的时候用户线程也在运行，程序运行的时候会产生新的垃圾，这里产生的垃圾就是浮动垃圾，cms无法当次处理，得等下次才可以。</code></pre><h3 id="6-7-G1收集器"><a href="#6-7-G1收集器" class="headerlink" title="6.7 G1收集器"></a>6.7 G1收集器</h3><p>G1(garbage first:尽可能多收垃圾，避免full gc)收集器是当前最为前沿的收集器之一(1.7以后才开始有)，同cms一样也是关注降低延迟，是用于替代cms功能更为强大的新型收集器，因为它解决了cms产生空间碎片等一系列缺陷。</p><blockquote><p>摘自甲骨文:适用于 Java HotSpot VM 的低暂停、服务器风格的分代式垃圾回收器。G1 GC 使用并发和并行阶段实现其目标暂停时间，并保持良好的吞吐量。当 G1 GC 确定有必要进行垃圾回收时，它会先收集存活数据最少的区域（垃圾优先)</p><p>g1的特别之处在于它强化了分区，弱化了分代的概念，是区域化、增量式的收集器，它不属于新生代也不属于老年代收集器。</p><p>用到的算法为标记-清理、复制算法</p></blockquote><pre><code>jdk1.7,1.8的都是默认关闭的，更高版本的还不知道开启选项 -XX:+UseG1GC 比如在tomcat的catania.sh启动参数加上</code></pre><p>g1是区域化的，它将java堆内存划分为若干个大小相同的区域【region】，jvm可以设置每个region的大小(1-32m,大小得看堆内存大小，必须是2的幂),它会根据当前的堆内存分配合理的region大小。</p><blockquote><p><a href="https://links.jianshu.com/go?to=http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/gc_implementation/g1/heapRegion.cpp">jdk7中计算region的源码</a>,这边博主看了下也看不怎么懂，也翻了下openjdk8的看了下关于region的处理似乎不太一样。。</p></blockquote><p>g1通过并发(并行)标记阶段查找老年代存活对象，通过并行复制压缩存活对象【这样可以省出连续空间供大对象使用】。</p><p>g1将一组或多组区域中存活对象以增量并行的方式复制到不同区域进行压缩，从而减少堆碎片，目标是尽可能多回收堆空间【垃圾优先】，且尽可能不超出暂停目标以达到低延迟的目的。</p><p>g1提供三种垃圾回收模式 young gc、mixed gc 和 full gc,不像其它的收集器，根据区域而不是分代，新生代老年代的对象它都能回收。</p><p>几个重要的默认值，更多的查看官方文档<a href="https://links.jianshu.com/go?to=http://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html">oracle官方g1中文文档</a></p><pre><code>g1是自适应的回收器，提供了若干个默认值，无需修改就可高效运作-XX:G1HeapRegionSize=n  设置g1 region大小，不设置的话自己会根据堆大小算，目标是根据最小堆内存划分2048个区域-XX:MaxGCPauseMillis=200 最大停顿时间 默认200毫秒</code></pre><h2 id="7-Minor-GC、Major-GC、FULL-GC、mixed-gc"><a href="#7-Minor-GC、Major-GC、FULL-GC、mixed-gc" class="headerlink" title="7 Minor GC、Major GC、FULL GC、mixed gc"></a>7 Minor GC、Major GC、FULL GC、mixed gc</h2><h3 id="7-1-Minor-GC"><a href="#7-1-Minor-GC" class="headerlink" title="7.1 Minor GC"></a>7.1 Minor GC</h3><blockquote><p>在年轻代<code>Young space</code>(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC,Minor GC只会清理年轻代.</p></blockquote><h3 id="7-2-Major-GC"><a href="#7-2-Major-GC" class="headerlink" title="7.2 Major GC"></a>7.2 Major GC</h3><blockquote><p>Major GC清理老年代(old GC)，但是通常也可以指和Full GC是等价，因为收集老年代的时候往往也会伴随着升级年轻代，收集整个Java堆。所以有人问的时候需问清楚它指的是full GC还是old GC。</p></blockquote><h3 id="7-3-Full-GC"><a href="#7-3-Full-GC" class="headerlink" title="7.3 Full GC"></a>7.3 Full GC</h3><blockquote><p>full gc是对新生代、老年代、永久代【jdk1.8后没有这个概念了】统一的回收。</p><p>【知乎R大的回答:收集整个堆，包括young gen、old gen、perm gen（如果存在的话)、元空间(1.8及以上)等所有部分的模式】</p></blockquote><h3 id="7-4-mixed-GC【g1特有】"><a href="#7-4-mixed-GC【g1特有】" class="headerlink" title="7.4 mixed GC【g1特有】"></a>7.4 mixed GC【g1特有】</h3><blockquote><p>混合GC</p><p>收集整个young gen以及部分old gen的GC。只有G1有这个模式</p></blockquote><h2 id="8-查看GC日志"><a href="#8-查看GC日志" class="headerlink" title="8 查看GC日志"></a>8 查看GC日志</h2><h4 id="8-1-简单日志查看"><a href="#8-1-简单日志查看" class="headerlink" title="8.1 简单日志查看"></a>8.1 简单日志查看</h4><p>要看得懂并理解GC，需要看懂GC日志。</p><p>这边我在idea上试了个小例子，需要在idea配置参数(-XX:+PrintGCDetails)。</p><p><img src="./2020-06-28_java_jvm/17.png"></p><pre><code>publicclassGCtest&#123;publicstaticvoidmain(String[] args)&#123;for(int i =0; i &lt;10000; i++)&#123;List&lt;String&gt; list =newArrayList&lt;&gt;();            list.add(&quot;aaaaaaaaaaaaa&quot;);&#125;System.gc();&#125;&#125;[GC (System.gc()) [PSYoungGen: 3998K-&gt;688K(38400K)] 3998K-&gt;696K(125952K), 0.0016551 secs[本次回收时间]] [Times: user=0.01 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 688K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;603K(87552K)] 696K-&gt;603K(125952K), [Metaspace: 3210K-&gt;3210K(1056768K)], 0.0121034 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] Heap PSYoungGen[年轻代]      total 38400K, used 333K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)  eden space 33280K, 1% used [0x0000000795580000,0x00000007955d34a8,0x0000000797600000)  from space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)  to   space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000) ParOldGen[老年代]       total 87552K, used 603K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)  object space 87552K, 0% used [0x0000000740000000,0x0000000740096fe8,0x0000000745580000) Metaspace[元空间]      used 3217K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 352K, capacity 388K, committed 512K, reserved 1048576K</code></pre><h4 id="8-2-离线工具查看"><a href="#8-2-离线工具查看" class="headerlink" title="8.2 离线工具查看"></a>8.2 离线工具查看</h4><p>比如sun的<a href="https://links.jianshu.com/go?to=https://java.net/projects/gchisto">gchisto</a>，<a href="https://links.jianshu.com/go?to=https://github.com/chewiebug/GCViewer">gcviewer</a>离线分析工具，做个笔记先了解下还没用过，可视化好像很好用的样子。</p><h3 id="8-3-自带的jconsole工具、jstat命令"><a href="#8-3-自带的jconsole工具、jstat命令" class="headerlink" title="8.3 自带的jconsole工具、jstat命令"></a>8.3 自带的jconsole工具、jstat命令</h3><p>终端输入jconsole就会出现jdk自带的gui监控工具</p><p><img src="./2020-06-28_java_jvm/18.png"></p><p>|-jconsole-|</p><p>可以根据内存使用情况间接了解内存使用和gc情况</p><p><img src="./2020-06-28_java_jvm/19.png"></p><p>|-jconsole-|</p><p>jstat命令</p><p>比如jstat -gcutil pid查看对应java进程gc情况</p><p><img src="./2020-06-28_java_jvm/20.png"></p><p>|-jstat-|</p><pre><code>s0: 新生代survivor space0简称 就是准备复制的那块 单位为%s1:指新生代s1已使用百分比，为0的话说明没有存活对象到这边e:新生代eden(伊甸园)区域(%)o:老年代(%)ygc:新生代  次数ygct:minor gc耗时fgct:full gc耗时(秒)GCT: ygct+fgct 耗时</code></pre><h2 id="几个疑问"><a href="#几个疑问" class="headerlink" title="几个疑问"></a>几个疑问</h2><h3 id="1-GC是怎么判断对象是被标记的"><a href="#1-GC是怎么判断对象是被标记的" class="headerlink" title="1.GC是怎么判断对象是被标记的"></a>1.GC是怎么判断对象是被标记的</h3><p>通过枚举根节点的方式，通过jvm提供的一种oopMap的数据结构，简单来说就是不要再通过去遍历内存里的东西，而是通过OOPMap的数据结构去记录该记录的信息,比如说它可以不用去遍历整个栈，而是扫描栈上面引用的信息并记录下来。</p><p>总结:通过OOPMap把栈上代表引用的位置全部记录下来，避免全栈扫描，加快枚举根节点的速度，除此之外还有一个极为重要的作用，可以帮HotSpot实现准确式GC【这边的准确关键就是类型，可以根据给定位置的某块数据知道它的准确类型，HotSpot是通过oopMap外部记录下这些信息，存成映射表一样的东西】。</p><h3 id="2-什么时候触发GC"><a href="#2-什么时候触发GC" class="headerlink" title="2.什么时候触发GC"></a>2.什么时候触发GC</h3><p>简单来说，触发的条件就是GC算法区域满了或将满了。</p><pre><code>minor GC(young GC):当年轻代中eden区分配满的时候触发[值得一提的是因为young GC后部分存活的对象会已到老年代(比如对象熬过15轮)，所以过后old gen的占用量通常会变高]full GC:①手动调用System.gc()方法 [增加了full GC频率，不建议使用而是让jvm自己管理内存，可以设置-XX:+ DisableExplicitGC来禁止RMI调用System.gc]②发现perm gen（如果存在永久代的话)需分配空间但已经没有足够空间③老年代空间不足，比如说新生代的大对象大数组晋升到老年代就可能导致老年代空间不足。④CMS GC时出现Promotion Faield[pf]⑤统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间。这个比较难理解，这是HotSpot为了避免由于新生代晋升到老年代导致老年代空间不足而触发的FUll GC。比如程序第一次触发Minor GC后，有5m的对象晋升到老年代，姑且现在平均算5m，那么下次Minor GC发生时，先判断现在老年代剩余空间大小是否超过5m，如果小于5m，则HotSpot则会触发full GC(这点挺智能的)Promotion Faield:minor GC时 survivor space放不下[满了或对象太大]，对象只能放到老年代，而老年代也放不下会导致这个错误。Concurrent Model Failure:cms时特有的错误，因为cms时垃圾清理和用户线程可以是并发执行的，如果在清理的过程中可能原因：1 cms触发太晚，可以把XX:CMSInitiatingOccupancyFraction调小[比如-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC)]2 垃圾产生速度大于清理速度，可能是晋升阈值设置过小，Survivor空间小导致跑到老年代，eden区太小，存在大对象、数组对象等情况3.空间碎片过多，可以开启空间碎片整理并合理设置周期时间</code></pre><blockquote><p>full gc导致了concurrent mode failure，而不是因为concurrent mode failure错误导致触发full gc，真正触发full gc的原因可能是ygc时发生的promotion failure。</p></blockquote><h3 id="3-cms收集器是否会扫描年轻代"><a href="#3-cms收集器是否会扫描年轻代" class="headerlink" title="3.cms收集器是否会扫描年轻代"></a>3.cms收集器是否会扫描年轻代</h3><blockquote><p>会，在初始标记的时候会扫描新生代。</p><p>虽然cms是老年代收集器，但是我们知道年轻代的对象是可以晋升为老年代的，为了空间分配担保，还是有必要去扫描年轻代。</p></blockquote><h3 id="4-什么是空间分配担保"><a href="#4-什么是空间分配担保" class="headerlink" title="4.什么是空间分配担保"></a>4.什么是空间分配担保</h3><p>在minor gc前，jvm会先检查老年代最大可用空间是否大于新生代所有对象总空间，如果是的话，则minor gc可以确保是安全的，</p><blockquote><p>如果担保失败,会检查一个配置(HandlePromotionFailire),即是否允许担保失败。</p><p>如果允许:继续检查老年代最大可用可用的连续空间是否大于之前晋升的平均大小，比如说剩10m，之前每次都有9m左右的新生代到老年代，那么将尝试一次minor gc(大于的情况)，这会比较冒险。</p><p>如果不允许，而且还小于的情况，则会触发full gc。【为了避免经常full GC 该参数建议打开】</p><p>这边为什么说是冒险是因为minor gc过后如果出现大对象，由于新生代采用复制算法，survivor无法容纳将跑到老年代，所以才会去计算之前的平均值作为一种担保的条件与老年代剩余空间比较，这就是分配担保。</p><p>这种担保是动态概率的手段，但是也有可能出现之前平均都比较低，突然有一次minor gc对象变得很多远高于以往的平均值，这个时候就会导致担保失败【Handle Promotion Failure】，这就只好再失败后再触发一次FULL GC，</p></blockquote><h3 id="5-为什么复制算法要分两个Survivor，而不直接移到老年代"><a href="#5-为什么复制算法要分两个Survivor，而不直接移到老年代" class="headerlink" title="5.为什么复制算法要分两个Survivor，而不直接移到老年代"></a>5.为什么复制算法要分两个Survivor，而不直接移到老年代</h3><p>这样做的话效率可能会更高，但是old区一般都是熬过多次可达性分析算法过后的存活的对象，要求比较苛刻且空间有限，而不能直接移过去，这将导致一系列问题(比如老年代容易被撑爆)</p><p>分两个Survivor(from/to)，自然是为了保证复制算法运行以提高效率。</p><h3 id="6-各个版本的JVM使用的垃圾收集器是怎么样的"><a href="#6-各个版本的JVM使用的垃圾收集器是怎么样的" class="headerlink" title="6.各个版本的JVM使用的垃圾收集器是怎么样的"></a>6.各个版本的JVM使用的垃圾收集器是怎么样的</h3><p>准确来说，垃圾收集器的使用跟当前jvm也有很大的关系，比如说g1是jdk7以后的版本才开始出现。</p><p>并不是所有的垃圾收集器都是默认开启的，有些得通过设置相应的开关参数才会使用。比如说cms，需设置(XX:+UseConcMarkSweepGC)</p><p>这边有几个实用的命令，比如说server模式下</p><pre><code>#UnlockExperimentalVMOptions UnlockDiagnosticVMOptions解锁获取jvm参数，PrintFlagsFinal用于输出xx相关参数，以Benchmark类测试，这边会有很多结果 大都看不懂- - 在这边查(usexxxxxxgc会看到jvm不同收集器的开关情况)java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal Benchmark#后面跟| grep &quot;:&quot;获取已赋值的参数[加:代表被赋值过]java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal Benchmark| grep &quot;:&quot;#获得用户自定义的设置或者jvm设置的详细的xx参数和值java -server -XX:+PrintCommandLineFlags Benchmark</code></pre><p><img src="./2020-06-28_java_jvm/21.png"></p><p>本人用的jdk8，这边UseParallelGC为true，参考深入理解jvm那本书说这个是Parallel Scavenge+Serial old搭配组合的开关，但是网上又说8默认是Parallel Scavenge+Parallel Old,我还是信书的吧 - -。</p><p>更多相关参数<a href="https://links.jianshu.com/go?to=https://upload-images.jianshu.io/upload_images/4914401-4503c1ac0196db78.png">来源</a></p><p><img src="./2020-06-28_java_jvm/22.png"></p><p>|-常用参数-|</p><blockquote><p>据说更高版本的jvm默认使用g1</p></blockquote><h3 id="7-stop-the-world具体是什么，有没有办法避免"><a href="#7-stop-the-world具体是什么，有没有办法避免" class="headerlink" title="7 stop the world具体是什么，有没有办法避免"></a>7 stop the world具体是什么，有没有办法避免</h3><p>stop the world简单来说就是gc的时候，停掉除gc外的java线程。</p><p>无论什么gc都难以避免停顿，即使是g1也会在初始标记阶段发生，stw并不可怕，可以尽可能的减少停顿时间。</p><h3 id="8-新生代什么样的情况会晋升为老年代"><a href="#8-新生代什么样的情况会晋升为老年代" class="headerlink" title="8 新生代什么样的情况会晋升为老年代"></a>8 新生代什么样的情况会晋升为老年代</h3><p>对象优先分配在eden区，eden区满时会触发一次minor GC</p><blockquote><p>对象晋升规则</p><p>1 长期存活的对象进入老年代，对象每熬过一次GC年龄+1(默认年龄阈值15，可配置)。</p><p>2 对象太大新生代无法容纳则会分配到老年代</p><p>3 eden区满了，进行minor gc后，eden和一个survivor区仍然存活的对象无法放到(to survivor区)则会通过分配担保机制放到老年代，这种情况一般是minor gc后新生代存活的对象太多。</p><p>4 动态年龄判定，为了使内存分配更灵活，jvm不一定要求对象年龄达到MaxTenuringThreshold(15)才晋升为老年代，若survior区相同年龄对象总大小大于survior区空间的一半，则大于等于这个年龄的对象将会在minor gc时移到老年代</p></blockquote><h3 id="8-怎么理解g1，适用于什么场景"><a href="#8-怎么理解g1，适用于什么场景" class="headerlink" title="8.怎么理解g1，适用于什么场景"></a>8.怎么理解g1，适用于什么场景</h3><blockquote><p>G1 GC 是区域化、并行-并发、增量式垃圾回收器，相比其他 HotSpot 垃圾回收器，可提供更多可预测的暂停。增量的特性使 G1 GC 适用于更大的堆，在最坏的情况下仍能提供不错的响应。G1 GC 的自适应特性使 JVM 命令行只需要软实时暂停时间目标的最大值以及 Java 堆大小的最大值和最小值，即可开始工作。</p></blockquote><p>g1不再区分老年代、年轻代这样的内存空间，这是较以往收集器很大的差异，所有的内存空间就是一块划分为不同子区域，每个区域大小为1m-32m，最多支持的内存为64g左右，且由于它为了的特性适用于大内存机器。</p><p><img src="./2020-06-28_java_jvm/23.png"></p><p>|-g1回收时堆内存情况-|</p><p>适用场景:</p><p>1.像cms能与应用程序并发执行，GC停顿短【短而且可控】，用户体验好的场景。</p><p>2.面向服务端，大内存，高cpu的应用机器。【网上说差不多是6g或更大】</p><p>3.应用在运行过程中经常会产生大量内存碎片，需要压缩空间【比cms好的地方之一，g1具备压缩功能】。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>深入理解Java虚拟机</p><p><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/chenyangyao/p/5269622.html">JVM内存模型、指令重排、内存屏障概念解析</a></p><p><a href="https://www.jianshu.com/p/9c19eb0ea4d8">Java对象头</a></p><p><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/duke2016/p/6250766.html">GC收集器</a></p><p><a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/41922036/answer/93079526">Major GC和Full GC的区别</a></p><p><a href="https://links.jianshu.com/go?to=http://m635674608.iteye.com/blog/2236137">JVM 垃圾回收 Minor gc vs Major gc vs Full gc</a></p><p><a href="https://links.jianshu.com/go?to=http://rednaxelafx.iteye.com/blog/1044951">关于准确式GC、保守式GC</a></p><p><a href="https://www.jianshu.com/p/55670407fdb9">关于CMS垃圾收集算法的一些疑惑</a></p><p><a href="https://www.jianshu.com/p/2a1b2f17d3e4">图解cms</a></p><p><a href="https://www.jianshu.com/p/0f1f5adffdc1">G1垃圾收集器介绍</a></p><p><a href="https://links.jianshu.com/go?to=http://www.cnblogs.com/littleLord/p/5380624.html">详解cms回收机制</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题，而且写java代码的时候难免会经常和内存打交道，遇到各种内存溢出问题，有时候又难以定位问题，因此是一定要学习jmm以及GC的。</p><p>由于博主本人水平有限【目前还是小菜鸡】，所以花了点时间，写下这篇博客当做为笔记总结归纳，但是写博客这种事如果全都是照抄别人的成果就很没意思了，吸收别人的成果的同时，也希望自己有能力多写点自己独特的理解和干货后续继续更新，所以如果有哪里写的不好或写错请指出，以便我继续学习和改进。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载：&lt;a href=&quot;https://www.jianshu.com/p/76959115d486&quot;&gt;https://www.jianshu.com/p/76959115d486&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-CPU和内存的交互&quot;&gt;&lt;a href=&quot;#1-CPU和内存的交互&quot; class=&quot;headerlink&quot; title=&quot;1 CPU和内存的交互&quot;&gt;&lt;/a&gt;1 CPU和内存的交互&lt;/h2&gt;&lt;p&gt;了解jvm内存模型前，了解下cpu和计算机内存的交互情况。【因为Java虚拟机内存模型定义的访问操作与计算机十分相似】&lt;/p&gt;</summary>
    
    
    <content src="https://blog.fenxiangz.com/images/java/basic/java_logo.png" type="image"/>
    
    
    <category term="Java 进阶" scheme="https://blog.fenxiangz.com/categories/Java-%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="https://blog.fenxiangz.com/tags/Java/"/>
    
    <category term="jvm" scheme="https://blog.fenxiangz.com/tags/jvm/"/>
    
    <category term="垃圾回收" scheme="https://blog.fenxiangz.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Netty 知识点思维导图</title>
    <link href="https://blog.fenxiangz.com/post/java/netty/2020-05-26_Netty%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html"/>
    <id>https://blog.fenxiangz.com/post/java/netty/2020-05-26_Netty%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html</id>
    <published>2020-05-26T00:00:00.000Z</published>
    <updated>2020-12-20T16:47:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>右键新 Tab页打开查看大图</p><p><img src="./2020-05-26_Netty%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;右键新 Tab页打开查看大图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./2020-05-26_Netty%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    <content src="https://blog.fenxiangz.com/images/java/netty-logo.png" type="image"/>
    
    
    <category term="Netty" scheme="https://blog.fenxiangz.com/categories/Netty/"/>
    
    
    <category term="Java" scheme="https://blog.fenxiangz.com/tags/Java/"/>
    
    <category term="思维导图" scheme="https://blog.fenxiangz.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="Netty" scheme="https://blog.fenxiangz.com/tags/Netty/"/>
    
  </entry>
  
</feed>
