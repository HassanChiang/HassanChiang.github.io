<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="原创： zhangshaolin 张少林同学微信号: zhangshaolin_tonxue 功能介绍 分享 前言">
<meta property="og:type" content="article">
<meta property="og:title" content="从源码的角度再学「Thread」">
<meta property="og:url" content="https://blog.fenxiangz.com/post/java/basic/2019-01-21_java_thread_source.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="原创： zhangshaolin 张少林同学微信号: zhangshaolin_tonxue 功能介绍 分享 前言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.fenxiangz.com/assets/uploads/files/1548122247324-a77dcb75-2e68-4785-81f8-a4b242b67382-image.png">
<meta property="og:image" content="https://blog.fenxiangz.com/post/java/basic/2019-01-21_java_thread_source/java_thread_source_1.png">
<meta property="article:published_time" content="2019-01-21T09:46:24.000Z">
<meta property="article:modified_time" content="2020-12-20T16:47:02.965Z">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java线程">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.fenxiangz.com/assets/uploads/files/1548122247324-a77dcb75-2e68-4785-81f8-a4b242b67382-image.png">


<link rel="canonical" href="https://blog.fenxiangz.com/post/java/basic/2019-01-21_java_thread_source.html">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>从源码的角度再学「Thread」 | 分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%B3%A8%E9%87%8A%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">从注释开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">Thread 常用属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">Thread 构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="nav-number">5.0.1.</span> <span class="nav-text">设置线程名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="nav-number">5.0.2.</span> <span class="nav-text">获取线程名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.0.3.</span> <span class="nav-text">启动线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.0.4.</span> <span class="nav-text">设置守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.0.5.</span> <span class="nav-text">判断线程是否为守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">5.0.6.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="nav-number">5.0.7.</span> <span class="nav-text">线程休眠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="nav-number">5.0.8.</span> <span class="nav-text">检查线程是否存活</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.0.9.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">5.0.10.</span> <span class="nav-text">线程中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/basic/2019-01-21_java_thread_source.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从源码的角度再学「Thread」
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-21 09:46:24" itemprop="dateCreated datePublished" datetime="2019-01-21T09:46:24+00:00">2019-01-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java 基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>原创： zhangshaolin <strong>张少林同学</strong><br>微信号: zhangshaolin_tonxue</p>
<p>功能介绍 分享</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Java</code>中的线程是使用<code>Thread</code>类实现的，<code>Thread</code>在初学<code>Java</code>的时候就学过了，也在实践中用过，不过一直没从源码的角度去看过它的实现，今天从源码的角度出发，再次学习<code>Java Thread</code>，愿此后对<code>Thread</code>的实践更加得心应手。</p>
<h2 id="从注释开始"><a href="#从注释开始" class="headerlink" title="从注释开始"></a>从注释开始</h2><p>相信阅读过<code>JDK</code>源码的同学都能感受到<code>JDK</code>源码中有非常详尽的注释，阅读某个类的源码应当先看看注释对它的介绍，注释原文就不贴了，以下是我对它的总结：</p>
<ul>
<li><p>  <code>Thread</code>是程序中执行的线程，<code>Java</code>虚拟机允许应用程序同时允许多个执行线程</p>
</li>
<li><p>  每个线程都有优先级的概念，具有较高优先级的线程优先于优先级较低的线程执行</p>
</li>
<li><p>  每个线程都可以被设置为守护线程</p>
</li>
<li><p>  当在某个线程中运行的代码创建一个新的<code>Thread</code>对象时，新的线程优先级跟创建线程一致</p>
</li>
<li><p>  当<code>Java</code>虚拟机启动的时候都会启动一个叫做<code>main</code>的线程，它没有守护线程，<code>main</code>线程会继续执行，直到以下情况发送</p>
</li>
</ul>
<ul>
<li><p>  <code>Runtime</code> 类的退出方法<code>exit</code>被调用并且安全管理器允许进行退出操作</p>
</li>
<li><p>  所有非守护线程均已死亡，或者<code>run</code>方法执行结束正常返回结果，或者<code>run</code>方法抛出异常</p>
</li>
</ul>
<ul>
<li><p>创建线程第一种方式：继承<code>Thread</code>类，重写<code>run</code>方法</p>
<pre><code>   1  //定义线程类
   2  class PrimeThread extends Thread &#123;
   3        long minPrime;
   4        PrimeThread(long minPrime) &#123;
   5            this.minPrime = minPrime;
   6        &#125;
   7        public void run() &#123;
   8            // compute primes larger than minPrime
   9            &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
  10        &#125;
  11    &#125;
  12  //启动线程
  13  PrimeThread p = new PrimeThread(143);
  14  p.start();</code></pre>
</li>
<li><p>创建线程第二种方式：实现<code>Runnable</code>接口，重写<code>run</code>方法，因为<code>Java</code>的单继承限制，通常使用这种方式创建线程更加灵活</p>
<pre><code>   1  //定义线程
   2   class PrimeRun implements Runnable &#123;
   3        long minPrime;
   4        PrimeRun(long minPrime) &#123;
   5            this.minPrime = minPrime;
   6        &#125;
   7        public void run() &#123;
   8            // compute primes larger than minPrime
   9            &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
  10        &#125;
  11    &#125;
  12  //启动线程
  13  PrimeRun p = new PrimeRun(143);
  14  new Thread(p).start();</code></pre>
</li>
<li><p>  创建线程时可以给线程指定名字，如果没有指定，会自动为它生成名字</p>
</li>
<li><p>  除非另有说明，否则将<code>null</code>参数传递给<code>Thread</code>类中的构造函数或方法将导致抛出 <code>NullPointerException</code></p>
</li>
</ul>
<h2 id="Thread-常用属性"><a href="#Thread-常用属性" class="headerlink" title="Thread 常用属性"></a>Thread 常用属性</h2><p>阅读一个<code>Java</code>类，先从它拥有哪些属性入手：</p>
<pre><code>     1  //线程名称，创建线程时可以指定线程的名称
     2  private volatile String name;
     3  
     4  //线程优先级，可以设置线程的优先级
     5  private int priority;
     6  
     7  //可以配置线程是否为守护线程，默认为false
     8  private boolean daemon = false;
     9  
    10  //最终执行线程任务的`Runnable`
    11  private Runnable target;
    12  
    13  //描述线程组的类
    14  private ThreadGroup group;
    15  
    16  //此线程的上下文ClassLoader
    17  private ClassLoader contextClassLoader;
    18  
    19  //所有初始化线程的数目，用于自动编号匿名线程，当没有指定线程名称时，会自动为其编号
    20  private static int threadInitNumber;
    21  
    22  //此线程请求的堆栈大小，如果创建者没有指定堆栈大小，则为0。, 虚拟机可以用这个数字做任何喜欢的事情。, 一些虚拟机会忽略它。
    23  private long stackSize;
    24  
    25  //线程id
    26  private long tid;
    27  
    28  //用于生成线程ID
    29  private static long threadSeqNumber;
    30  
    31  //线程状态
    32  private volatile int threadStatus = 0;
    33  
    34  //线程可以拥有的最低优先级
    35  public final static int MIN_PRIORITY = 1;
    36  
    37  //分配给线程的默认优先级。
    38  public final static int NORM_PRIORITY = 5;
    39  
    40  //线程可以拥有的最大优先级
    41  public final static int MAX_PRIORITY = 10;</code></pre>
<h2 id="Thread-构造方法"><a href="#Thread-构造方法" class="headerlink" title="Thread 构造方法"></a>Thread 构造方法</h2><p>了解了属性之后，看看<code>Thread</code>实例是怎么构造的？先预览下它大致有多少个构造方法：</p>
<p><img src="/assets/uploads/files/1548122247324-a77dcb75-2e68-4785-81f8-a4b242b67382-image.png" alt="a77dcb75-2e68-4785-81f8-a4b242b67382-image.png"> </p>
<p>查看每个构造方法内部源码，发现均调用的是名为<code>init</code>的私有方法，再看<code>init</code>方法有两个重载，而其核心方法如下：</p>
<pre><code> 1   /**
 2     * Initializes a Thread.
 3     *
 4     * @param g                   线程组
 5     * @param target              最终执行任务的 `run()` 方法的对象
 6     * @param name                新线程的名称
 7     * @param stackSize           新线程所需的堆栈大小，或者 0 表示要忽略此参数
 8     * @param acc                 要继承的AccessControlContext，如果为null，则为 AccessController.getContext()
 9     * @param inheritThreadLocals 如果为 true，从构造线程继承可继承的线程局部的初始值
10     */
11    private void init(ThreadGroup g, Runnable target, String name,
12                      long stackSize, AccessControlContext acc,
13                      boolean inheritThreadLocals) &#123;
14        //线程名称为空，直接抛出空指针异常
15        if (name == null) &#123;
16            throw new NullPointerException(&quot;name cannot be null&quot;);
17        &#125;
18        //初始化当前线程对象的线程名称
19        this.name = name;
20        //获取当前正在执行的线程为父线程
21        Thread parent = currentThread();
22        //获取系统安全管理器
23        SecurityManager security = System.getSecurityManager();
24        //如果线程组为空
25        if (g == null) &#123;
26            //如果安全管理器不为空
27            if (security != null) &#123;
28                //获取SecurityManager中的线程组
29                g = security.getThreadGroup();
30            &#125;
31            //如果获取的线程组还是为空
32            if (g == null) &#123;
33                //则使用父线程的线程组
34                g = parent.getThreadGroup();
35            &#125;
36        &#125;
37
38        //检查安全权限
39        g.checkAccess();
40
41        //使用安全管理器检查是否有权限
42        if (security != null) &#123;
43            if (isCCLOverridden(getClass())) &#123;
44                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
45            &#125;
46        &#125;
47
48        //线程组中标记未启动的线程数+1，这里方法是同步的，防止出现线程安全问题
49        g.addUnstarted();
50
51        //初始化当前线程对象的线程组
52        this.group = g;
53        //初始化当前线程对象的是否守护线程属性，注意到这里初始化时跟父线程一致
54        this.daemon = parent.isDaemon();
55        //初始化当前线程对象的线程优先级属性，注意到这里初始化时跟父线程一致
56        this.priority = parent.getPriority();
57        //这里初始化类加载器
58        if (security == null || isCCLOverridden(parent.getClass()))
59            this.contextClassLoader = parent.getContextClassLoader();
60        else
61            this.contextClassLoader = parent.contextClassLoader;
62        this.inheritedAccessControlContext =
63                acc != null ? acc : AccessController.getContext();
64        //初始化当前线程对象的最终执行任务对象
65        this.target = target;
66        //这里再对线程的优先级字段进行处理
67        setPriority(priority);
68        if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)
69            this.inheritableThreadLocals =
70                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
71        //初始化当前线程对象的堆栈大小
72        this.stackSize = stackSize;
73
74        //初始化当前线程对象的线程ID，该方法是同步的，内部实际上是threadSeqNumber++
75        tid = nextThreadID();
76    &#125;</code></pre>
<p>另一个重载<code>init</code>私有方法如下，实际上内部调用的是上述<code>init</code>方法：</p>
<pre><code>1   private void init(ThreadGroup g, Runnable target, String name,
2                      long stackSize) &#123;
3        init(g, target, name, stackSize, null, true);
4   &#125;</code></pre>
<p>接下来看看所有构造方法：</p>
<ol>
<li><p>空构造方法</p>
<pre><code> 1    public Thread() &#123;
 2        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
 3    &#125;</code></pre>
<p> 内部调用的是<code>init</code>第二个重载方法，参数基本都是默认值，线程名称写死为<code>&quot;Thread-&quot; + nextThreadNum()</code>格式，<code>nextThreadNum()</code>为一个同步方法，内部维护一个静态属性表示线程的初始化数量+1：</p>
<pre><code> 1   private static int threadInitNumber;
 2    private static synchronized int nextThreadNum() &#123;
 3        return threadInitNumber++;
 4    &#125;</code></pre>
<p> 与第一个构造方法区别在于可以自定义<code>Runnable</code>对象</p>
</li>
<li><p>自定义执行任务<code>Runnable</code>对象的构造方法</p>
<pre><code> 1    private static int threadInitNumber;
 2    private static synchronized int nextThreadNum() &#123;
 3        return threadInitNumber++;
 4    &#125;</code></pre>
</li>
<li><p>自定义执行任务<code>Runnable</code>对象和<code>AccessControlContext</code>对象的构造方法</p>
<pre><code> 1 Thread(Runnable target, AccessControlContext acc) &#123;
 2    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc, false);
 3 &#125;</code></pre>
</li>
<li><p>自定义线程组<code>ThreadGroup</code>和执行任务<code>Runnable</code>对象的构造方法</p>
<pre><code> 1  public Thread(ThreadGroup group, Runnable target) &#123;
 2    init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义线程名称<code>name</code>的构造方法</p>
<pre><code> 1  public Thread(String name) &#123;
 2    init(null, null, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义线程组<code>ThreadGroup</code>和线程名称<code>name</code>的构造方法</p>
<pre><code> 1  public Thread(String name) &#123;
 2     init(null, null, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义执行任务<code>Runnable</code>对象和线程名称<code>name</code>的构造方法</p>
<pre><code> 1  public Thread(Runnable target, String name) &#123;
 2     init(null, target, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义线程组<code>ThreadGroup</code>和线程名称<code>name</code>和执行任务<code>Runnable</code>对象的构造方法</p>
<pre><code> 1  public Thread(ThreadGroup group, Runnable target, String name) &#123;
 2     init(group, target, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>全部属性都是自定义的构造方法</p>
<pre><code> 1  public Thread(ThreadGroup group, Runnable target, String name,
 2                long stackSize) &#123;
 3     init(group, target, name, stackSize);
 4  &#125;</code></pre>
</li>
</ol>
<p><code>Thread</code>提供了非常灵活的重载构造方法，方便开发者自定义各种参数的<code>Thread</code>对象。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>这里记录一些比较常见的方法吧，对于<code>Thread</code>中存在的一些本地方法，我们暂且不用管它～</p>
<h4 id="设置线程名称"><a href="#设置线程名称" class="headerlink" title="设置线程名称"></a>设置线程名称</h4><p>设置线程名称，该方法为同步方法，为了防止出现线程安全问题，可以手动调用<code>Thread</code>的实例方法设置名称，也可以在构造<code>Thread</code>时在构造方法中传入线程名称，我们通常都是在构造参数时设置</p>
<pre><code>     1   public final synchronized void setName(String name) &#123;
     2       　　//检查安全权限
     3          checkAccess();
     4       　　//如果形参为空，抛出空指针异常
     5          if (name == null) &#123;
     6              throw new NullPointerException(&quot;name cannot be null&quot;);
     7          &#125;
     8        //给当前线程对象设置名称
     9          this.name = name;
    10          if (threadStatus != 0) &#123;
    11              setNativeName(name);
    12          &#125;
    13      &#125;</code></pre>
<h4 id="获取线程名称"><a href="#获取线程名称" class="headerlink" title="获取线程名称"></a>获取线程名称</h4><p>内部直接返回当前线程对象的名称属性</p>
<pre><code>    1  public final String getName() &#123;
    2        return name;
    3    &#125;</code></pre>
<h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><pre><code>     1  public synchronized void start() &#123;
     2      //如果不是刚创建的线程，抛出异常
     3      if (threadStatus != 0)
     4          throw new IllegalThreadStateException();
     5
     6      //通知线程组，当前线程即将启动，线程组当前启动线程数+1，未启动线程数-1
     7      group.add(this);
     8
     9      //启动标识
    10      boolean started = false;
    11      try &#123;
    12          //直接调用本地方法启动线程
    13          start0();
    14          //设置启动标识为启动成功
    15          started = true;
    16      &#125; finally &#123;
    17          try &#123;
    18              //如果启动呢失败
    19              if (!started) &#123;
    20                  //线程组内部移除当前启动的线程数量-1，同时启动失败的线程数量+1
    21                  group.threadStartFailed(this);
    22              &#125;
    23          &#125; catch (Throwable ignore) &#123;
    24              /* do nothing. If start0 threw a Throwable then
    25                it will be passed up the call stack */
    26          &#125;
    27      &#125;
    28  &#125;</code></pre>
<p>我们正常的启动线程都是调用<code>Thread</code>的<code>start()</code>方法，然后<code>Java</code>虚拟机内部会去调用<code>Thred</code>的<code>run</code>方法，可以看到<code>Thread</code>类也是实现<code>Runnable</code>接口，重写了<code>run</code>方法的：</p>
<pre><code>    1 @Override
    2 public void run() &#123;
    3     //当前执行任务的Runnable对象不为空，则调用其run方法
    4     if (target != null) &#123;
    5         target.run();
    6     &#125;
    7 &#125;</code></pre>
<p><code>Thread</code>的两种使用方式：</p>
<ul>
<li><p>  继承<code>Thread</code>类，重写<code>run</code>方法，那么此时是直接执行<code>run</code>方法的逻辑，不会使用<code>target.run();</code></p>
</li>
<li><p>  实现<code>Runnable</code>接口，重写<code>run</code>方法，因为<code>Java</code>的单继承限制，通常使用这种方式创建线程更加灵活，这里真正的执行逻辑就会交给自定义<code>Runnable</code>去实现</p>
</li>
</ul>
<h4 id="设置守护线程"><a href="#设置守护线程" class="headerlink" title="设置守护线程"></a>设置守护线程</h4><p>本质操作是设置<code>daemon</code>属性</p>
<pre><code>     1  public final void setDaemon(boolean on) &#123;
     2      //检查是否有安全权限
     3      checkAccess();
     4      //本地方法，测试此线程是否存活。, 如果一个线程已经启动并且尚未死亡，则该线程处于活动状态
     5      if (isAlive()) &#123;
     6          //如果线程先启动后再设置守护线程，将抛出异常
     7          throw new IllegalThreadStateException();
     8      &#125;
     9      //设置当前守护线程属性
    10      daemon = on;
    11  &#125;</code></pre>
<h4 id="判断线程是否为守护线程"><a href="#判断线程是否为守护线程" class="headerlink" title="判断线程是否为守护线程"></a>判断线程是否为守护线程</h4><pre><code>    1 public final boolean isDaemon() &#123;
    2     //直接返回当前对象的守护线程属性
    3     return daemon;
    4 &#125;</code></pre>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>先来个线程状态图：</p>
<p><img src="./2019-01-21_java_thread_source/java_thread_source_1.png" alt="java_thread_source_1.png"> </p>
<p>获取线程状态：</p>
<pre><code>    1 public State getState() &#123;
    2     //由虚拟机实现，获取当前线程的状态
    3     return sun.misc.VM.toThreadState(threadStatus);
    4 &#125;</code></pre>
<p>线程状态主要由内部枚举类<code>State</code>组成：</p>
<pre><code>     1  public enum State &#123;
     2
     3     NEW,
     4
     5
     6     RUNNABLE,
     7
     8
     9     BLOCKED,
    10
    11
    12     WAITING,
    13
    14
    15     TIMED_WAITING,
    16
    17
    18     TERMINATED;
    19 &#125;</code></pre>
<ul>
<li><p>  NEW：刚刚创建，尚未启动的线程处于此状态</p>
</li>
<li><p>  RUNNABLE：在Java虚拟机中执行的线程处于此状态</p>
</li>
<li><p>  BLOCKED：被阻塞等待监视器锁的线程处于此状态，比如线程在执行过程中遇到<code>synchronized</code>同步块，就会进入此状态，此时线程暂停执行，直到获得请求的锁</p>
</li>
<li><p>  WAITING：无限期等待另一个线程执行特定操作的线程处于此状态</p>
</li>
</ul>
<ul>
<li><p>  通过 wait() 方法等待的线程在等待 notify() 方法</p>
</li>
<li><p>  通过 join() 方法等待的线程则会等待目标线程的终止</p>
</li>
</ul>
<ul>
<li>  TIMED_WAITING：正在等待另一个线程执行动作，直到指定等待时间的线程处于此状态</li>
</ul>
<ul>
<li><p>  通过 wait() 方法，携带超时时间，等待的线程在等待 notify() 方法</p>
</li>
<li><p>  通过 join() 方法，携带超时时间，等待的线程则会等待目标线程的终止</p>
</li>
</ul>
<ul>
<li>  TERMINATED：已退出的线程处于此状态，此时线程无法再回到 RUNNABLE 状态</li>
</ul>
<h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p>这是一个静态的本地方法，使当前执行的线程休眠暂停执行 <code>millis</code> 毫秒，当休眠被中断时会抛出<code>InterruptedException</code>中断异常</p>
<pre><code>     1 /**
     2  * Causes the currently executing thread to sleep (temporarily cease
     3  * execution) for the specified number of milliseconds, subject to
     4  * the precision and accuracy of system timers and schedulers. The thread
     5  * does not lose ownership of any monitors.
     6  *
     7  * @param  millis
     8  *         the length of time to sleep in milliseconds
     9  *
    10  * @throws  IllegalArgumentException
    11  *          if the value of &#123;@code millis&#125; is negative
    12  *
    13  * @throws  InterruptedException
    14  *          if any thread has interrupted the current thread. The
    15  *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
    16  *          cleared when this exception is thrown.
    17  */
    18 public static native void sleep(long millis) throws InterruptedException;</code></pre>
<h4 id="检查线程是否存活"><a href="#检查线程是否存活" class="headerlink" title="检查线程是否存活"></a>检查线程是否存活</h4><p>本地方法，测试此线程是否存活。 如果一个线程已经启动并且尚未死亡，则该线程处于活动状态。</p>
<pre><code>    1  /**
    2   * Tests if this thread is alive. A thread is alive if it has
    3   * been started and has not yet died.
    4   *
    5   * @return  &lt;code&gt;true&lt;/code&gt; if this thread is alive;
    6   *          &lt;code&gt;false&lt;/code&gt; otherwise.
    7   */
    8  public final native boolean isAlive();</code></pre>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>设置线程优先级</p>
<pre><code>   1  /**
   2   * Changes the priority of this thread.
   3   * &lt;p&gt;
   4   * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
   5   * with no arguments. This may result in throwing a
   6   * &lt;code&gt;SecurityException&lt;/code&gt;.
   7   * &lt;p&gt;
   8   * Otherwise, the priority of this thread is set to the smaller of
   9   * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted
  10   * priority of the thread&#39;s thread group.
  11   *
  12   * @param newPriority priority to set this thread to
  13   * @exception  IllegalArgumentException  If the priority is not in the
  14   *               range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to
  15   *               &lt;code&gt;MAX_PRIORITY&lt;/code&gt;.
  16   * @exception  SecurityException  if the current thread cannot modify
  17   *               this thread.
  18   * @see        #getPriority
  19   * @see        #checkAccess()
  20   * @see        #getThreadGroup()
  21   * @see        #MAX_PRIORITY
  22   * @see        #MIN_PRIORITY
  23   * @see        ThreadGroup#getMaxPriority()
  24   */
  25  public final void setPriority(int newPriority) &#123;
  26      //线程组
  27      ThreadGroup g;
  28      //检查安全权限
  29      checkAccess();
  30      //检查优先级形参范围
  31      if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;
  32          throw new IllegalArgumentException();
  33      &#125;
  34      if((g = getThreadGroup()) != null) &#123;
  35          //如果优先级形参大于线程组最大线程最大优先级
  36          if (newPriority &gt; g.getMaxPriority()) &#123;
  37              //则使用线程组的优先级数据
  38              newPriority = g.getMaxPriority();
  39          &#125;
  40          //调用本地设置线程优先级方法
  41          setPriority0(priority = newPriority);
  42      &#125;
  43  &#125;</code></pre>
</li>
</ul>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>有一个<code>stop()</code>实例方法可以强制终止线程，不过这个方法因为太过于暴力，已经被标记为过时方法，不建议程序员再使用，因为<strong>强制终止线程</strong>会导致数据不一致的问题。</p>
<p>这里关于线程中断的方法涉及三个：</p>
<pre><code>    1 //实例方法，通知线程中断，设置标志位
    2 public void interrupt()&#123;&#125;
    3 //静态方法，检查当前线程的中断状态，同时会清除当前线程的中断标志位状态
    4 public static boolean interrupted()&#123;&#125;
    5 //实例方法，检查当前线程是否被中断，其实是检查中断标志位
    6 public boolean isInterrupted()&#123;&#125;</code></pre>
<p><strong>interrupt() 方法解析</strong></p>
<pre><code>     1  /**
     2   * Interrupts this thread.
     3   *
     4   * &lt;p&gt; Unless the current thread is interrupting itself, which is
     5   * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method
     6   * of this thread is invoked, which may cause a &#123;@link
     7   * SecurityException&#125; to be thrown.
     8   *
     9   * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link
    10   * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link
    11   * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;
    12   * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link
    13   * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,
    14   * methods of this class, then its interrupt status will be cleared and it
    15   * will receive an &#123;@link InterruptedException&#125;.
    16   *
    17   * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link
    18   * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;
    19   * then the channel will be closed, the thread&#39;s interrupt
    20   * status will be set, and the thread will receive a &#123;@link
    21   * java.nio.channels.ClosedByInterruptException&#125;.
    22   *
    23   * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;
    24   * then the thread&#39;s interrupt status will be set and it will return
    25   * immediately from the selection operation, possibly with a non-zero
    26   * value, just as if the selector&#39;s &#123;@link
    27   * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.
    28   *
    29   * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
    30   * status will be set. &lt;/p&gt;
    31   *
    32   * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
    33   *
    34   * @throws  SecurityException
    35   *          if the current thread cannot modify this thread
    36   *
    37   * @revised 6.0
    38   * @spec JSR-51
    39   */
    40  public void interrupt() &#123;
    41      //检查是否是自身调用
    42      if (this != Thread.currentThread())
    43          //检查安全权限,这可能导致抛出&#123;@link * SecurityException&#125;。
    44          checkAccess();
    45
    46      //同步代码块
    47      synchronized (blockerLock) &#123;
    48          Interruptible b = blocker;
    49          //检查是否是阻塞线程调用
    50          if (b != null) &#123;
    51              //设置线程中断标志位
    52              interrupt0(); 
    53              //此时抛出异常，将中断标志位设置为false,此时我们正常会捕获该异常，重新设置中断标志位
    54              b.interrupt(this);
    55              return;
    56          &#125;
    57      &#125;
    58      //如无意外，则正常设置中断标志位
    59      interrupt0();
    60  &#125;</code></pre>
<ul>
<li><p>  线程中断方法不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出啦～</p>
</li>
<li><p>  只能由自身调用，否则可能会抛出 <code>SecurityException</code></p>
</li>
<li><p>  调用中断方法是由目标线程自己决定是否中断，而如果同时调用了<code>wait</code>,<code>join</code>,<code>sleep</code>等方法，会使当前线程进入阻塞状态，此时有可能发生<code>InterruptedException</code>异常</p>
</li>
<li><p>  被阻塞的线程再调用中断方法是不合理的</p>
</li>
<li><p>  中断不活动的线程不会产生任何影响</p>
</li>
</ul>
<p>检查线程是否被中断:</p>
<pre><code>     1  /**
     2   * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
     3   * status&lt;/i&gt; of the thread is unaffected by this method.
     4
     5   测试此线程是否已被中断。, 线程的&lt;i&gt;中断*状态&lt;/ i&gt;不受此方法的影响。
     6   *
     7   * &lt;p&gt;A thread interruption ignored because a thread was not alive
     8   * at the time of the interrupt will be reflected by this method
     9   * returning false.
    10   *
    11   * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;
    12   *          &lt;code&gt;false&lt;/code&gt; otherwise.
    13   * @see     #interrupted()
    14   * @revised 6.0
    15   */
    16  public boolean isInterrupted() &#123;
    17      return isInterrupted(false);
    18  &#125;</code></pre>
<p>静态方法,会清空当前线程的中断标志位：</p>
<pre><code>     1   /**
     2     *测试当前线程是否已被中断。, 此方法清除线程的* &lt;i&gt;中断状态&lt;/ i&gt;。, 换句话说，如果要连续两次调用此方法，则* second调用将返回false（除非当前线程再次被中断，在第一次调用已清除其中断的*状态   之后且在第二次调用已检查之前）, 它）
     3     *
     4     * &lt;p&gt;A thread interruption ignored because a thread was not alive
     5     * at the time of the interrupt will be reflected by this method
     6     * returning false.
     7     *
     8     * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;
     9     *          &lt;code&gt;false&lt;/code&gt; otherwise.
    10     * @see #isInterrupted()
    11     * @revised 6.0
    12     */
    13    public static boolean interrupted() &#123;
    14        return currentThread().isInterrupted(true);
    15    &#125;</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录自己阅读<code>Thread</code>类源码的一些思考，不过对于其中用到的很多本地方法只能望而却步，还有一些代码没有看明白，暂且先这样吧，如果有不足之处，请留言告知我，谢谢！后续会在实践中对<code>Thread</code>做出更多总结记录。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Java%E7%BA%BF%E7%A8%8B/" rel="tag"># Java线程</a>
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/design/2019-01-05_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_3_%E5%8D%81%E4%B8%80%E7%A7%8D%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html" rel="prev" title="Java 经典设计模式（3）：十一种行为型模式">
                  <i class="fa fa-chevron-left"></i> Java 经典设计模式（3）：十一种行为型模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/java/nio/2019-02-27_java_nio_model.html" rel="next" title="谈一谈 Java IO 模型">
                  谈一谈 Java IO 模型 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
