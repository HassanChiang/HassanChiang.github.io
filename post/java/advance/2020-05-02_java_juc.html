<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。 一、volatile关键字与内存可见性1、内存可见性： 先来看看下面的一段代码： public class TestVolatile &amp;#123;     public static v">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC 概览">
<meta property="og:url" content="https://blog.fenxiangz.com/post/java/advance/2020-05-02_java_juc.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。 一、volatile关键字与内存可见性1、内存可见性： 先来看看下面的一段代码： public class TestVolatile &amp;#123;     public static v">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-02T00:00:00.000Z">
<meta property="article:modified_time" content="2020-12-20T16:47:02.962Z">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.fenxiangz.com/post/java/advance/2020-05-02_java_juc.html">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>JUC 概览 | 分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">一、volatile关键字与内存可见性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">二、原子性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%94%81%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">三、锁分段机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%97%AD%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">四、闭锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F-%E2%80%94-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">五、创建线程的方式 — 实现Callable接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Lock%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">六、Lock同步锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">七、等待唤醒机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81ReadWriterLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">八、ReadWriterLock读写锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">9.</span> <span class="nav-text">九、线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2020-05-02_java_juc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC 概览
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-02T00:00:00+00:00">2020-05-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。</p>
<h1 id="一、volatile关键字与内存可见性"><a href="#一、volatile关键字与内存可见性" class="headerlink" title="一、volatile关键字与内存可见性"></a>一、volatile关键字与内存可见性</h1><p><strong>1、内存可见性：</strong></p>
<p>先来看看下面的一段代码：</p>
<pre><code>public class TestVolatile &#123;
    public static void main(String[] args)&#123; //这个线程是用来读取flag的值的
        ThreadDemo threadDemo = new ThreadDemo();
        Thread thread = new Thread(threadDemo);
        thread.start();
        while (true)&#123;
            if (threadDemo.isFlag())&#123;
                System.out.println(&quot;主线程读取到的flag = &quot; + threadDemo.isFlag());
                break;
            &#125;
        &#125;
    &#125;
&#125;

@Data
class ThreadDemo implements Runnable&#123; //这个线程是用来修改flag的值的
    public  boolean flag = false;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        flag = true;
        System.out.println(&quot;ThreadDemo线程修改后的flag = &quot; + isFlag());
    &#125;
&#125;</code></pre>
<p>这段代码很简单，就是一个ThreadDemo类继承Runnable创建一个线程。它有一个成员变量flag为false，然后重写run方法，在run方法里面将flag改为true，同时还有一条输出语句。然后就是main方法主线程去读取flag。如果flag为true，就会break掉while循环，否则就是死循环。按道理，下面那个线程将flag改为true了，主线程读取到的应该也是true，循环应该会结束。看看运行结果：</p>
<p>从图中可以看到，该程序并没有结束，也就是死循环。说明主线程读取到的flag还是false，可是另一个线程明明将flag改为true了，而且打印出来了，这是什么原因呢？这就是内存可见性问题。</p>
<ul>
<li>内存可见性问题：当多个线程操作共享数据时，彼此不可见。</li>
</ul>
<p>看下图理解上述代码：</p>
<p>要解决这个问题，可以加锁。如下：</p>
<pre><code>while (true)&#123;
        synchronized (threadDemo)&#123;
            if (threadDemo.isFlag())&#123;
                System.out.println(&quot;主线程读取到的flag = &quot; + threadDemo.isFlag());
                break;
            &#125;
        &#125;
 &#125;</code></pre>
<p>加了锁，就可以让while循环每次都从主存中去读取数据，这样就能读取到true了。但是一加锁，每次只能有一个线程访问，当一个线程持有锁时，其他的就会阻塞，效率就非常低了。不想加锁，又要解决内存可见性问题，那么就可以使用volatile关键字。</p>
<p><strong>2、volatile关键字：</strong></p>
<ul>
<li>用法：</li>
</ul>
<p>volatile关键字：当多个线程操作共享数据时，可以保证内存中的数据可见。用这个关键字修饰共享数据，就会及时的把线程缓存中的数据刷新到主存中去，也可以理解为，就是直接操作主存中的数据。所以在不使用锁的情况下，可以使用volatile。如下：</p>
<pre><code>public  volatile boolean flag = false;</code></pre>
<p>这样就可以解决内存可见性问题了。</p>
<ul>
<li>volatile和synchronized的区别：     </li>
</ul>
<p>volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。     </p>
<p>volatile不具备原子性。</p>
<h1 id="二、原子性"><a href="#二、原子性" class="headerlink" title="二、原子性"></a>二、原子性</h1><p><strong>1、理解原子性：</strong></p>
<p>上面说到volatile不具备原子性，那么原子性到底是什么呢？先看如下代码：</p>
<pre><code>public class TestIcon &#123;
    public static void main(String[] args)&#123;
        AtomicDemo atomicDemo = new AtomicDemo();
        for (int x = 0;x &lt; 10; x++)&#123;
            new Thread(atomicDemo).start();
        &#125;
    &#125;
&#125;

class AtomicDemo implements Runnable&#123;
    private int i = 0;
    public int getI()&#123;
        return i++;
    &#125;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(getI());
    &#125;
&#125;</code></pre>
<p>这段代码就是在run方法里面让i++，然后启动十个线程去访问。看看结果：</p>
<p>可以发现，出现了重复数据。明显产生了多线程安全问题，或者说原子性问题。所谓原子性就是操作不可再细分，而i++操作分为读改写三步，如下：</p>
<pre><code>int temp = i;
i = i+1;
i = temp;</code></pre>
<p>所以i++明显不是原子操作。上面10个线程进行i++时，内存图解如下：</p>
<p>看到这里，好像和上面的内存可见性问题一样。是不是加个volatile关键字就可以了呢？其实不是的，因为加了volatile，只是相当于所有线程都是在主存中操作数据而已，但是不具备互斥性。比如两个线程同时读取主存中的0，然后又同时自增，同时写入主存，结果还是会出现重复数据。</p>
<p><strong>2、原子变量：</strong></p>
<p>JDK 1.5之后，Java提供了原子变量，在java.util.concurrent.atomic包下。原子变量具备如下特点：</p>
<ul>
<li>有volatile保证内存可见性。</li>
<li>用CAS算法保证原子性。</li>
</ul>
<p><strong>3、CAS算法：</strong></p>
<p>CAS算法是计算机硬件对并发操作共享数据的支持，CAS包含3个操作数：</p>
<ul>
<li>内存值V</li>
<li>预估值A</li>
<li>更新值B</li>
</ul>
<p>当且仅当V==B时，才会把B的值赋给V，即V = B，否则不做任何操作。就上面的i++问题，CAS算法是这样处理的：首先V是主存中的值0，然后预估值A也是0，因为此时还没有任何操作，这时V=B，所以进行自增，同时把主存中的值变为1。如果第二个线程读取到主存中的还是0也没关系，因为此时预估值已经变成1，V不等于B，所以不进行任何操作。</p>
<p><strong>4、使用原子变量改进i++问题：</strong></p>
<p>原子变量用法和包装类差不多，如下：</p>
<pre><code> //private int i = 0;
 AtomicInteger i = new AtomicInteger();
 public int getI()&#123;
     return i.getAndIncrement();
 &#125;</code></pre>
<p>只改这两处即可。</p>
<h1 id="三、锁分段机制"><a href="#三、锁分段机制" class="headerlink" title="三、锁分段机制"></a>三、锁分段机制</h1><p>JDK 1.5之后，在java.util.concurrent包中提供了多种并发容器类来改进同步容器类的性能。其中最主要的就是ConcurrentHashMap。</p>
<p><strong>1、ConcurrentHashMap：</strong></p>
<p>ConcurrentHashMap就是一个线程安全的hash表。我们知道HashMap是线程不安全的，Hash Table加了锁，是线程安全的，因此它效率低。HashTable加锁就是将整个hash表锁起来，当有多个线程访问时，同一时间只能有一个线程访问，并行变成串行，因此效率低。所以JDK1.5后提供了ConcurrentHashMap，它采用了锁分段机制。     </p>
<p>如上图所示，ConcurrentHashMap默认分成了16个segment，每个Segment都对应一个Hash表，且都有独立的锁。所以这样就可以每个线程访问一个Segment，就可以并行访问了，从而提高了效率。这就是锁分段。<strong>但是，</strong>java 8 又更新了，不再采用锁分段机制，也采用CAS算法了。</p>
<p><strong>2、用法:</strong></p>
<p>java.util.concurrent包还提供了设计用于多线程上下文中的 Collection 实现： ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给 定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap， ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远 大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。下面看看部分用法：</p>
<pre><code>public class TestConcurrent &#123;
    public static void main(String[] args)&#123;
        ThreadDemo2 threadDemo2 = new ThreadDemo2();
           for (int i=0;i&lt;10;i++)&#123;
               new Thread(threadDemo2).start();
           &#125;
    &#125;
&#125;
//10个线程同时访问
class ThreadDemo2 implements Runnable&#123;
    private static List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());//普通做法
    static &#123;
        list.add(&quot;aaa&quot;);
        list.add(&quot;bbb&quot;);
        list.add(&quot;ccc&quot;);
    &#125;
    @Override
    public void run() &#123;
        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext())&#123;
            System.out.println(iterator.next());//读
            list.add(&quot;ddd&quot;);//写
        &#125;
    &#125;
&#125;</code></pre>
<p>10个线程并发访问这个集合，读取集合数据的同时再往集合中添加数据。运行这段代码会报错，并发修改异常。</p>
<p>将创建集合方式改成：</p>
<pre><code>private static CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></pre>
<p>这样就不会有并发修改异常了。因为这个是写入并复制，每次生成新的，所以如果添加操作比较多的话，开销非常大，适合迭代操作比较多的时候使用。</p>
<h1 id="四、闭锁"><a href="#四、闭锁" class="headerlink" title="四、闭锁"></a>四、闭锁</h1><p>java.util.concurrent包中提供了多种并发容器类来改进同步容器的性能。ContDownLatch是一个同步辅助类，在完成某些运算时，只有其他所有线程的运算全部完成，当前运算才继续执行，这就叫闭锁。看下面代码：</p>
<pre><code>public class TestCountDownLatch &#123;
    public static void main(String[] args)&#123;
        LatchDemo ld = new LatchDemo();
        long start = System.currentTimeMillis();
        for (int i = 0;i&lt;10;i++)&#123;
            new Thread(ld).start();
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时间为：&quot;+(end - start)+&quot;秒&quot;);
    &#125;
&#125;

class LatchDemo implements Runnable&#123;
    private CountDownLatch latch;
    public LatchDemo()&#123;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0;i&lt;5000;i++)&#123;
            if (i % 2 == 0)&#123;//50000以内的偶数
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>这段代码就是10个线程同时去输出5000以内的偶数，然后在主线程那里计算执行时间。其实这是计算不了那10个线程的执行时间的，因为主线程与这10个线程也是同时执行的，可能那10个线程才执行到一半，主线程就已经输出“耗费时间为x秒”这句话了。所有要想计算这10个线程执行的时间，就得让主线程先等待，等10个分线程都执行完了才能执行主线程。这就要用到闭锁。看如何使用：</p>
<pre><code>public class TestCountDownLatch &#123;
    public static void main(String[] args) &#123;
        final CountDownLatch latch = new CountDownLatch(10);//有多少个线程这个参数就是几
        LatchDemo ld = new LatchDemo(latch);
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(ld).start();
        &#125;
        try &#123;
            latch.await();//这10个线程执行完之前先等待
        &#125; catch (InterruptedException e) &#123;
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时间为：&quot; + (end - start));
    &#125;
&#125;

class LatchDemo implements Runnable &#123;
    private CountDownLatch latch;
    public LatchDemo(CountDownLatch latch) &#123;
        this.latch = latch;
    &#125;
    @Override
    public void run() &#123;
        synchronized (this) &#123;
            try &#123;
                for (int i = 0; i &lt; 50000; i++) &#123;
                    if (i % 2 == 0) &#123;//50000以内的偶数
                        System.out.println(i);
                    &#125;
                &#125;
            &#125; finally &#123;
                latch.countDown();//每执行完一个就递减一个
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>如上代码，主要就是用<code>latch.countDown()</code>和<code>latch.await()</code>实现闭锁，详细请看上面注释即可。</p>
<h1 id="五、创建线程的方式-—-实现Callable接口"><a href="#五、创建线程的方式-—-实现Callable接口" class="headerlink" title="五、创建线程的方式 — 实现Callable接口"></a>五、创建线程的方式 — 实现Callable接口</h1><p>直接看代码：</p>
<pre><code>public class TestCallable &#123;
    public static void main(String[] args)&#123;
        CallableDemo callableDemo = new CallableDemo();
        //执行callable方式，需要FutureTask实现类的支持，用来接收运算结果
        FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(callableDemo);
        new Thread(result).start();
        //接收线程运算结果
        try &#123;
            Integer sum = result.get();//当上面的线程执行完后，才会打印结果。跟闭锁一样。所有futureTask也可以用于闭锁
            System.out.println(sum);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

class CallableDemo implements Callable&lt;Integer&gt;&#123;
    @Override
    public Integer call() throws Exception &#123;
       int sum = 0;
       for (int i = 0;i&lt;=100;i++)&#123;
           sum += i;
       &#125;
       return sum;
    &#125;
&#125;</code></pre>
<p>现在Callable接口和实现Runable接口的区别就是，Callable带泛型，其call方法有返回值。使用的时候，需要用FutureTask来接收返回值。而且它也要等到线程执行完调用get方法才会执行，也可以用于闭锁操作。</p>
<h1 id="六、Lock同步锁"><a href="#六、Lock同步锁" class="headerlink" title="六、Lock同步锁"></a>六、Lock同步锁</h1><p>在JDK1.5之前，解决多线程安全问题有两种方式(sychronized隐式锁)：</p>
<ul>
<li>同步代码块</li>
<li>同步方法</li>
</ul>
<p>在JDK1.5之后，出现了更加灵活的方式(Lock显式锁)：</p>
<ul>
<li>同步锁</li>
</ul>
<p>Lock需要通过lock()方法上锁，通过unlock()方法释放锁。为了保证锁能释放，所有unlock方法一般放在finally中去执行。</p>
<p>再来看一下卖票案例：</p>
<pre><code>public class TestLock &#123;
    public static void main(String[] args) &#123;
        Ticket td = new Ticket();
        new Thread(td, &quot;窗口1&quot;).start();
        new Thread(td, &quot;窗口2&quot;).start();
        new Thread(td, &quot;窗口3&quot;).start();
    &#125;
&#125;

class Ticket implements Runnable &#123;
    private int ticket = 100;
    @Override
    public void run() &#123;
        while (true) &#123;
            if (ticket &gt; 0) &#123;
                try &#123;
                    Thread.sleep(200);
                &#125; catch (Exception e) &#123;
                &#125;
                System.out.println(Thread.currentThread().getName() + &quot;完成售票，余票为：&quot; + (--ticket));
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>多个线程同时操作共享数据ticket，所以会出现线程安全问题。会出现同一张票卖了好几次或者票数为负数的情况。以前用同步代码块和同步方法解决，现在看看用同步锁怎么解决。</p>
<pre><code>class Ticket implements Runnable &#123;
    private Lock lock = new ReentrantLock();//创建lock锁
    private int ticket = 100;
    @Override
    public void run() &#123;
        while (true) &#123;
            lock.lock();//上锁
            try &#123;
                if (ticket &gt; 0) &#123;
                    try &#123;
                        Thread.sleep(200);
                    &#125; catch (Exception e) &#123;
                    &#125;
                    System.out.println(Thread.currentThread().getName() + &quot;完成售票，余票为：&quot; + (--ticket));
                &#125;
            &#125;finally &#123;
                lock.unlock();//释放锁
            &#125;

        &#125;
    &#125;
&#125;</code></pre>
<p>直接创建lock对象，然后用lock()方法上锁，最后用unlock()方法释放锁即可。</p>
<h1 id="七、等待唤醒机制"><a href="#七、等待唤醒机制" class="headerlink" title="七、等待唤醒机制"></a>七、等待唤醒机制</h1><p><strong>1、虚假唤醒问题：</strong></p>
<p>生产消费模式是等待唤醒机制的一个经典案例，看下面的代码：</p>
<pre><code>public class TestProductorAndconsumer &#123;
    public static void main(String[] args)&#123;
           Clerk clerk = new Clerk();
           Productor productor = new Productor(clerk);
           Consumer consumer = new Consumer(clerk);
           new Thread(productor,&quot;生产者A&quot;).start();
           new Thread(consumer,&quot;消费者B&quot;).start();
    &#125;
&#125;
//店员
class Clerk&#123;
    private int product = 0;//共享数据
    public synchronized void get()&#123; //进货
        if(product &gt;= 10)&#123;
            System.out.println(&quot;产品已满&quot;);
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (++product));
        &#125;
    &#125;
    public synchronized void sell()&#123;//卖货
        if (product &lt;= 0)&#123;
            System.out.println(&quot;缺货&quot;);
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (--product));
        &#125;
    &#125;
&#125;
//生产者
class Productor implements Runnable&#123;
    private Clerk clerk;
    public Productor(Clerk clerk)&#123;
        this.clerk = clerk;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0;i&lt;20;i++)&#123;
            clerk.get();
        &#125;
    &#125;
&#125;
//消费者
class Consumer implements Runnable&#123;
    private Clerk clerk;
    public Consumer(Clerk clerk)&#123;
        this.clerk = clerk;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0;i&lt;20;i++)&#123;
            clerk.sell();
        &#125;
    &#125;
&#125;</code></pre>
<p>这就是生产消费模式的案例，这里没有使用等待唤醒机制，运行结果就是即使是缺货状态，它也会不断的去消费，也会一直打印“缺货”，即使是产品已满状态，也会不断地进货。用等待唤醒机制改进：</p>
<pre><code>//店员
class Clerk&#123;
    private int product = 0;//共享数据
    public synchronized void get()&#123; //进货
        if(product &gt;= 10)&#123;
            System.out.println(&quot;产品已满&quot;);
            try &#123;
                this.wait();//满了就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (++product));
            this.notifyAll();//没满就可以进货
        &#125;
    &#125;
    public synchronized void sell()&#123;//卖货
        if (product &lt;= 0)&#123;
            System.out.println(&quot;缺货&quot;);
            try &#123;
                this.wait();//缺货就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (--product));
            this.notifyAll();//不缺货就可以卖
        &#125;
    &#125;
&#125;</code></pre>
<p>这样就不会出现上述问题了。没有的时候就生产，生产满了就通知消费，消费完了再通知生产。但是这样还是有点问题，将上述代码做如下改动：</p>
<pre><code>if(product &gt;= 1)&#123; //把原来的10改成1
            System.out.println(&quot;产品已满&quot;);
         ......
public void run() &#123;
        try &#123;
            Thread.sleep(200);//睡0.2秒
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        for (int i = 0;i&lt;20;i++)&#123;
            clerk.sell();
        &#125;
&#125;</code></pre>
<p>就做这两处修改，再次运行，发现虽然结果没问题，但是程序却一直没停下来。出现这种情况是因为有一个线程在等待，而另一个线程没有执行机会了，唤醒不了这个等待的线程了，所以程序就无法结束。解决办法就是把get和sell方法里面的else去掉，不要用else包起来。但是，即使这样，如果再多加两个线程，就会出现负数了。</p>
<pre><code>new Thread(productor, &quot;生产者C&quot;).start();
new Thread(consumer, &quot;消费者D&quot;).start();</code></pre>
<p>运行结果：</p>
<p>一个消费者线程抢到执行权，发现product是0，就等待，这个时候，另一个消费者又抢到了执行权，product是0，还是等待，此时两个消费者线程在同一处等待。然后当生产者生产了一个product后，就会唤醒两个消费者，发现product是1，同时消费，结果就出现了0和-1。这就是<strong>虚假唤醒</strong>。解决办法就是把if判断改成while。如下：</p>
<pre><code> public synchronized void get() &#123; //进货
        while (product &gt;= 1) &#123;
            System.out.println(&quot;产品已满&quot;);
            try &#123;
                this.wait();//满了就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (++product));
            this.notifyAll();//没满就可以进货
    &#125;
    public synchronized void sell() &#123;//卖货
        while (product &lt;= 0) &#123;//为了避免虚假唤醒问题，wait方法应该总是在循环中使用
            System.out.println(&quot;缺货&quot;);
            try &#123;
                this.wait();//缺货就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (--product));
            this.notifyAll();//不缺货就可以卖
    &#125;</code></pre>
<p>只需要把if改成while，每次都再去判断一下，就可以了。</p>
<p><strong>2、用Lock锁实现等待唤醒：</strong></p>
<pre><code>class Clerk &#123;
    private int product = 0;//共享数据
    private Lock lock = new ReentrantLock();//创建锁对象
    private Condition condition = lock.newCondition();//获取condition实例
    public  void get() &#123; //进货
        lock.lock();//上锁
        try &#123;
            while (product &gt;= 1) &#123;
                System.out.println(&quot;产品已满&quot;);
                try &#123;
                    condition.await();//满了就等待
                &#125; catch (InterruptedException e) &#123;
                &#125;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (++product));
            condition.signalAll();//没满就可以进货
        &#125;finally &#123;
            lock.unlock();//释放锁
        &#125;
    &#125;

    public  void sell() &#123;//卖货
        lock.lock();//上锁
        try &#123;
            while (product &lt;= 0) &#123;
                System.out.println(&quot;缺货&quot;);
                try &#123;
                    condition.await();//缺货就等待
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (--product));
            condition.signalAll();//不缺货就可以卖
        &#125;finally &#123;
            lock.unlock();//释放锁
        &#125;
    &#125;
&#125;</code></pre>
<p>使用lock同步锁，就不需要sychronized关键字了，需要创建lock对象和condition实例。condition的await()方法、signal()方法和signalAll()方法分别与wait()方法、notify()方法和notifyAll()方法对应。</p>
<p><strong>3、线程按序交替：</strong></p>
<p>首先来看一道题：</p>
<pre><code>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，
每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。
如：ABCABCABC…… 依次递归</code></pre>
<p>分析：</p>
<pre><code>线程本来是抢占式进行的，要按序交替，所以必须实现线程通信，
那就要用到等待唤醒。可以使用同步方法，也可以用同步锁。</code></pre>
<p>编码实现：</p>
<pre><code>public class TestLoopPrint &#123;
    public static void main(String[] args) &#123;
        AlternationDemo ad = new AlternationDemo();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    ad.loopA();
                &#125;
            &#125;
        &#125;, &quot;A&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    ad.loopB();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    ad.loopC();
                &#125;
            &#125;
        &#125;, &quot;C&quot;).start();
    &#125;
&#125;

class AlternationDemo &#123;
    private int number = 1;//当前正在执行的线程的标记
    private Lock lock = new ReentrantLock();
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Condition condition3 = lock.newCondition();

    public void loopA() &#123;
        lock.lock();
        try &#123;
            if (number != 1) &#123; //判断
                condition1.await();
            &#125;
            System.out.println(Thread.currentThread().getName());//打印
            number = 2;
            condition2.signal();
        &#125; catch (Exception e) &#123;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public void loopB() &#123;
        lock.lock();
        try &#123;
            if (number != 2) &#123; //判断
                condition2.await();
            &#125;
            System.out.println(Thread.currentThread().getName());//打印
            number = 3;
            condition3.signal();
        &#125; catch (Exception e) &#123;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public void loopC() &#123;
        lock.lock();
        try &#123;
            if (number != 3) &#123; //判断
                condition3.await();
            &#125;
            System.out.println(Thread.currentThread().getName());//打印
            number = 1;
            condition1.signal();
        &#125; catch (Exception e) &#123;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>以上编码就满足需求。创建三个线程，分别调用loopA、loopB和loopC方法，这三个线程使用condition进行通信。</p>
<h1 id="八、ReadWriterLock读写锁"><a href="#八、ReadWriterLock读写锁" class="headerlink" title="八、ReadWriterLock读写锁"></a>八、ReadWriterLock读写锁</h1><p>我们在读数据的时候，可以多个线程同时读，不会出现问题，但是写数据的时候，如果多个线程同时写数据，那么到底是写入哪个线程的数据呢？所以，如果有两个线程，写写/读写需要互斥，读读不需要互斥。这个时候可以用读写锁。看例子：</p>
<pre><code>public class TestReadWriterLock &#123;
    public static void main(String[] args)&#123;
           ReadWriterLockDemo rw = new ReadWriterLockDemo();
           new Thread(new Runnable() &#123;//一个线程写
               @Override
               public void run() &#123;
                   rw.set((int)Math.random()*101);
               &#125;
           &#125;,&quot;write:&quot;).start();
           for (int i = 0;i&lt;100;i++)&#123;//100个线程读
               Runnable runnable = () -&gt; rw.get();
               Thread thread = new Thread(runnable);
               thread.start();
           &#125;
    &#125;
&#125;

class ReadWriterLockDemo&#123;
    private int number = 0;
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    //读(可以多个线程同时操作)
    public void get()&#123;
        readWriteLock.readLock().lock();//上锁
        try &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+number);
        &#125;finally &#123;
            readWriteLock.readLock().unlock();//释放锁
        &#125;
    &#125;
    //写(一次只能有一个线程操作)
    public void set(int number)&#123;
        readWriteLock.writeLock().lock();
        try &#123;
            System.out.println(Thread.currentThread().getName());
            this.number = number;
        &#125;finally &#123;
            readWriteLock.writeLock().unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>这个就是读写锁的用法。上面的代码实现了一个线程写，一百个线程同时读的操作。</p>
<h1 id="九、线程池"><a href="#九、线程池" class="headerlink" title="九、线程池"></a>九、线程池</h1><p>我们使用线程时，需要new一个，用完了又要销毁，这样频繁的创建销毁也很耗资源，所以就提供了线程池。道理和连接池差不多，连接池是为了避免频繁的创建和释放连接，所以在连接池中就有一定数量的连接，要用时从连接池拿出，用完归还给连接池。线程池也一样。线程池中有一个线程队列，里面保存着所有等待状态的线程。下面来看一下用法：</p>
<pre><code>public class TestThreadPool &#123;
    public static void main(String[] args) &#123;
        ThreadPoolDemo tp = new ThreadPoolDemo();
        //1.创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(5);
        //2.为线程池中的线程分配任务
        pool.submit(tp);
        //3.关闭线程池
        pool.shutdown();
    &#125;
&#125;

class ThreadPoolDemo implements Runnable &#123;
    private int i = 0;
    @Override
    public void run() &#123;
        while (i &lt; 100) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (i++));
        &#125;
    &#125;
&#125;</code></pre>
<p>线程池用法很简单，分为三步。首先用工具类Executors创建线程池，然后给线程池分配任务，最后关闭线程池就行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上为本文全部内容，涉及到了JUC的大部分内容。 本人也是初次接触，如有错误，希望大佬指点一二！</p>
<p>原文：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f19835e05c0">https://www.jianshu.com/p/1f19835e05c0</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/java/advance/2020-04-25_java_optimize.html" rel="prev" title="接口性能优化思路">
                  <i class="fa fa-chevron-left"></i> 接口性能优化思路
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/java/spring/2020-11-20_SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" rel="next" title="Spring IOC 容器源码分析">
                  Spring IOC 容器源码分析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
