<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="分享之">
<meta property="og:url" content="https://blog.fenxiangz.com/page/7/index.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="Share everything">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="JAVA,Linux,技术分享,网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.fenxiangz.com/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-12-13_%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-12-13_%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5.html" class="post-title-link" itemprop="url">帧、报文、报文段、分组、包、数据报的概念区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-13T00:00:00+00:00">2017-12-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分组、包，packet，信息在互联网当中传输的单元，网络层实现分组交付。用抓包工具抓到的一条条记录就是包。</p>
<p>帧，frame，数据链路层的协议数据单元。我们将链路层分组称为帧。</p>
<p>数据报，Datagram，通过网络传输的数据的基本单元，包含一个报头（header）和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。可以理解为传输数据的分组。我们将通过网络传输的数据的基本单元称为数据报。</p>
<p>报文段，segment，组成报文的每个分组。我们将运输层分组称为报文段。</p>
<p>报文，message，一般指完整的信息，传输层实现报文交付。我们将位于应用层的信息分组称为报文。</p>
<p>由此可见，抓包抓到的是传输层的包，所以packet，frame，Datagram，segment是存在于同条记录中的，而frame，Datagram，segment是基于所在协议层不同而取了不同的名字。</p>
<h3 id="1-报文-message"><a href="#1-报文-message" class="headerlink" title="1. 报文(message)"></a>1. 报文(message)</h3><p>报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</p>
<h3 id="2-分组-packet"><a href="#2-分组-packet" class="headerlink" title="2. 分组(packet)"></a>2. 分组(packet)</h3><p>分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。</p>
<h3 id="3-数据包-data-packet"><a href="#3-数据包-data-packet" class="headerlink" title="3. 数据包(data packet)"></a>3. 数据包(data packet)</h3><p>数据包是TCP/IP协议通信传输中的数据单元，也称为“包”。是指自包含的，带有足够寻址信息，可独立地从源主机传输到目的主机，而不需要依赖早期的源主机和目的主机之间交换信息以及传输网络的数据包。</p>
<h3 id="4-数据报-datagram"><a href="#4-数据报-datagram" class="headerlink" title="4. 数据报(datagram)"></a>4. 数据报(datagram)</h3><p>面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。</p>
<h3 id="5-帧-frame"><a href="#5-帧-frame" class="headerlink" title="5. 帧(frame)"></a>5. 帧(frame)</h3><p>帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。</p>
<p>应用层——消息<br>传输层——数据段(segment)<br>网络层——分组、数据包（packet）<br>链路层——帧（frame）<br>物理层——P-PDU（bit）<br>（《计算机网络——自顶向下方法》）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-12-14_TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84seq_ack%E5%BA%8F%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-12-14_TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84seq_ack%E5%BA%8F%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F.html" class="post-title-link" itemprop="url">TCP协议中的seq/ack序号是如何变化的？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-13T00:00:00+00:00">2017-12-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这里提供了截取出来的一次client端和server端TCP包的交互过程。建议将图单独放到一台设备、或者打印出来查看，以便不断核对下述内容。</p>
<p><img src="2017-12-14_TCP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84seq_ack%E5%BA%8F%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F/1.png"> </p>
<p>图：TCP数据包交换过程</p>
<p>再开始分析之前，还需要论述一下seq、ack表示什么意思，应该以什么样的角度去理解这两个序列号。</p>
<ul>
<li><strong>sequence number</strong>：表示的是我方（发送方）这边，这个packet的数据部分的第一位应该在整个data stream中所在的位置。（注意这里使用的是“应该”。因为对于没有数据的传输，如ACK，虽然它有一个seq，但是这次传输在整个data stream中是不占位置的。所以下一个实际有数据的传输，会依旧从上一次发送ACK的数据包的seq开始）</li>
<li><strong>acknowledge number</strong>：表示的是期望的对方（接收方）的下一次sequence number是多少。</li>
<li>注意，SYN/FIN的传输虽然没有data，但是会让下一次传输的packet seq增加一，但是，ACK的传输，不会让下一次的传输packet加一。</li>
</ul>
<p>上面这几条原则第一次读会有些抽象，可以先继续往下读分析过程，再回过头来查看这个三个原则。</p>
<p>1、</p>
<blockquote>
<ul>
<li>seq：client端第一次发送packet，即：first-way handshake。所以按照上面的准则，它的数据应该从第一个开始，也即是第0位开始，所以seq为0。</li>
<li>ack：而server端之前并未发送过数据，所以期望的是server端回传时的packet的seq应该从第一个开始，即是第0位开始，所以ack为0。</li>
</ul>
</blockquote>
<p>2、</p>
<blockquote>
<ul>
<li>seq：server端第一次发送packet，即：second-way handshake。所以，这个packet的seq为0。</li>
<li>ack：由于在【no.1】中接收到的是client端的SYN数据包，且它的seq为0，所以client端会让它自己的seq增加1。由此可预计（expect），client端的下一次packet传输时，它的seq是1（0增加1）。所以，ACK为1。</li>
</ul>
</blockquote>
<p>3、</p>
<blockquote>
<ul>
<li>seq：third-way handshake。上一次发送时为【no.1】，【no.1】中seq为0且为SYN数据包，所以这一次的seq为1（0增加1）。</li>
<li>ack：上次接收到时为【no.2】，【no.2】中seq为0，且为SYN数据包（虽然在flag上同时设定为SYN/ACK，但只要flag是SYN，就会驱使seq加一），所以可预计，server端下一次seq为1（0增加1）。</li>
</ul>
</blockquote>
<p>4、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.1】，【no.1】中seq为0且为SYN数据包，所以这一次的seq为1（0增加1）。</li>
<li>ack：上次接收到时为【no.2】，【no.2】中seq为0，且为SYN数据包，所以可预计，server端下一次seq为1（0增加1）。</li>
</ul>
</blockquote>
<p>5、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.2】，【no.2】中seq为0，且为SYN数据包，所以这一次的seq为1（0增加1）。</li>
<li>ack：上一次接收时为【no.4】，【no.4】中的seq为1，数据包的长度为725，所以可以预计，下一次client端的seq为726（1+725）。</li>
</ul>
</blockquote>
<p>6、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.5】，【no.5】中seq为1，但【no.5】为ACK数据包，所以数据长度为0且不会驱使seq加1，所以这一次的seq为1（1+0）。</li>
<li>ack：上一次接收时为【no.4】，【no.4】中的seq为1，数据包的长度为725，所以可以预计，下一次client端的seq为726（1+725）。</li>
</ul>
</blockquote>
<p>7、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.4】，【no.4】中seq为1，数据包长度为725，所以这一次的seq为726（1+725）。</li>
<li>ack：上一次接收时为【no.6】，【no.6】中seq为1，且数据长度为1448，所以可以预计，下一次server端的seq为1449（1+1448）。</li>
</ul>
</blockquote>
<p>8、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.6】，【no.6】中seq为1，数据包长度为1448，所以这一次的seq为1449（1+1448）。</li>
<li>ack：上一次接收时为【no.7】，【no.7】中seq为726，数据包为ACK、即数据为0，所以可以预计，下一次client端的seq为726（726+0）。</li>
</ul>
</blockquote>
<p>9、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.7】，【no.7】中seq为726，数据包为ACK、即长度为0， 所以这一次seq为726（726+0）。</li>
<li>ack：上一次接收时为【no.8】，【no.8】中seq为1449，数据包长度为1448，所以可以预计，下一次server端的seq为2897（1449+1448）。</li>
</ul>
</blockquote>
<p>10、</p>
<blockquote>
<ul>
<li>seq：上一次发送时为【no.8】，【no.8】中seq为1449，且数据包长度为1448，所以这一次seq为2897（1449+1448）。</li>
<li>ack：上一次接收时为【no.9】，【no.9】中seq为726，数据包为ACK、即数据为0，所以可以预计，下一次client端的seq为726（726+0）。</li>
</ul>
</blockquote>
<p>剩下的7个packet可以留作练习题自己分析。可以看到的是，从【no.7】开始，client端这边就只负责做响应，发送ACK数据包，而并没有实际的数据发送到server端。所以，从【no.7】开始，所有的ACK数据包的seq都是相同的726，因为ACK不像SYN/FIN可以让seq增加，所以发送再多的ACK包都只能让seq原地踏步。</p>
<h3 id="丢包验证"><a href="#丢包验证" class="headerlink" title="丢包验证"></a>丢包验证</h3><p>由此可以看到，无论对于client端还是server端，这一次刚收到的对方的packet的seq，一定要和最后一次发送时的packet的ack相等。</p>
<p>因为最后一次发送时的packet的ack，是对下一次接收的packet的seq做的预测。如果两者不等，则表明中途有数据包丢失了！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-12_Ubuntu20.04LTS%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-12_Ubuntu20.04LTS%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95.html" class="post-title-link" itemprop="url">Ubuntu 20.04 LTS 安装搜狗输入法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-12 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-12T00:00:00+00:00">2017-12-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://pic1.zhimg.com/v2-0528c3ad69dfe7d8567e5f4bc99bcc5b_1440w.jpg?source=172ae18b" alt="Ubuntu20.04LTS安装搜狗输入法"></p>
<h1 id="Ubuntu20-04LTS安装搜狗输入法"><a href="#Ubuntu20-04LTS安装搜狗输入法" class="headerlink" title="Ubuntu20.04LTS安装搜狗输入法"></a>Ubuntu20.04LTS安装搜狗输入法</h1><p><a target="_blank" rel="noopener" href="//www.zhihu.com/people/zhou-gong-87-23"><img src="https://pic3.zhimg.com/v2-a6ca19495b3ada24210aefdafdb40574_xs.jpg?source=172ae18b" alt="舟公"></a></p>
<p><a target="_blank" rel="noopener" href="//www.zhihu.com/people/zhou-gong-87-23">舟公</a></p>
<p>Ubuntu 20.04安装后，一直想安装搜狗输入法，尝试过官网下载安装搜狗输入法Linux版，但由于依赖（qt4相关，在20.04版本中被去掉了）的问题无法修复，导致一直无法成功安装。用了一段时间统自带的输入法，使用起来相对还可以，不过相比搜狗输入法（拼音纠错，模糊音，候选词等），还是远远比不上的。最近搜索了一下，发现已经有方法安装，并可以正常使用，而且方法并不复杂，帮助大家整理一下，并附上原文链接！</p>
<h2 id="1-添加ubuntukylin源"><a href="#1-添加ubuntukylin源" class="headerlink" title="1.添加ubuntukylin源"></a>1.添加ubuntukylin源</h2><p>根据官方教程添加ukui的官方源，为了安装及后续更新。此源中包含了麒麟版搜狗输入法。</p>
<pre><code>$ curl -sL &#39;https://keyserver.ubuntu.com/pks/lookup?&amp;op=get&amp;search=0x73BC8FBCF5DE40C6ADFCFFFA9C949F2093F565FF&#39; | sudo apt-key add
$ sudo apt-add-repository &#39;deb http://archive.ubuntukylin.com/ukui focal main&#39;
$ sudo apt upgrade</code></pre>
<h2 id="2-安装搜狗输入法"><a href="#2-安装搜狗输入法" class="headerlink" title="2.安装搜狗输入法"></a>2.安装搜狗输入法</h2><p>直接安装软件包，注意包名是sogouimebs而不是原来的sogoupinyin。这个版本在其他地方暂时是找不到的，因为是麒麟社区定制的版本。由于ubuntu和优麒麟一脉相承的关系，我们可以直接拿来用。</p>
<pre><code>$ sudo apt install sogouimebs</code></pre>
<h2 id="3-输入法设置"><a href="#3-输入法设置" class="headerlink" title="3.输入法设置"></a>3.输入法设置</h2><p>根据自身需求针对输入法属性进行设置</p>
<pre><code>$ sogouIme-configtool </code></pre>
<h2 id="4-设置默认输入法"><a href="#4-设置默认输入法" class="headerlink" title="4.设置默认输入法"></a>4.设置默认输入法</h2><p>进入设置，选择“区域与语言”，点击管理已安装的语言，把默认输入法设置为fcitx，重启电脑就可以使用搜狗输入法了。切换输入法按键Ctrl+Space。</p>
<h2 id="禁用IBus-可选"><a href="#禁用IBus-可选" class="headerlink" title="禁用IBus(可选)"></a>禁用IBus(可选)</h2><p>经过使用，我发现偶尔会遇到输入卡住的情况，ibus和fcitx发生冲突不是新鲜问题了，如果有相同的问题不妨卸载ibus试一试。</p>
<p>如果无法卸载ibus可以采用禁用ibus的方法。</p>
<pre><code>$ sudo dpkg-divert --package im-config --rename /usr/bin/ibus-daemon
Adding &#39;diversion of /usr/bin/ibus-daemon to /usr/bin/ibus-daemon.distrib by im-config&#39;</code></pre>
<p>附上启用ibus方法。</p>
<pre><code> $ sudo dpkg-divert --package im-config --rename --remove /usr/bin/ibus-daemon
Removing &#39;diversion of /usr/bin/ibus-daemon to /usr/bin/ibus-daemon.distrib by im-config&#39;</code></pre>
<p>原文链接：</p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/cocode/p/12875555.html">Ubuntu 20.04 LTS安装搜狗输入法，只需三条命令，还能自动更新​www.cnblogs.com![图标]<br>(https://pic1.zhimg.com/v2-b4a895150168f683f1e800179334bcfd_180x120.jpg)</a></p>
<p>麒麟社区软件：</p>
<p><a href="https://link.zhihu.com/?target=https://www.ubuntukylin.com/applications/">应用下载-Ubuntu Kylin,优麒麟,ubuntu,麒麟操作系统,优客-优麒麟操作系统​www.ubuntukylin.com<img src="https://pic2.zhimg.com/v2-e927aa8fcab6e2ecb1dbc065dcc90bdd_180x120.jpg" alt="图标"></a></p>
<p>Ubuntu kylin官方源：</p>
<p><a href="https://link.zhihu.com/?target=https://www.ukui.org/development.html">UKUI Desktop Environment​www.ukui.org<img src="https://pic3.zhimg.com/v2-05ebbf72a70cb5694109d13f79c2582a_180x120.jpg" alt="图标"></a><br>禁用ibus方法：<br><a href="https://link.zhihu.com/?target=https://wiki.debian.org/InputMethodBuster">InputMethodBuster - Debian Wiki​wiki.debian.org</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native.html" class="post-title-link" itemprop="url">未来已来：云原生 Cloud Native</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-11T00:00:00+00:00">2017-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自 2013 年容器（虚拟）技术（Docker）成熟后，后端的架构方式进入快速迭代的阶段，出现了很多新兴概念：</p>
<ul>
<li>微服务</li>
<li>k8s</li>
<li>Serverless</li>
<li>IaaS：基础设施服务，Infrastructure-as-a-service</li>
<li>PaaS：平台服务，Platform-as-a-service</li>
<li>SaaS：软件服务，Software-as-a-service</li>
<li>Cloud Native： 云原生</li>
<li>Service Mesh</li>
</ul>
<p>后端架构的变迁和云计算的发展密切相关，架构其实在不断地适应云计算，特别是云原生，被誉为未来架构，在 2019 年，云原生落地方案 Service Mesh 在国内外全面开花，我认为，未来已来。</p>
<p>接下来，我们将：</p>
<ul>
<li>梳理后端架构演化史，回顾后端架构发展历程；</li>
<li>回顾云服务发展历程，探讨云原生概念；</li>
<li>梳理云原生实现方案 Service Mesh 的发展历程；</li>
<li>介绍 Service Mesh 的代表 Istio 的亮眼功能；</li>
</ul>
<h2 id="后端架构演化史"><a href="#后端架构演化史" class="headerlink" title="后端架构演化史"></a>后端架构演化史</h2><h3 id="集中式架构"><a href="#集中式架构" class="headerlink" title="集中式架构"></a>集中式架构</h3><p>集中式架构又叫单体式架构，在Web2.0模式并未大规模兴起时十分流行。后来，基于Web应用的B/S（Browser/Server）架构逐渐取代了基于桌面应用的C/S（Client/Server）架构。B/S架构的后端系统大都采用集中式架构，它当时以优雅的分层设计，统一了服务器后端的开发领域。</p>
<p>集中式应用分为标准的3层架构模型：数据访问层M、服务层V和逻辑控制层C。每个层之间既可以共享领域模型对象，也可以进行更加细致的拆分。</p>
<p>其缺点是</p>
<ul>
<li>编译时间过长;</li>
<li>回归测试周期过长;</li>
<li>开发效率降低等；</li>
<li>不利于更新技术框架</li>
</ul>
<h3 id="分布式系统架构"><a href="#分布式系统架构" class="headerlink" title="分布式系统架构"></a>分布式系统架构</h3><p>对于互联网应用规模的迅速增长，集中式架构并无法做到无限制的提升系统的吞吐量，而分布式系统架构在理论上为吞吐量的上升提供了无限扩展的可能。因此，用于搭建互联网应用的服务器也渐渐地放弃了昂贵的小型机，转而采用大量的廉价PC服务器。</p>
<h3 id="容器技术新纪元-Docker"><a href="#容器技术新纪元-Docker" class="headerlink" title="容器技术新纪元 Docker"></a>容器技术新纪元 Docker</h3><p>分布式架构的概念很早就出现，阻碍其落地的最大问题是容器技术不成熟，应用程序在云平台运行，仍然需要为不同的开发语言安装相应的运行时环境。虽然自动化运维工具可以降低环境搭建的复杂度，但仍然不能从根本上解决环境的问题。</p>
<p>Docker的出现成为了软件开发行业新的分水岭；容器技术的成熟，也标志技术新纪元的开启。Docker让开发工程师可以将他们的应用和依赖封装到一个可移植的容器中。就像当年智能手机的出现改变了整个手机行业的游戏规则一样，Docker也大有席卷整个软件行业，并且进而改变行业游戏规则的趋势。通过集装箱式的封装，开发和运维都以标准化的方式发布的应用，异构语言不再是桎梏团队的枷锁。</p>
<p>在 Docker 之后，微服务得以流行开来</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>
<p>微服务优势</p>
<ul>
<li>可扩展</li>
<li>可升级</li>
<li>易维护</li>
<li>故障和资源的隔离</li>
</ul>
<p>微服务的问题</p>
<p>但是，世界上没有完美无缺的事物，微服务也是一样。著名软件大师，被认为是十大软件架构师之一的 Chris Richardson 曾一针见血地指出：“微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在 RPC 或者消息传递之间选择并完成进程间通讯机制。此外，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。”</p>
<p>在微服务架构中，一般要处理以下几类问题：</p>
<ul>
<li>服务治理：弹性伸缩，故障隔离</li>
<li>流量控制：路由，熔断，限速</li>
<li>应用观测：指标度量、链式追踪</li>
</ul>
<p>解决方案 Spring Cloud（Netflix OSS）</p>
<p>这是一个典型的微服务架构图</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/1.png"></p>
<p>Spring Cloud 体系提供了服务发现、负载均衡、失效转移、动态扩容、数据分片、调用链路监控等分布式系统的核心功能，一度成为微服务的最佳实践。</p>
<p>Spring Cloud 的问题</p>
<blockquote>
<p>如果开始构建微服务的方法，肯定容易被 Netflix OSS/Java/Spring/SpringCloud 所吸引。但是要知道你不是Netflix，也不需要直接使用 AWS EC2，使得应用程序变得很复杂。如今使用 docker 和采用 memos/kubernetes 是明智之举，它们已经具备大量的分布式系统特性。在应用层进行分层，是因为 netflix 5年前面临的问题，而不得不这样做（可以说如果那时有了kubernetes，netflix OSS栈会大不相同）。</p>
<p>因此，建议谨慎选择，按需选择，避免给应用程序带来不必要的复杂度。</p>
</blockquote>
<p>的确 SpringCloud 方案看起来很美好，但是它具有非常强的侵入性，应用代码中会包含大量的 SpringCloud 模块，而且对其他编程语言也不友好。</p>
<h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Kubernetes 出现就是为了解决 SpringCloud 的问题，不侵入应用层，在容器层解决问题。</p>
<p>Kubernetes 起源</p>
<p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。</p>
<p>Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。</p>
<p>Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。</p>
<p>Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p>
<h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><p>Service Mesh 是对 Kubernetes 的增强，提供了更多的能力。</p>
<p>2018年9月1日，Bilgin Ibryam 在 InfoQ 发表了一篇文章 <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/microservices-post-kubernetes/">Microservices in a Post-Kubernetes Era</a>，中文版见后 <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/microservices-post-kubernetes">Kubernetes 时代的微服务</a>（译文有些错误，仅供参考）。</p>
<p>文中作者的观点是：在后 Kubernetes 时代，服务网格（Service Mesh）技术已完全取代了使用软件库实现网络运维（例如 Hystrix 断路器）的方式。</p>
<p>如果说 Kubernetes 对 Spring Cloud 开了第一枪，那么 Service Mesh 就是 Spring Cloud 的终结者。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们用一个流程图来描述后端架构的发展历程<br><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/2.png"></p>
<p>每个关键节点的大概时间表</p>
<table>
<thead>
<tr>
<th align="left">架构/技术</th>
<th align="left">时间/年份</th>
</tr>
</thead>
<tbody><tr>
<td align="left">集中式架构</td>
<td align="left">~</td>
</tr>
<tr>
<td align="left">分布式架构</td>
<td align="left">~</td>
</tr>
<tr>
<td align="left">Docker</td>
<td align="left">2013</td>
</tr>
<tr>
<td align="left">微服务</td>
<td align="left">2014</td>
</tr>
<tr>
<td align="left">Spring Cloud</td>
<td align="left">2014</td>
</tr>
<tr>
<td align="left">Kubernetes 成熟</td>
<td align="left">2017</td>
</tr>
<tr>
<td align="left">Service Mesh</td>
<td align="left">2017</td>
</tr>
</tbody></table>
<p>可以看出，微服务生态这里，Spring Cloud 为代表的这条路已经后继无人了，未来属于 Service Mesh 。<br>Service Mesh 经过2年的发展，目前 Service Mesh 已经足够成熟，已经有生产落地的案例，我们接下来就看看 Service Mesh，在此之前，我们要先理解一个概念，云原生。</p>
<h2 id="云原生-Cloud-Native"><a href="#云原生-Cloud-Native" class="headerlink" title="云原生 Cloud Native"></a>云原生 Cloud Native</h2><p>如何理解“云原生”？之所以将这个话题放在前面，是因为，这是对云原生概念的最基本的理解，而这会直接影响到后续的所有认知。</p>
<p>注意：以下云原生的内容将全部引用敖小剑的 <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/fA42rfjV*dYGAvRANFqE">畅谈云原生（上）：云原生应用应该是什么样子？</a> 这篇文章，图画得太好了。</p>
<p>云原生的定义一直在发展，每个人对云原生的理解都可能不同，就如莎士比亚所说：一千个人眼中有一千个哈姆雷特。</p>
<p>2018 年 CNCF (<a target="_blank" rel="noopener" href="https://www.cncf.io/">Cloud Native Computing Foundation</a>)更新了云原生的定义。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/3.png"><br>这是新定义中描述的代表技术，其中容器和微服务两项在不同时期的不同定义中都有出现，而服务网格这个在 2017 年才开始被社区接纳的新热点技术被非常醒目的列出来，和微服务并列，而不是我们通常认为的服务网格只是微服务在实施时的一种新的方式。</p>
<p>那我们该如何理解云原生呢？我们尝试一下，将 Cloud Native 这个词汇拆开来理解，先看看什么是 Cloud。</p>
<h3 id="什么是云-Cloud"><a href="#什么是云-Cloud" class="headerlink" title="什么是云 Cloud"></a>什么是云 Cloud</h3><p>快速回顾一下云计算的历史，来帮助我们对云有个更感性的认识。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/4.png"></p>
<p>云计算的出现和虚拟化技术的发展和成熟密切相关，2000 年前后 x86 的虚拟机技术成熟后，云计算逐渐发展起来。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/5.png"></p>
<p>基于虚拟机技术，陆续出现了 IaaS/PaaS/FaaS 等形态，以及他们的开源版本。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/6.png"></p>
<p>2013 年 docker 出现，容器技术成熟，然后围绕容器编排一场大战，最后在 2017 年底，kubernetes 胜出。2015 年 CNCF 成立，并在近年形成了 cloud native 生态。</p>
<p>在这个过程中，云的形态一直变化，可以看到：供应商提供的功能越来越多，而客户或者说应用需要自己管理的功能越来越少。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/7.png"></p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/8.png"><br>架构也在一直适应云计算的变化</p>
<h3 id="什么是原生-Native"><a href="#什么是原生-Native" class="headerlink" title="什么是原生 Native"></a>什么是原生 Native</h3><p>在回顾完云计算的历史之后，我们对 Cloud 有更深的认识，接着继续看一下：什么是 Native？<br>字典的解释是：与生俱来的。<br>那 Cloud 和 native 和在一起，又该如何理解？</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/9.png"></p>
<p>这里我们抛出一个我们自己的理解：云原生代表着原生为云设计。详细的解释是：应用原生被设计为在云上以最佳方式运行，充分发挥云的优势。</p>
<p>这个理解有点空泛，但是考虑到云原生的定义和特征在这些年间不停的变化，以及完全可以预料到的在未来的必然变化，我觉得，对云原生的理解似乎也只能回到云原生的出发点，而不是如何具体实现。</p>
<h3 id="Cloud-Native-是道，Service-Mesh-是术"><a href="#Cloud-Native-是道，Service-Mesh-是术" class="headerlink" title="Cloud Native 是道，Service Mesh 是术"></a>Cloud Native 是道，Service Mesh 是术</h3><p>那在这么一个云原生理解的背景下，我再来介绍一下我对云原生应用的设想，也就是我觉得云原生应用应该是什么样子。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/10.png"></p>
<p>在云原生之前，底层平台负责向上提供基本运行资源。而应用需要满足业务需求和非业务需求，为了更好的代码复用，通用型好的非业务需求的实现往往会以类库和开发框架的方式提供，另外在 SOA/ 微服务时代部分功能会以后端服务的方式存在，这样在应用中就被简化为对其客户端的调用代码。</p>
<p>然后应用将这些功能，连同自身的业务实现代码，一起打包。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/11.png"></p>
<p>而云的出现，可以在提供各种资源之外，还提供各种能力，从而帮助应用，使得应用可以专注于业务需求的实现。<br>非业务需求相关的功能都被移到云，或者说基础设施中去了，以及下沉到基础设施的中间件。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/12.png"></p>
<p>以服务间通讯为例：需要实现上面列举的各种功能。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/13.png"></p>
<p>SDK 的思路：在应用层添加一个胖客户端，在这个客户端中实现各种功能。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/14.png"></p>
<p>Service Mesh 的思路，体现在将 SDK 客户端的功能剥离出来，放到 Sidecar 中。就是把更多的事情下沉，下沉到基础设施中。</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/15.png"></p>
<p>在用户看来，应用长这样：</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/16.png"></p>
<p>云原生是我们的目标，Service Mesh 交出了自己的答卷，接下来我们可以回到 Service Mesh 这里了。</p>
<h2 id="Service-Mesh-1"><a href="#Service-Mesh-1" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p>其中文译名是服务网格，这个词最早使用由开发Linkerd的Buoyant公司提出，并在内部使用。</p>
<p>定义</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/17.png"></p>
<p>服务网格的基本构成</p>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/18.jpeg"></p>
<h3 id="纷争-2017"><a href="#纷争-2017" class="headerlink" title="纷争 2017"></a>纷争 2017</h3><p>2017 年年底，当非侵入式的 Service Mesh 技术终于从萌芽到走向了成熟，当 Istio/Conduit 横空出世，人们才惊觉：微服务并非只有侵入式一种玩法，更不是 Spring Cloud 的独角戏！</p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2017-service-mesh">解读 2017 之 Service Mesh：群雄逐鹿烽烟起</a></p>
<p>文章总结一下：<br>创业公司 Buoyant 的产品 Linkerd 开局拿下一血；<br>Envoy 默默耕耘；<br>从 Google 和 IBM 联手推出 Istio，Linkerd 急转直下；<br>2017 年底 Buoyant 推出 Conduit 背水一战；<br>Nginmesh 与 Kong 低调参与；</p>
<h3 id="百家争鸣-2018"><a href="#百家争鸣-2018" class="headerlink" title="百家争鸣 2018"></a>百家争鸣 2018</h3><p>2018 年，Service Mesh 又多了哪些内容呢？在 2018 年，Service Mesh 在国内大热，有多家公司推出自己的 Service Mesh 产品和方案，Service Mesh 更加热闹了。<br>详细见这篇文章 <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/DtxylyFwlyl7K5Jte*WI">下一代微服务！Service Mesh 2018 年度总结</a></p>
<p>文章总结一下：<br>Service Mesh 在国内大热，有多家公司加入战场；<br>Istio 发布1.0，成为最受欢迎的 Service Mesh 项目，获得多方支持；<br>Envoy 继续稳扎稳打，Envoy 被 Istio 直接采用为数据平面，有望成为数据平面标准；<br>Linkerd1.x 陷入困境，Conduit 小步快跑，但响应平平，Buoyant 公司决定合并产品线，Linkerd1.x + Conduit = Linkerd2.0；<br>更多的公司参与 Service Mesh，国外有 Nginx、Consul、Kong、AWS等，国内有蚂蚁金服、新浪微博、华为，阿里 Dubbo，腾讯等；</p>
<h3 id="持续发展-2019"><a href="#持续发展-2019" class="headerlink" title="持续发展 2019"></a>持续发展 2019</h3><p>2019 将会听到更多 Service Mesh 的声音，请关注<a target="_blank" rel="noopener" href="https://www.servicemesher.com/">Service Mesh 中文社区</a></p>
<h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><p>前文讲到 Istio 是当前最受欢迎的 Service Mesh 框架，一句话定义 Istio：一个用来连接、管理和保护微服务的开放平台。<br>它能给我们的微服务提供哪些功能呢？</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li>动态路由</li>
<li>超时重试</li>
<li>熔断</li>
<li>故障注入</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://istio.io/zh/docs/tasks/traffic-management/">详细见官网介绍</a></p>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>安全问题一开始就要做好，在 Istio 实现安全通讯是非常方便的。</p>
<p>Istio 支持双向 TLS 加密</p>
<p><a target="_blank" rel="noopener" href="https://istio.io/zh/docs/tasks/security/">见官方文档</a></p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>速率限制<br>黑白名单</p>
<p><a target="_blank" rel="noopener" href="https://istio.io/zh/docs/tasks/policy-enforcement/">见官方文档</a></p>
<h3 id="观测"><a href="#观测" class="headerlink" title="观测"></a>观测</h3><ul>
<li>指标度量：每秒请求数，Prometheus 与 Grafana<br>使用 Grafana 观测流量情况</li>
</ul>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/19.jpeg"></p>
<ul>
<li>分布式追踪：Jaeger 或 Zipkin<br>快速观测调用链路</li>
</ul>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/20.png"></p>
<ul>
<li><p>日志：非应用日志</p>
</li>
<li><p>网格可视化<br>快速理清服务的关系</p>
</li>
</ul>
<p><img src="./2017-12-11_%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9FCloud_Native/21.png"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>虚拟化技术推动这云计算技术的变革，顺带也影响了后端架构的演进，目前我们身处云时代，将会有更多的元原生应用出现，Istio 作为其中的佼佼者，值得你投入一份精力了解一下。</p>
<h2 id="学习资料-指引"><a href="#学习资料-指引" class="headerlink" title="学习资料/指引"></a>学习资料/指引</h2><p><a target="_blank" rel="noopener" href="https://www.servicemesher.com/">Service Mesh 中文社区</a> 上面提供了丰富的学习资料。</p>
<p>搭建 Kubernetes 集群会比较麻烦，推荐几种方式。主要原因是很多镜像需要翻墙才能下载。</p>
<ol>
<li>Docker Desktop 自带的 Kubernetes 集群</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/aixiaoyang168/article/details/88600530">使用 Rancher2.0 搭建 Kubernetes 集群</a></li>
<li>在 Google Cloud 上直接开集群，可以领 300 美金的体验金，需要翻墙</li>
</ol>
<p>不推荐 MiniKube,翻墙和代理问题非常难搞。<br>再附上 Docker <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26033249">设置代理的方式</a></p>
<p><a target="_blank" rel="noopener" href="https://katacoda.com/courses/istio/deploy-istio-on-kubernetes">在线体验 Istio</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/">kubernetes-handbook</a></p>
<p><a target="_blank" rel="noopener" href="https://www.servicemesher.com/istio-handbook/">istio-handbook</a></p>
<p><a target="_blank" rel="noopener" href="https://skyao.gitbooks.io/learning-microservice/content/definition/Martin-Fowler/microservices.html">微服务学习笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/fA42rfjV*dYGAvRANFqE">畅谈云原生（上）：云原生应用应该是什么样子？</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/59fbab2151882576ea350afb">Service Mesh：下一代微服务？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8104194ff6fd">从架构到组件，深挖istio如何连接、管理和保护微服务2.0？</a></p>
<p><a target="_blank" rel="noopener" href="http://myfjdthink.com/2019/08/28/%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9F-cloud-native/">原文链接</a><br>作者: <a target="_blank" rel="noopener" href="http://myfjdthink.com/">天如</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-10_%E6%B5%85%E6%9E%90Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-10_%E6%B5%85%E6%9E%90Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.html" class="post-title-link" itemprop="url">浅析Linux中的零拷贝技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-10T00:00:00+00:00">2017-12-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文探讨Linux中<strong>主要的几种零拷贝技术</strong>以及零拷贝技术<strong>适用的场景</strong>。为了迅速建立起零拷贝的概念，我们拿一个常用的场景进行引入：</p>
<h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p>在写一个服务端程序时（Web Server或者文件服务器），文件下载是一个基本功能。这时候服务端的任务是：<strong>将服务端主机磁盘中的文件不做修改地从已连接的socket发出去</strong>，我们通常用下面的代码完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while((n &#x3D; read(diskfd, buf, BUF_SIZE)) &gt; 0)</span><br><span class="line">    write(sockfd, buf , n);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到<code>socket</code>。但是由于Linux的<code>I/O</code>操作默认是缓冲<code>I/O</code>。这里面主要使用的也就是<code>read</code>和<code>write</code>两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上<code>I/O</code>操作中，发生了多次的数据拷贝。</p>
<p>当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据<code>read</code>系统调用提供的<code>buf</code>地址，将内核缓冲区的内容拷贝到<code>buf</code>所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠<code>DMA</code>来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。  </p>
<p>接下来，<code>write</code>系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后<code>socket</code>再把内核缓冲区的内容发送到网卡上。  </p>
<p>说了这么多，不如看图清楚：  </p>
<p><img src="./2017-12-10_%E6%B5%85%E6%9E%90Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/1.png"></p>
<p>从上图中可以看出，共产生了四次数据拷贝，即使使用了<code>DMA</code>来处理了与硬件的通讯，CPU仍然需要处理两次数据拷贝，与此同时，在用户态与内核态也发生了多次上下文切换，无疑也加重了CPU负担。</p>
<p>在此过程中，我们没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，而零拷贝主要就是为了解决这种低效性。</p>
<h2 id="什么是零拷贝技术（zero-copy）？"><a href="#什么是零拷贝技术（zero-copy）？" class="headerlink" title="什么是零拷贝技术（zero-copy）？"></a>什么是零拷贝技术（zero-copy）？</h2><p>零拷贝主要的任务就是<strong>避免</strong>CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。</p>
<p>我们继续回到引文中的例子，我们如何减少数据拷贝的次数呢？一个很明显的着力点就是减少数据在内核空间和用户空间来回拷贝，这也引入了零拷贝的一个类型：</p>
<h2 id="让数据传输不需要经过user-space"><a href="#让数据传输不需要经过user-space" class="headerlink" title="让数据传输不需要经过user space"></a>让数据传输不需要经过user space</h2><h3 id="使用mmap"><a href="#使用mmap" class="headerlink" title="使用mmap"></a>使用mmap</h3><p>我们减少拷贝次数的一种方法是调用mmap()来代替read调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf &#x3D; mmap(diskfd, len);</span><br><span class="line">write(sockfd, buf, len);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用程序调用<code>mmap()</code>，磁盘上的数据会通过<code>DMA</code>被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用<code>write()</code>,操作系统直接将内核缓冲区的内容拷贝到<code>socket</code>缓冲区中，这一切都发生在内核态，最后，<code>socket</code>缓冲区再把数据发到网卡去。  </p>
<p>同样的，看图很简单：</p>
<p><img src="./2017-12-10_%E6%B5%85%E6%9E%90Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/2.png"></p>
<p>使用mmap替代read很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。但是使用<code>mmap</code>是有代价的。当你使用<code>mmap</code>时，你可能会遇到一些隐藏的陷阱。例如，当你的程序<code>map</code>了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被<code>SIGBUS</code>信号终止。<code>SIGBUS</code>信号默认会杀死你的进程并产生一个<code>coredump</code>,如果你的服务器这样被中止了，那会产生一笔损失。</p>
<p>通常我们使用以下解决方案避免这种问题：</p>
<p><strong>1. 为SIGBUS信号建立信号处理程序</strong></p>
<p>当遇到<code>SIGBUS</code>信号时，信号处理程序简单地返回，<code>write</code>系统调用在被中断之前会返回已经写入的字节数，并且<code>errno</code>会被设置成success,但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心。</p>
<p><strong>2. 使用文件租借锁</strong></p>
<p>通常我们使用这种方法，在文件描述符上使用租借锁，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的<code>RT_SIGNAL_LEASE</code>信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被<code>SIGBUS</code>杀死之前，你的<code>write</code>系统调用会被中断。<code>write</code>会返回已经写入的字节数，并且置<code>errno</code>为success。</p>
<p>我们应该在<code>mmap</code>文件之前加锁，并且在操作完文件后解锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(fcntl(diskfd, F_SETSIG, RT_SIGNAL_LEASE) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    perror(&quot;kernel lease set signal&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* l_type can be F_RDLCK F_WRLCK  加锁*&#x2F;</span><br><span class="line">&#x2F;* l_type can be  F_UNLCK 解锁*&#x2F;</span><br><span class="line">if(fcntl(diskfd, F_SETLEASE, l_type))&#123;</span><br><span class="line">    perror(&quot;kernel lease set type&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用sendfile"><a href="#使用sendfile" class="headerlink" title="使用sendfile"></a>使用sendfile</h3><p>从2.1版内核开始，Linux引入了<code>sendfile</code>来简化操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;sendfile.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统调用<code>sendfile()</code>在代表输入文件的描述符<code>in_fd</code>和代表输出文件的描述符<code>out_fd</code>之间传送文件内容（字节）。描述符<code>out_fd</code>必须指向一个套接字，而<code>in_fd</code>指向的文件必须是可以<code>mmap</code>的。这些局限限制了<code>sendfile</code>的使用，使<code>sendfile</code>只能将数据从文件传递到套接字上，反之则不行。  </p>
<p>使用<code>sendfile</code>不仅减少了数据拷贝的次数，还减少了上下文切换，数据传送始终只发生在<code>kernel space</code>。</p>
<p><img src="./2017-12-10_%E6%B5%85%E6%9E%90Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/3.png"></p>
<p>在我们调用<code>sendfile</code>时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，<code>sendfile</code>调用仅仅返回它在被中断之前已经传输的字节数，<code>errno</code>会被置为success。如果我们在调用sendfile之前给文件加了锁，<code>sendfile</code>的行为仍然和之前相同，我们还会收到RT_SIGNAL_LEASE的信号。</p>
<p>目前为止，我们已经减少了数据拷贝的次数了，但是仍然存在一次拷贝，就是页缓存到socket缓存的拷贝。那么能不能把这个拷贝也省略呢？</p>
<p>借助于硬件上的帮助，我们是可以办到的。之前我们是把页缓存的数据拷贝到socket缓存中，实际上，我们仅仅需要把缓冲区描述符传到<code>socket</code>缓冲区，再把数据长度传过去，这样<code>DMA</code>控制器直接将页缓存中的数据打包发送到网络中就可以了。</p>
<p>总结一下，<code>sendfile</code>系统调用利用<code>DMA</code>引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，<code>DMA</code>引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。  </p>
<p><img src="./2017-12-10_%E6%B5%85%E6%9E%90Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/4.png"></p>
<p>不过这一种收集拷贝功能是需要硬件以及驱动程序支持的。</p>
<h3 id="使用splice"><a href="#使用splice" class="headerlink" title="使用splice"></a>使用splice</h3><p>sendfile只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。Linux在<code>2.6.17</code>版本引入<code>splice</code>系统调用，用于在两个文件描述符中移动数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE         &#x2F;* See feature_test_macros(7) *&#x2F;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>splice调用在两个文件描述符之间移动数据，而不需要数据在内核空间和用户空间来回拷贝。他从<code>fd_in</code>拷贝<code>len</code>长度的数据到<code>fd_out</code>，但是有一方必须是管道设备，这也是目前<code>splice</code>的一些局限性。<code>flags</code>参数有以下几种取值：</p>
<ul>
<li><strong>SPLICE_F_MOVE</strong> ：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：如果内核不能从<code>pipe</code>移动数据或者<code>pipe</code>的缓存不是一个整页面，仍然需要拷贝数据。Linux最初的实现有些问题，所以从<code>2.6.21</code>开始这个选项不起作用，后面的Linux版本应该会实现。</li>
<li>** SPLICE_F_NONBLOCK** ：<code>splice</code> 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞。</li>
<li>** SPLICE_F_MORE**： 后面的<code>splice</code>调用会有更多的数据。</li>
</ul>
<p>splice调用利用了Linux提出的管道缓冲区机制， 所以至少一个描述符要为管道。</p>
<p>以上几种零拷贝技术都是减少数据在用户空间和内核空间拷贝技术实现的，但是有些时候，数据必须在用户空间和内核空间之间拷贝。这时候，我们只能针对数据在用户空间和内核空间拷贝的时机上下功夫了。Linux通常利用**写时复制(copy on write)**来减少系统开销，这个技术又时常称作<code>COW</code>。</p>
<p>由于篇幅原因，本文不详细介绍写时复制。大概描述下就是：如果多个程序同时访问同一块数据，那么每个程序都拥有指向这块数据的指针，在每个程序看来，自己都是独立拥有这块数据的，只有当程序需要对数据内容进行修改时，才会把数据内容拷贝到程序自己的应用空间里去，这时候，数据才成为该程序的私有数据。如果程序不需要对数据进行修改，那么永远都不需要拷贝数据到自己的应用空间里。这样就减少了数据的拷贝。写时复制的内容可以再写一篇文章了。。。</p>
<p>除此之外，还有一些零拷贝技术，比如传统的Linux I/O中加上<code>O_DIRECT</code>标记可以直接<code>I/O</code>，避免了自动缓存，还有尚未成熟的<code>fbufs</code>技术，本文尚未覆盖所有零拷贝技术，只是介绍常见的一些，如有兴趣，可以自行研究，一般成熟的服务端项目也会自己改造内核中有关I/O的部分，提高自己的数据传输速率。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fad3339e3448">https://www.jianshu.com/p/fad3339e3448</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/util/svn/2017-12-10_SVN%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E2%80%9C%E8%A2%AB%E6%89%8B%E5%8A%A8%E5%88%A0%E9%99%A4%E2%80%9D%E7%9A%84%E6%96%87%E4%BB%B6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/util/svn/2017-12-10_SVN%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E2%80%9C%E8%A2%AB%E6%89%8B%E5%8A%A8%E5%88%A0%E9%99%A4%E2%80%9D%E7%9A%84%E6%96%87%E4%BB%B6.html" class="post-title-link" itemprop="url">SVN 自动删除 “被手动删除” 的文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-10T00:00:00+00:00">2017-12-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SVN/" itemprop="url" rel="index"><span itemprop="name">SVN</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>删除SVN存储库工作副本中的文件时，应该在命令行上执行：</p>
<pre><code>svn rm [filename]</code></pre>
<p>但是，如果您不这样做(例如通过gui删除，或者只执行“rm”而不执行“svn”)，那么svn就会感到困惑，并将一个“!”在所有被删除的文件之前的状态。</p>
<p>如果您进行svn更新，所有的文件都将被恢复，显然您花费在删除它们上的所有时间都将被浪费了。</p>
<p>你真的应该使用svn rm，但如果已经太晚了，你可以使用这个bash脚本来删除svn中的文件：</p>
<pre><code> #从svn中删除你已经删除的文件    
 svn status | grep &quot;^\!&quot; | sed &#39;s/^\! *//g&#39; | xargs svn rm</code></pre>
<p>这个命令执行一个status命令，查找所有以“!”开头的行。然后提取文件名，并运行它通过“ svn rm ” 真正删除文件。</p>
<p>警告：确保您确实想删除所有这些文件！</p>
<p>使用方法自负风险。代码足够简单，所以您应该能够了解它的功能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-09_Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-09_Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">Linux内存映射mmap原理分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-09T00:00:00+00:00">2017-12-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。 </p>
<h2 id="二、基本函数"><a href="#二、基本函数" class="headerlink" title="二、基本函数"></a>二、基本函数</h2><p>mmap函数是unix/linux下的系统调用，详细内容可参考《Unix Netword programming》卷二12.2节。</p>
<p>mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。</p>
<p>mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用msync()来显式同步一下, 这样你所写的内容就能立即保存到文件里了.这点应该和驱动相关。 不过通过mmap来写文件这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.如果想取消内存映射，可以调用munmap()来取消内存映射。</p>
<pre><code>void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset)</code></pre>
<p>mmap用于把文件映射到内存空间中，简单说mmap就是把一个文件的内容在内存里面做一个映像。映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先，“映射”这个词，就和数学课上说的“一一映射”是一个意思，就是建立一种一一对应关系，在这里主要是只 硬盘上文件 的位置与进程 逻辑地址空间 中一块大小相同的区域之间的一一对应，如图1中过程1所示。这种对应关系纯属是逻辑上的概念，物理上是不存在的，原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存，具体到代码，就是建立并初始化了相关的数据结构（struct address_space），这个过程有系统调用mmap()实现，所以建立内存映射的效率很高。</p>
<p><img src="./2017-12-09_Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1.png"></p>
<p>|-图1.内存映射原理-|</p>
<p>既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。</p>
<p>mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址，如图1中过程2所示。这个过程与内存映射无关。</p>
<p>前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中，如图1中过程3所示。这个过程与内存映射无关。</p>
<p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么呢？原因是read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，如图2中过程1，然后再将这些数据拷贝到用户空间，如图2中过程2，在这个过程中，实际上完成了 两次数据拷贝 ；而mmap()也是系统调用，如前所述，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 一次数据拷贝 。因此，内存映射的效率要比read/write效率高。</p>
<p><img src="./2017-12-09_Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/2.png"></p>
<p>|-图2.read系统调用原理-|</p>
<p>下面这个程序，通过read和mmap两种方法分别对硬盘上一个名为“mmap_test”的文件进行操作，文件中存有10000个整数，程序两次使用不同的方法将它们读出，加1，再写回硬盘。通过对比可以看出，read消耗的时间将近是mmap的两到三倍。</p>
<pre><code>#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;sys/time.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;sys/mman.h&gt;
#define MAX 10000

int main()
&#123;

int i=0;

int count=0, fd=0;

struct timeval tv1, tv2;

int *array = (int *)malloc( sizeof(int)*MAX );
/*read*/
gettimeofday( &amp;tv1, NULL );

fd = open( &quot;mmap_test&quot;, O_RDWR );

if( sizeof(int)*MAX != read( fd, (void *)array, sizeof(int)*MAX ) )
&#123;

printf( &quot;Reading data failed.../n&quot; );

return -1;

&#125;

for( i=0; i&lt;MAX; ++i )

++array[ i ];

if( sizeof(int)*MAX != write( fd, (void *)array, sizeof(int)*MAX ) )

&#123;

printf( &quot;Writing data failed.../n&quot; );

return -1;

&#125;

free( array );

close( fd );

gettimeofday( &amp;tv2, NULL );

printf( &quot;Time of read/write: %dms/n&quot;, tv2.tv_usec-tv1.tv_usec );

/*mmap*/

gettimeofday( &amp;tv1, NULL );

fd = open( &quot;mmap_test&quot;, O_RDWR );

array = mmap( NULL, sizeof(int)*MAX, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0 );

for( i=0; i&lt;MAX; ++i )



++array[ i ];

munmap( array, sizeof(int)*MAX );

msync( array, sizeof(int)*MAX, MS_SYNC );

free( array );

close( fd );

gettimeofday( &amp;tv2, NULL );

printf( &quot;Time of mmap: %dms/n&quot;, tv2.tv_usec-tv1.tv_usec );

return 0;

&#125;</code></pre>
<p>输出结果：</p>
<p>Time of read/write: 154ms</p>
<p>Time of mmap: 68ms</p>
<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mg0832058/article/details/5890688">https://blog.csdn.net/mg0832058/article/details/5890688</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/util/monitor/2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/util/monitor/2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F.html" class="post-title-link" itemprop="url">从零开始搭建Prometheus自动监控报警系统（企业级）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-09T00:00:00+00:00">2017-12-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%9B%91%E6%8E%A7/" itemprop="url" rel="index"><span itemprop="name">监控</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是Prometheus"><a href="#什么是Prometheus" class="headerlink" title="什么是Prometheus?"></a>什么是Prometheus?</h2><p>Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。 </p>
<p>2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。 </p>
<p>Prometheus目前在开源社区相当活跃。 </p>
<p>Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。</p>
<h2 id="Prometheus的特点"><a href="#Prometheus的特点" class="headerlink" title="Prometheus的特点"></a>Prometheus的特点</h2><ul>
<li>多维度数据模型。</li>
<li>灵活的查询语言。</li>
<li>不依赖分布式存储，单个服务器节点是自主的。</li>
<li>通过基于HTTP的pull方式采集时序数据。</li>
<li>可以通过中间网关进行时序列数据推送。</li>
<li>通过服务发现或者静态配置来发现目标服务对象。</li>
<li>支持多种多样的图表和界面展示，比如Grafana等。</li>
</ul>
<p>官网地址：<a target="_blank" rel="noopener" href="https://prometheus.io/">https://prometheus.io/</a></p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/1.png"></p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/2.png"></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Prometheus的基本原理是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如VM、Docker、Kubernetes等。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux系统信息(包括磁盘、内存、CPU、网络等等)。</p>
<h2 id="服务过程"><a href="#服务过程" class="headerlink" title="服务过程"></a>服务过程</h2><ul>
<li>Prometheus Daemon负责定时去目标上抓取metrics(指标)数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。Prometheus支持通过配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup等方式指定抓取目标。Prometheus采用PULL的方式进行监控，即服务器可以直接通过目标PULL数据或者间接地通过中间网关来Push数据。</li>
<li>Prometheus在本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。</li>
<li>Prometheus通过PromQL和其他API可视化地展示收集的数据。Prometheus支持很多方式的图表可视化，例如Grafana、自带的Promdash以及自身提供的模版引擎等等。Prometheus还提供HTTP API的查询方式，自定义所需要的输出。</li>
<li>PushGateway支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</li>
<li>Alertmanager是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</li>
</ul>
<h2 id="三大套件"><a href="#三大套件" class="headerlink" title="三大套件"></a>三大套件</h2><ul>
<li>Server 主要负责数据采集和存储，提供PromQL查询语言的支持。</li>
<li>Alertmanager 警告管理器，用来进行报警。</li>
<li>Push Gateway 支持临时性Job主动推送指标的中间网关。</li>
</ul>
<h2 id="本飞猪教程内容简介"><a href="#本飞猪教程内容简介" class="headerlink" title="本飞猪教程内容简介"></a>本飞猪教程内容简介</h2><ul>
<li>1.演示安装Prometheus Server</li>
<li>2.演示通过golang和node-exporter提供metrics接口</li>
<li>3.演示pushgateway的使用</li>
<li>4.演示grafana的使用</li>
<li>5.演示alertmanager的使用</li>
</ul>
<h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>这里我的IP是10.211.55.25，登入，建立相应文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;chenqionghe&#x2F;promethues</span><br><span class="line">mkdir -p &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;server</span><br><span class="line">mkdir -p &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;client</span><br><span class="line">touch &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;server&#x2F;rules.yml</span><br><span class="line">chmod 777 &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;server&#x2F;rules.yml</span><br></pre></td></tr></table></figure>

<p>下面开始三大套件的学习</p>
<h1 id="一-安装Prometheus-Server"><a href="#一-安装Prometheus-Server" class="headerlink" title="一.安装Prometheus Server"></a>一.安装Prometheus Server</h1><p>通过docker方式 </p>
<p>首先创建一个配置文件/home/chenqionghe/test/prometheus/prometheus.yml </p>
<p>挂载之前需要改变文件权限为777，要不会引起修改宿主机上的文件 会引起内容不同步的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # 默认抓取间隔, 15秒向目标抓取一次数据。</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: &#39;codelab-monitor&#39;</span><br><span class="line"># 这里表示抓取对象的配置</span><br><span class="line">scrape_configs:</span><br><span class="line">    #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:&quot;prometheus&quot;&#125;的标签  - job_name: &#39;prometheus&#39;</span><br><span class="line">    scrape_interval: 5s # 重写了全局抓取间隔时间，由15秒重写成5秒</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#39;localhost:9090&#39;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f prometheus</span><br><span class="line">docker run --name&#x3D;prometheus -d \</span><br><span class="line">-p 9090:9090 \</span><br><span class="line">-v &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;server&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \</span><br><span class="line">-v &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;server&#x2F;rules.yml:&#x2F;etc&#x2F;prometheus&#x2F;rules.yml \</span><br><span class="line">prom&#x2F;prometheus:v2.7.2 \</span><br><span class="line">--config.file&#x3D;&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \</span><br><span class="line">--web.enable-lifecycle</span><br></pre></td></tr></table></figure>

<p>启动时加上–web.enable-lifecycle启用远程热加载配置文件 </p>
<p>调用指令是curl -X POST <a target="_blank" rel="noopener" href="http://localhost:9090/-/reload">http://localhost:9090/-/reload</a></p>
<p>访问<a target="_blank" rel="noopener" href="http://10.211.55.25:9090/">http://10.211.55.25:9090</a> </p>
<p>我们会看到如下l界面 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/3.png"></p>
<p>访问<a target="_blank" rel="noopener" href="http://10.211.55.25:9090/metrics">http://10.211.55.25:9090/metrics</a> </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/4.png"></p>
<p>我们配置了9090端口，默认prometheus会抓取自己的/metrics接口 </p>
<p>在Graph选项已经可以看到监控的数据 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/5.png"></p>
<h1 id="二-安装客户端提供metrics接口"><a href="#二-安装客户端提供metrics接口" class="headerlink" title="二.安装客户端提供metrics接口"></a>二.安装客户端提供metrics接口</h1><h2 id="1-通过golang客户端提供metrics"><a href="#1-通过golang客户端提供metrics" class="headerlink" title="1.通过golang客户端提供metrics"></a>1.通过golang客户端提供metrics</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;client&#x2F;golang&#x2F;src</span><br><span class="line">cd !$</span><br><span class="line">export GOPATH&#x3D;&#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;client&#x2F;golang&#x2F;</span><br><span class="line">#克隆项目</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;client_golang.git</span><br><span class="line">#安装需要FQ的第三方包</span><br><span class="line">mkdir -p $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;</span><br><span class="line">cd !$</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;net.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;sys.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;tools.git</span><br><span class="line">#安装必要软件包</span><br><span class="line">go get -u -v github.com&#x2F;prometheus&#x2F;client_golang&#x2F;prometheus</span><br><span class="line">#编译</span><br><span class="line">cd $GOPATH&#x2F;src&#x2F;client_golang&#x2F;examples&#x2F;random</span><br><span class="line">go build -o random main.go</span><br></pre></td></tr></table></figure>

<p>运行3个示例metrics接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;random -listen-address&#x3D;:8080 &amp;</span><br><span class="line">.&#x2F;random -listen-address&#x3D;:8081 &amp;</span><br><span class="line">.&#x2F;random -listen-address&#x3D;:8082 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="2-通过node-exporter提供metrics"><a href="#2-通过node-exporter提供metrics" class="headerlink" title="2.通过node exporter提供metrics"></a>2.通过node exporter提供metrics</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name&#x3D;node-exporter \</span><br><span class="line">-p 9100:9100 \</span><br><span class="line">prom&#x2F;node-exporter</span><br></pre></td></tr></table></figure>

<p>然后把这两些接口再次配置到prometheus.yml, 重新载入配置curl -X POST <a target="_blank" rel="noopener" href="http://localhost:9090/-/reload">http://localhost:9090/-/reload</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # 默认抓取间隔, 15秒向目标抓取一次数据。</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: &#39;codelab-monitor&#39;</span><br><span class="line">rule_files:</span><br><span class="line">  #- &#39;prometheus.rules&#39;</span><br><span class="line"># 这里表示抓取对象的配置</span><br><span class="line">scrape_configs:</span><br><span class="line">  #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:&quot;prometheus&quot;&#125;的标签  - job_name: &#39;prometheus&#39;</span><br><span class="line">  - job_name: &#39;prometheus&#39;</span><br><span class="line">    scrape_interval: 5s # 重写了全局抓取间隔时间，由15秒重写成5秒</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#39;localhost:9090&#39;]</span><br><span class="line">      - targets: [&#39;http:&#x2F;&#x2F;10.211.55.25:8080&#39;, &#39;http:&#x2F;&#x2F;10.211.55.25:8081&#39;,&#39;http:&#x2F;&#x2F;10.211.55.25:8082&#39;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &#39;client-golang&#39;</span><br><span class="line">      - targets: [&#39;http:&#x2F;&#x2F;10.211.55.25:9100&#39;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &#39;client-node-exporter&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到接口都生效了 </p>
<p>prometheus还提供了各种exporter工具，感兴趣小伙伴可以去研究一下</p>
<h1 id="三-安装pushgateway"><a href="#三-安装pushgateway" class="headerlink" title="三.安装pushgateway"></a>三.安装pushgateway</h1><p>pushgateway是为了允许临时作业和批处理作业向普罗米修斯公开他们的指标。 </p>
<p>由于这类作业的存在时间可能不够长, 无法抓取到, 因此它们可以将指标推送到推网关中。 </p>
<p>Prometheus采集数据是用的pull也就是拉模型，这从我们刚才设置的5秒参数就能看出来。但是有些数据并不适合采用这样的方式，对这样的数据可以使用Push Gateway服务。 </p>
<p>它就相当于一个缓存，当数据采集完成之后，就上传到这里，由Prometheus稍后再pull过来。 </p>
<p>我们来试一下，首先启动Push Gateway</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;pushgateway</span><br><span class="line">cd !$</span><br><span class="line">docker run -d -p 9091:9091 --name pushgateway prom&#x2F;pushgateway</span><br></pre></td></tr></table></figure>

<p>访问<a target="_blank" rel="noopener" href="http://10.211.55.25:9091/">http://10.211.55.25:9091</a> 已经pushgateway运行起来了 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/6.png"></p>
<p>接下来我们就可以往pushgateway推送数据了，prometheus提供了多种语言的sdk，最简单的方式就是通过shell</p>
<ul>
<li>推送一个指标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;cqh_metric 3.14&quot; | curl --data-binary @- http:&#x2F;&#x2F;ubuntu-linux:9091&#x2F;metrics&#x2F;job&#x2F;cqh</span><br></pre></td></tr></table></figure>

<ul>
<li>推送多个指标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | curl --data-binary @- http:&#x2F;&#x2F;10.211.55.25:9091&#x2F;metrics&#x2F;job&#x2F;cqh&#x2F;instance&#x2F;test</span><br><span class="line"># 锻炼场所价格</span><br><span class="line">muscle_metric&#123;label&#x3D;&quot;gym&quot;&#125; 8800</span><br><span class="line"># 三大项数据 kg</span><br><span class="line">bench_press 100</span><br><span class="line">dead_lift 160</span><br><span class="line">deep_squal 160</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后我们再将pushgateway配置到prometheus.yml里边,重载配置 </p>
<p>看到已经可以搜索出刚刚推送的指标了 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/7.png"></p>
<h1 id="四-安装Grafana展示"><a href="#四-安装Grafana展示" class="headerlink" title="四.安装Grafana展示"></a>四.安装Grafana展示</h1><p>Grafana是用于可视化大型测量数据的开源程序，它提供了强大和优雅的方式去创建、共享、浏览数据。 </p>
<p>Dashboard中显示了你不同metric数据源中的数据。 </p>
<p>Grafana最常用于因特网基础设施和应用分析，但在其他领域也有用到，比如：工业传感器、家庭自动化、过程控制等等。 </p>
<p>Grafana支持热插拔控制面板和可扩展的数据源，目前已经支持Graphite、InfluxDB、OpenTSDB、Elasticsearch、Prometheus等。</p>
<p>我们使用docker安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name grafana grafana&#x2F;grafana</span><br></pre></td></tr></table></figure>

<p>默认登录账户和密码都是admin，进入后界面如下 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/8.png"></p>
<p>我们添加一个数据源 </p>
<p>把Prometheus的地址填上 </p>
<p>导入prometheus的模板 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/9.png"></p>
<p>打开左上角选择已经导入的模板会看到已经有各种图 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/10.png"></p>
<p>我们来添加一个自己的图表 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/11.png"></p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/12.png"></p>
<p>指定自己想看的图标和关键字，右上角保存 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/13.png"></p>
<p>看到如下数据 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/14.png"></p>
<p>到这里我们就已经实现了数据的自动收集和展示，下面来说下prometheus如何自动报警</p>
<h1 id="五-安装AlterManager"><a href="#五-安装AlterManager" class="headerlink" title="五.安装AlterManager"></a>五.安装AlterManager</h1><p>Pormetheus的警告由独立的两部分组成。 </p>
<p>Prometheus服务中的警告规则发送警告到Alertmanager。 </p>
<p>然后这个Alertmanager管理这些警告。包括silencing, inhibition, aggregation，以及通过一些方法发送通知，例如：email，PagerDuty和HipChat。 </p>
<p>建立警告和通知的主要步骤：</p>
<ul>
<li>创建和配置Alertmanager</li>
<li>启动Prometheus服务时，通过-alertmanager.url标志配置Alermanager地址，以便Prometheus服务能和Alertmanager建立连接。</li>
</ul>
<p>创建和配置Alertmanager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;alertmanager</span><br><span class="line">cd !$</span><br></pre></td></tr></table></figure>

<p>创建配置文件alertmanager.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">route:</span><br><span class="line">  group_by: [&#39;cqh&#39;]</span><br><span class="line">  group_wait: 10s #组报警等待时间</span><br><span class="line">  group_interval: 10s #组报警间隔时间</span><br><span class="line">  repeat_interval: 1m #重复报警间隔时间</span><br><span class="line">  receiver: &#39;web.hook&#39;</span><br><span class="line">receivers:</span><br><span class="line">  - name: &#39;web.hook&#39;</span><br><span class="line">    webhook_configs:</span><br><span class="line">      - url: &#39;http:&#x2F;&#x2F;10.211.55.2:8888&#x2F;open&#x2F;test&#39;</span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: &#39;critical&#39;</span><br><span class="line">    target_match:</span><br><span class="line">      severity: &#39;warning&#39;</span><br><span class="line">    equal: [&#39;alertname&#39;, &#39;dev&#39;, &#39;instance&#39;]</span><br></pre></td></tr></table></figure>

<p>这里配置成了web.hook的方式，当server通知alertmanager会自动调用webhook <a target="_blank" rel="noopener" href="http://10.211.55.2:8888/open/test">http://10.211.55.2:8888/open/test</a></p>
<p>下面运行altermanager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f alertmanager</span><br><span class="line">docker run -d -p 9093:9093 \</span><br><span class="line">--name alertmanager \</span><br><span class="line">-v &#x2F;home&#x2F;chenqionghe&#x2F;promethues&#x2F;alertmanager&#x2F;alertmanager.yml:&#x2F;etc&#x2F;alertmanager&#x2F;alertmanager.yml \</span><br><span class="line">prom&#x2F;alertmanager</span><br></pre></td></tr></table></figure>

<p>访问<a target="_blank" rel="noopener" href="http://10.211.55.25:9093/">http://10.211.55.25:9093</a> </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/15.png"></p>
<p>接下来修改Server端配置报警规则和altermanager地址 </p>
<p>修改规则/home/chenqionghe/promethues/server/rules.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">groups:</span><br><span class="line">  - name: cqh</span><br><span class="line">    rules:</span><br><span class="line">      - alert: cqh测试</span><br><span class="line">        expr: dead_lift &gt; 150</span><br><span class="line">        for: 1m</span><br><span class="line">        labels:</span><br><span class="line">          status: warning</span><br><span class="line">        annotations:</span><br><span class="line">          summary: &quot;&#123;&#123;$labels.instance&#125;&#125;:硬拉超标！lightweight baby!!!&quot;</span><br><span class="line">          description: &quot;&#123;&#123;$labels.instance&#125;&#125;:硬拉超标！lightweight baby!!!&quot;</span><br></pre></td></tr></table></figure>

<p>这条规则的意思是，硬拉超过150公斤，持续一分钟，就报警通知 </p>
<p>然后再修改prometheus添加altermanager配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # 默认抓取间隔, 15秒向目标抓取一次数据。</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: &#39;codelab-monitor&#39;</span><br><span class="line">rule_files:</span><br><span class="line">  - &#x2F;etc&#x2F;prometheus&#x2F;rules.yml</span><br><span class="line"># 这里表示抓取对象的配置</span><br><span class="line">scrape_configs:</span><br><span class="line">  #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:&quot;prometheus&quot;&#125;的标签  - job_name: &#39;prometheus&#39;</span><br><span class="line">  - job_name: &#39;prometheus&#39;</span><br><span class="line">    scrape_interval: 5s # 重写了全局抓取间隔时间，由15秒重写成5秒</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#39;localhost:9090&#39;]</span><br><span class="line">      - targets: [&#39;10.211.55.25:8080&#39;, &#39;10.211.55.25:8081&#39;,&#39;10.211.55.25:8082&#39;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &#39;client-golang&#39;</span><br><span class="line">      - targets: [&#39;10.211.55.25:9100&#39;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &#39;client-node-exporter&#39;</span><br><span class="line">      - targets: [&#39;10.211.55.25:9091&#39;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &#39;pushgateway&#39;</span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">    - static_configs:</span><br><span class="line">        - targets: [&quot;10.211.55.25:9093&quot;]</span><br></pre></td></tr></table></figure>

<p>重载prometheus配置，规则就已经生效 </p>
<p>接下来我们观察grafana中数据的变化 </p>
<p>然后我们点击prometheus的Alert模块，会看到已经由绿-&gt;黄-红，触发了报警 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/16.png"></p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/17.png"></p>
<p>然后我们再来看看提供的webhook接口，这里的接口我是用的golang写的，接到数据后将body内容报警到钉钉 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/18.png"></p>
<p>钉钉收到报警内容如下 </p>
<p><img src="./2017-12-10_%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAPrometheus%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/19.png"></p>
<p>到这里，从零开始搭建Prometheus实现自动监控报警就说介绍完了，一条龙服务，自动抓取接口+自动报警+优雅的图表展示，你还在等什么，赶紧high起来！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor.html" class="post-title-link" itemprop="url">两种高性能 I/O 设计模式 Reactor 和 Proactor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-08 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-08T00:00:00+00:00">2017-12-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Reactor 和 Proactor 是基于事件驱动，在网络编程中经常用到两种设计模式。</p>
<p>曾经在一个项目中用到了网络库 libevent，也学习了一段时间，其内部实现所用到的就是 Reactor，所知道的还有 ACE；Proactor 模式的库有 Boost.Asio，ACE，暂时没有用过。但我也翻阅了一些文档，理解了它的实现方法。下面是我在学习这两种设计模式过程的笔记。</p>
<h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><p>Reactor，即反应堆。Reactor 的一般工作过程是首先在 Reactor 中注册（Reactor）感兴趣事件，并在注册时候指定某个已定义的回调函数（callback）；当客户端发送请求时，在 Reactor 中会触发刚才注册的事件，并调用对应的处理函数。在这一个处理回调函数中，一般会有数据<strong>接收</strong>、处理、<strong>回复</strong>请求等操作。</p>
<p><img src="./2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/1.png"></p>
<p>libevent 采用的就是 Reactor 的设计思想。其 <strong>Reactor 的中心思想是众所周知的 I/O 多路复用</strong>：select,poll,epoll,kqueue 等.libevent 精彩的将定时事件，信号处理，I/O 事件结合在在一起，也就是说用户同时在 Reactor 中注册上述三类事件。遗憾的是，libevent 不支持多线程，也就是说它同步处理请求，导致不能处理大量的请求；这样并不是说 Reactor 实现的网络库都不支持多线程，而是 libevent 本身的原因，我们也可以通过修改让 ilbevent 支持多线程，并发处理多个请求。</p>
<p>下面是 libevent 的一段代码，大概能够说明 Reactor 工作模式：</p>
<pre><code>/*accept callback function.*/
void accept_callback(int fd,  short ev,void *arg)
&#123;
    ......
&#125;
......
struct event accept_event;
event_set(&amp;accept_event,
                socketlisten,
                EV_READ|EV_PERSIST,
                accept_callback,
                NULL);

event_add(&amp;accept_event,
                NULL);

event_dispatch();</code></pre>
<h4 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h4><p>从上面 Reactor 模式中，发现服务端数据的接收和发送都占用了用户状态（还有一种内核态），这样服务器的处理操作就在数据的读写上阻塞花费了时间，节省这些时间的办法是借助操作系统的异步读写；异步读写在调用的时候可以传递回调函数或者回送信号，当异步操作完毕，内核会自动调用回调函数或者发送信号。Proactor 就是这么做的，所以很依赖操作系统。来一幅 UML：</p>
<p><img src="./2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/2.png"></p>
<p>和时序图：</p>
<p><img src="./2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/3.png"></p>
<p><em>注：这两幅美艳的图片来自 Proactor.doc，下面会提到.</em></p>
<p>Proactor 的实现主要有三个部分：异步操作处理器，Proactor 和 事件处理函数。其中：</p>
<pre><code>- 异步操作处理器，很依赖操作系统的异步处理机制，如若操作系统没有实现，我们可以自行模拟，即开专门的数据读写线程，数据读写完毕触发相应的时间（如果有注册的话）；
- Proactor，会接收异步操作的提醒，调用相应的事件处理函数，它有自己的 event loop；
- 事件处理函数，事件触发，执行操作；</code></pre>
<p>曾经看过 Proactor.doc，作者是 Douglas C. Schmidt，你可以在<a target="_blank" rel="noopener" href="http://www.laputan.org/pub/sag/proactor.pdf">这里</a>阅读此文档。里面的关于 Proactor 的讲解很精彩，部分摘抄和自己的理解如下：当连接 web 服务器时：</p>
<p><img src="./2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/4.png"></p>
<ul>
<li><p>  web 服务器指定（1）接收器，此接收器相当于服务器的客户端，它可以启动异步的 accept 操作；</p>
</li>
<li><p>  接收器调用操作系统上的异步接收操作（2），并传递自己和 Proactor 的引用；异步接收操作结束后，前者用作事件处理函数，后者会回过头来分发事件；<em>注：传递 Proactor 是为了让操作系统通知正确的 Proactor，可能会存在多个 Proactor；传递接收器自己是为了在异步接收操作结束后 Proactor 能调用正确的事件处理函数，以下同理。</em></p>
</li>
<li><p>  web 服务器调用 Proactor 的事件循环；（3）</p>
</li>
<li><p>  web 浏览器连接 web 服务器；（4）</p>
</li>
<li><p>  异步接收操作结束后，操作系统产生事件（通过回调或者信号）并通知 Proactor（5），Proactor 收到后会调用相应的事件处理函数，即交由接收器处理；（6）</p>
</li>
<li><p>  接收器生成 HTTP 处理器，执行操作；（7）</p>
</li>
<li><p>  HTTP 处理器解析事件，启动异步读操作（8），获取来自浏览器的 GET 请求。同样，HTTP 处理器传递自己和 Proactor 的引用；</p>
</li>
<li><p>  web 服务器的控制权交还回 Proactor 的事件循环。（9）</p>
</li>
</ul>
<p>接收 GET 请求过后，会处理数据：</p>
<p><img src="./2017-12-08_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BDIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/5.png"></p>
<ul>
<li><p>  浏览器发送（1）一个 HTTP GET 请求；</p>
</li>
<li><p>  异步读操作结束后，操作系统会通知 Proactor，Proactor 分发给事件处理函数；（2，3）</p>
</li>
<li><p>  事件处理器解析请求。（4）2-4 步骤会重复，指导所有的数据都接收为止；</p>
</li>
<li><p>  事件处理器产生答复数据；（5）</p>
</li>
<li><p>  HTTP 处理器启动异步写操作（6），传输应答数据，同样的这里还会传递处理器自己和 Proactor；</p>
</li>
<li><p>  异步写操作结束，操作系统通知 Proactor（7），Proactor 分发给事件处理函数（8）。6-8 步骤会重复直到所有的数据写完为止。至此，一个请求回复完成。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>相比网络编程中最简单的思路模式：bind,listen,accept,read,server operator,write，Reactor 和 Proactor 是两种高性能的设计模式，掌握此两种模式，有助于理解一些网络库的工作流程。此文提到了两种设计模式，但没有一些技术细节，譬如多线程同步。如果在 Reactor 中支持多线程，或多个线程共享一个 Proactor，线程的同步问题就来了。共享一篇印象笔记关于线程的综合讨论：<a target="_blank" rel="noopener" href="http://app.yinxiang.com/shard/s9/sh/732ee92e-0eac-4080-94ce-b9a04e173cdf/9b403c45ee885eb64949970fddd3417e">这里</a>.</p>
<p>《<a target="_blank" rel="noopener" href="http://www.artima.com/articles/io_design_patterns.html">Comparing Two High-Performance I/O Design Patterns</a>》提到<strong>一个将 Reactor 模拟 Proactor 而不借助操作系统异步机制的方法</strong>：同样在 Reactor 注册感兴趣的事件（比如读），当事件发生时，执行非阻塞的读，读毕即才调用数据处理——假异步。</p>
<p>最后，实践出真知。欢迎讨论。</p>
<p>原文：<a target="_blank" rel="noopener" href="http://daoluan.net/linux/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2013/08/20/two-high-performance-io-design-patterns.html">http://daoluan.net/linux/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2013/08/20/two-high-performance-io-design-patterns.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.html" class="post-title-link" itemprop="url">Unix 网络 IO 模型及 Linux 的 IO 多路复用模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-07T00:00:00+00:00">2017-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>近段在看 Kafka 的网络模型时，遇到了很多 Java NIO 的内容，在学习 Java NIO 的过程中，发现需要把 UNIX 的这几种网络 IO 模型以及 Linux 的 IO 多路复用理解清楚，才能更好地理解 Java NIO，本文就是在学习 UNIX 的五种网络 IO 模型以及 Linux IO 多路复用模型后，做的一篇总结。</p>
<p>本文主要探讨的问题有以下两个：</p>
<ol>
<li>Unix 中的五种网络 IO 模型；</li>
<li>Linux 中 IO 多路复用的实现。</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><hr>
<p>在介绍网络模型之前，先简单介绍一些基本概念。</p>
<h4 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h4><p>文件描述符（file descriptor，简称 fd）在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>在 Linux 中，内核将所有的外部设备都当做一个文件来进行操作，而对一个文件的读写操作会调用内核提供的系统命令，返回一个 fd，对一个 socket 的读写也会有相应的描述符，称为 socketfd（socket 描述符），实际上描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性）。</p>
<h4 id="用户空间与内核空间、内核态与用户态"><a href="#用户空间与内核空间、内核态与用户态" class="headerlink" title="用户空间与内核空间、内核态与用户态"></a>用户空间与内核空间、内核态与用户态</h4><p>这个是经常提到的概念，具体含义可以参考这篇文章<a target="_blank" rel="noopener" href="http://www.cnblogs.com/Anker/p/3269106.html">用户空间与内核空间，进程上下文与中断上下文【总结】</a>，大概内容如下：</p>
<p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 linux 操作系统而言（以32位操作系统为例）</p>
<ul>
<li>将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间；</li>
<li>将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</li>
</ul>
<p>每个进程可以通过系统调用进入内核，因此，Linux 内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间。</p>
<ul>
<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈；</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li>
</ul>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>当一个进程在执行时，CPU 的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。</p>
<p>当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在 Linux 中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时，内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。</p>
<h3 id="UNIX-的网络-IO-模型"><a href="#UNIX-的网络-IO-模型" class="headerlink" title="UNIX 的网络 IO 模型"></a>UNIX 的网络 IO 模型</h3><hr>
<p>根据 UNIX 网络编程对 IO 模型的分类，UNIX 提供了以下 5 种 IO 模型。</p>
<h4 id="阻塞-IO-模型"><a href="#阻塞-IO-模型" class="headerlink" title="阻塞 IO 模型"></a>阻塞 IO 模型</h4><p>最常用的 IO 模型就是阻塞 IO 模型，在缺省条件下，所有文件操作都是阻塞的，以 socket 读为例来介绍一下此模型，如下图所示。</p>
<p><img src="./2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/1.png"></p>
<p>在用户空间调用 <code>recvfrom</code>，系统调用直到数据包达到且被复制到应用进程的缓冲区中或中间发生异常返回，在这个期间进程会一直等待。进程从调用 <code>recvfrom</code> 开始到它返回的整段时间内都是被阻塞的，因此，被称为阻塞 IO 模型。</p>
<h4 id="非阻塞-IO-模型"><a href="#非阻塞-IO-模型" class="headerlink" title="非阻塞 IO 模型"></a>非阻塞 IO 模型</h4><p>recvfrom 从应用到内核的时，如果该缓冲区没有数据，就会直接返回 EWOULDBLOCK 错误，一般都对非阻塞 IO 模型进行轮询检查这个状态，看看内核是不是有数据到来，流程如下图所示。</p>
<p><img src="./2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/2.png"></p>
<p>也就是说非阻塞的 <code>recvform</code> 系统调用调用之后，进程并没有被阻塞，内核马上返回给进程。</p>
<p>如果数据还没准备好，此时会返回一个 error。进程在返回之后，可以干点别的事情，然后再发起 <code>recvform</code> 系统调用。重复上面的过程，循环往复的进行 <code>recvform</code> 系统调用，这个过程通常被称之为轮询。</p>
<p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<p>在 Linux 下，可以通过设置 socket 使其变为 non-blocking。</p>
<h4 id="IO-多路复用模型"><a href="#IO-多路复用模型" class="headerlink" title="IO 多路复用模型"></a>IO 多路复用模型</h4><p>Linux 提供 select、poll、epoll，进程通过讲一个或者多个 fd 传递给 select、poll、epoll 系统调用，阻塞在 select 操作（这个是内核级别的调用）上，这样的话，可以同时监听多个 fd 是否处于就绪状态。其中，</p>
<ul>
<li>select/poll 是顺序扫描 fd 是否就绪，而且支持的 fd 数量有限；</li>
<li>epoll 是基于事件驱动方式代替顺序扫描性能更高。</li>
</ul>
<p>这个后面详细讲述，具体流程如下图所示。</p>
<p><img src="./2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/3.png"></p>
<p>多路复用的特点是通过一种机制一个进程能同时等待 IO 文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll 函数就可以返回，它最大的优势就是可以同时处理多个连接。</p>
<h4 id="信号驱动-IO-模型"><a href="#信号驱动-IO-模型" class="headerlink" title="信号驱动 IO 模型"></a>信号驱动 IO 模型</h4><p>首先需要开启 socket 信号驱动 IO 功能，并通过系统调用 <code>sigaction</code> 执行一个信号处理函数（非阻塞，立即返回）。当数据就绪时，会为该进程生成一个 SIGIO 信号，通过信号回调通知应用程序调用 <code>recvfrom</code> 来读取数据，并通知主循环喊出处理数据，流程如下图所示。</p>
<p><img src="./2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/4.png"></p>
<h4 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h4><p>告知内核启动某个事件，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通过我们，流程如下图所示。</p>
<p><img src="./2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/5.png"></p>
<p>与信号驱动模式的主要区别是：</p>
<ul>
<li>信号驱动 IO 由内核通知我们何时可以开始一个 IO 操作；</li>
<li>异步 IO 操作由内核通知我们 IO 何时完成。</li>
</ul>
<p>内核是通过向应用程序发送 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉用户 read 操作已经完成，在 Linux 中，通知的方式是信号：</p>
<ol>
<li>当进程正处于用户态时，应用需要立马进行处理，一般情况下，是先将事件登记一下，放进一个队列中；</li>
<li>当进程正处于内核态时，比如正在以同步阻塞模式读磁盘，那么只能先把这个通知挂起来，等内核态的事情完成之后，再触发信号通知；</li>
<li>如果这个进程现在被挂起来了，比如 sleep，那就把这个进程唤醒，等 CPU 空闲时，就会调度这个进程，触发信号通知。</li>
</ol>
<h4 id="几种-IO-模型比较"><a href="#几种-IO-模型比较" class="headerlink" title="几种 IO 模型比较"></a>几种 IO 模型比较</h4><p><img src="./2017-12-07_Unix%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E5%8F%8ALinux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/6.png"></p>
<h4 id="Linux-的-IO-多路复用模型"><a href="#Linux-的-IO-多路复用模型" class="headerlink" title="Linux 的 IO 多路复用模型"></a>Linux 的 IO 多路复用模型</h4><p>IO 多路复用通过把多个 IO 阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下，可以同时处理多个 client 请求，与传统的多线程/多进程模型相比，IO 多路复用的最大优势是系统开销小，系统不需要创建新的额外的进程或线程，也不需要维护这些进程和线程的运行，节省了系统资源，IO 多路复用的主要场景如下：</p>
<ol>
<li>Server 需要同时处理多个处于监听状态或者连接状态的 socket；</li>
<li>Server 需要同时处理多种网络协议的 socket。</li>
</ol>
<p>IO 多路复用实际上就是通过一种机制，一个进程可以监视多个描 fd，一旦某个 fd 就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，目前支持 IO 多路复用的系统有 select、pselect、poll、epoll，但它们本质上都是同步 IO。</p>
<p>在 Linux 网络编程中，最初是选用 select 做轮询和网络事件通知，然而 select 的一些固有缺陷导致了它的应用受到了很大的限制，最终 Linux 选择 epoll。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 函数监视的 fd 分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后select 函数会阻塞，直到有 fd 就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当select函数返回后，可以通过遍历 fdset，来找到就绪的 fd。</p>
<p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一个最大的缺陷就是单个进程对打开的 fd 是有一定限制的，它由 FD_SETSIZE 限制，默认值是1024，如果修改的话，就需要重新编译内核，不过这会带来网络效率的下降。</p>
<p>select 和 poll 另一个缺陷就是随着 fd 数目的增加，可能只有很少一部分 socket 是活跃的，但是 select/poll 每次调用时都会线性扫描全部的集合，导致效率呈现线性的下降。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有 fd 后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历 fd。这个过程经历了多次无谓的遍历。</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样以下两个缺点：</p>
<ol>
<li>大量的 fd 的数组被整体复制于用户态和内核地址空间之间；</li>
<li>poll 还有一个特点是【水平触发】，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd；</li>
<li>fd 增加时，线性扫描导致性能下降。</li>
</ol>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll 支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些 fd 变为就绪态，并且只会通知一次。还有一个特点是，epoll 使用【事件】的就绪通知方式，通过 epoll_ctl 注册 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd，epoll_wait 便可以收到通知。</p>
<p>epoll的优点：</p>
<ol>
<li>没有最大并发连接的限制，它支持的 fd 上限受操作系统最大文件句柄数；</li>
<li>效率提升，不是轮询的方式，不会随着 fd 数目的增加效率下降。epoll 只会对【活跃】的 socket 进行操作，这是因为在内核实现中 epoll 是根据每个 fd 上面的 callback 函数实现的，只有【活跃】的 socket 才会主动的去调用 callback 函数，其他 idle 状态的 socket 则不会。epoll 的性能不会受 fd 总数的限制。</li>
<li>select/poll 都需要内核把 fd 消息通知给用户空间，而 epoll 是通过内核和用户空间 mmap 同一块内存实现。</li>
</ol>
<p>epoll 对 fd 的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件，下次调用 epoll_wait 时，会再次响应应用程序并通知此事件；</li>
<li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件，如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h4 id="三种模型的区别"><a href="#三种模型的区别" class="headerlink" title="三种模型的区别"></a>三种模型的区别</h4><table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">select</th>
<th align="left">poll</th>
<th align="left">epoll</th>
</tr>
</thead>
<tbody><tr>
<td align="left">支持的最大连接数</td>
<td align="left">由 FD_SETSIZE 限制</td>
<td align="left">基于链表存储，没有限制</td>
<td align="left">受系统最大句柄数限制</td>
</tr>
<tr>
<td align="left">fd 剧增的影响</td>
<td align="left">线性扫描 fd 导致性能很低</td>
<td align="left">同 select</td>
<td align="left">基于 fd 上 callback 实现，没有性能下降的问题</td>
</tr>
<tr>
<td align="left">消息传递机制</td>
<td align="left">内核需要将消息传递到用户空间，需要内核拷贝</td>
<td align="left">同 select</td>
<td align="left">epoll 通过内核与用户空间共享内存来实现</td>
</tr>
</tbody></table>
<p>介绍完 IO 多路复用之后，后续我们看一下 Java 网络编程中的 NIO 模型及其背后的实现机制。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li>  《Netty 权威指南》</li>
<li>  <a target="_blank" rel="noopener" href="http://www.cnblogs.com/Anker/p/3269106.html">用户空间与内核空间，进程上下文与中断上下文【总结】</a></li>
<li>  <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/486b0965c296">聊聊 Linux 中的五种 IO 模型</a></li>
<li>  <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></li>
<li>  <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2461535c38f3">高性能Server—Reactor模型</a></li>
</ul>
<p>原文：<a target="_blank" rel="noopener" href="http://matt33.com/2017/08/06/unix-io/">http://matt33.com/2017/08/06/unix-io/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
