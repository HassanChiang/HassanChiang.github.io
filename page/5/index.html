<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="分享之">
<meta property="og:url" content="https://blog.fenxiangz.com/page/5/index.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="Share everything">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="JAVA,Linux,技术分享,网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.fenxiangz.com/page/5/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2019-05-04_java_labmda.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/advance/2019-05-04_java_labmda.html" class="post-title-link" itemprop="url">Java8新特性学习-函数式编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-04T00:00:00+00:00">2019-05-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java8 新引入函数式编程方式，大大的提高了编码效率。本文将对涉及的对象等进行统一的学习及记录。内容包括：Stream/Function/Optional/Consumer。</p>
<p>首先需要清楚一个概念：函数式接口；它指的是有且只有一个未实现的方法的接口，一般通过 FunctionalInterface 这个注解来表明某个接口是一个函数式接口。函数式接口是 Java 支持函数式编程的基础。</p>
<p>本文目录：</p>
<ul>
<li><p><a href="#1-java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8">1 Java8 函数式编程语法入门</a></p>
</li>
<li><p><a href="#2-java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">2 Java 函数式接口</a></p>
</li>
<li><p><a href="#2-1-consumer">2.1 Consumer</a></p>
</li>
<li><p><a href="#2-2-function">2.2 Function</a></p>
</li>
<li><p><a href="#2-3-predicate">2.3 Predicate</a></p>
</li>
<li><p><a href="#3-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8">3 函数式编程接口的使用</a></p>
</li>
<li><p><a href="#3-1-stream">3.1 Stream</a></p>
</li>
<li><p><a href="#3-1-1-stream-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">3.1.1 Stream 对象的创建</a></p>
</li>
<li><p><a href="#3-1-2-stream-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8">3.1.2 Stream 对象的使用</a></p>
</li>
<li><p><a href="#3-1-2-1-filter">3.1.2.1 filter</a></p>
</li>
<li><p><a href="#3-1-2-2-map">3.1.2.2 map</a></p>
</li>
<li><p><a href="#3-1-2-3-flatmap">3.1.2.3 flatMap</a></p>
</li>
<li><p><a href="#3-1-2-4-takewhile">3.1.2.4 takeWhile</a></p>
</li>
<li><p><a href="#3-1-2-5-dropwhile">3.1.2.5 dropWhile</a></p>
</li>
<li><p><a href="#3-1-2-6-reduce-%E4%B8%8E-collect">3.1.2.6 reduce 与 collect</a></p>
</li>
<li><p><a href="#3-2-optional">3.2 Optional</a></p>
</li>
<li><p><a href="#3-2-1-optional%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA">3.2.1 Optional 对象创建</a></p>
</li>
<li><p><a href="#3-2-1-1-empty">3.2.1.1 empty</a></p>
</li>
<li><p><a href="#3-2-1-2-of">3.2.1.2 of</a></p>
</li>
<li><p><a href="#3-2-1-3-ofnullable">3.2.1.3 ofNullable</a></p>
</li>
<li><p><a href="#3-2-2-%E6%96%B9%E6%B3%95">3.2.2 方法</a></p>
</li>
<li><p><a href="#3-2-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3.2.3 使用场景</a></p>
</li>
<li><p><a href="#3-2-3-1-%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%BA%E7%A9%BA%E5%90%8E%E4%BD%BF%E7%94%A8">3.2.3.1 判断结果不为空后使用</a></p>
</li>
<li><p><a href="#3-2-3-2-%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA%E6%97%B6%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E5%80%BC">3.2.3.2 变量为空时提供默认值</a></p>
</li>
<li><p><a href="#3-2-3-3-%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA%E6%97%B6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-%E5%90%A6%E5%88%99%E4%BD%BF%E7%94%A8">3.2.3.3 变量为空时抛出异常,否则使用</a></p>
</li>
</ul>
<h1 id="1-Java8-函数式编程语法入门"><a href="#1-Java8-函数式编程语法入门" class="headerlink" title="1 Java8 函数式编程语法入门"></a>1 Java8 函数式编程语法入门</h1><p>Java8 中函数式编程语法能够精简代码。 </p>
<p>使用 Consumer 作为示例，它是一个函数式接口，包含一个抽象方法 accept，这个方法只有输入而无输出。 </p>
<p>现在我们要定义一个 Consumer 对象，传统的方式是这样定义的：</p>
<pre><code>Consumer c = new Consumer() &#123;
    @Overridepublicvoidaccept(Object o) &#123;
        System.out.println(o);
    &#125;
&#125;;</code></pre>
<p>而在 Java8 中，针对函数式编程接口，可以这样定义：</p>
<pre><code>Consumer c = (o) -&gt; &#123;
    System.out.println(o);
&#125;;  </code></pre>
<p>上面已说明，函数式编程接口都只有一个抽象方法，因此在采用这种写法时，编译器会将这段函数编译后当作该抽象方法的实现。 </p>
<p>如果接口有多个抽象方法，编译器就不知道这段函数应该是实现哪个方法的了。 </p>
<p>因此，= 后面的函数体我们就可以看成是 accept 函数的实现。</p>
<ul>
<li>输入：-&gt;前面的部分，即被 () 包围的部分。此处只有一个输入参数，实际上输入是可以有多个的，如两个参数时写法：(a, b); 当然也可以没有输入，此时直接就可以是()。  </li>
<li>函数体：-&gt;后面的部分，即被 {} 包围的部分；可以是一段代码。</li>
<li>输出：函数式编程可以没有返回值，也可以有返回值。如果有返回值时，需要代码段的最后一句通过 return 的方式返回对应的值。</li>
</ul>
<p>当函数体中只有一个语句时，可以去掉 {} 进一步简化：</p>
<pre><code>Consumer c = (o) -&gt; System.out.println(o);</code></pre>
<p>然而这还不是最简的，由于此处只是进行打印，调用了 System.out 中的 println 静态方法对输入参数直接进行打印，因此可以简化成以下写法：</p>
<pre><code>Consumer c = System.out::println;</code></pre>
<p>它表示的意思就是针对输入的参数将其调用 System.out 中的静态方法 println 进行打印。 </p>
<p>到这一步就可以感受到函数式编程的强大能力。 </p>
<p>通过最后一段代码，我们可以简单的理解函数式编程，Consumer 接口直接就可以当成一个函数了，这个函数接收一个输入参数，然后针对这个输入进行处理；当然其本质上仍旧是一个对象，但我们已经省去了诸如老方式中的对象定义过程，直接使用一段代码来给函数式接口对象赋值。 </p>
<p>而且最为关键的是，这个函数式对象因为本质上仍旧是一个对象，因此可以做为其它方法的参数或者返回值，可以与原有的代码实现无缝集成！</p>
<p>下面对 Java 中的几个预先定义的函数式接口及其经常使用的类进行分析学习。</p>
<h1 id="2-Java-函数式接口"><a href="#2-Java-函数式接口" class="headerlink" title="2 Java 函数式接口"></a>2 Java 函数式接口</h1><h2 id="2-1-Consumer"><a href="#2-1-Consumer" class="headerlink" title="2.1 Consumer"></a>2.1 Consumer</h2><p>Consumer 是一个函数式编程接口； 顾名思义，Consumer 的意思就是消费，即针对某个东西我们来使用它，因此它包含有一个有输入而无输出的 accept 接口方法；  </p>
<p>除 accept 方法，它还包含有 andThen 这个方法； </p>
<p>其定义如下：</p>
<pre><code>default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;
    Objects.requireNonNull(after);
    return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;
&#125;</code></pre>
<p>可见这个方法就是指定在调用当前 Consumer 后是否还要调用其它的 Consumer；  </p>
<p>使用示例：</p>
<pre><code>publicstaticvoidconsumerTest() &#123;
    Consumer f = System.out::println;
    Consumer f2 = n -&gt; System.out.println(n + &quot;-F2&quot;);

    //执行完F后再执行F2的Accept方法
    f.andThen(f2).accept(&quot;test&quot;);

    //连续执行F的Accept方法
    f.andThen(f).andThen(f).andThen(f).accept(&quot;test1&quot;);
&#125;</code></pre>
<h2 id="2-2-Function"><a href="#2-2-Function" class="headerlink" title="2.2 Function"></a>2.2 Function</h2><p>Function 也是一个函数式编程接口；它代表的含义是 “函数”，而函数经常是有输入输出的，因此它含有一个 apply 方法，包含一个输入与一个输出；  </p>
<p>除 apply 方法外，它还有 compose 与 andThen 及 indentity 三个方法，其使用见下述示例；</p>
<pre><code>/**
 * Function测试
 */publicstaticvoidfunctionTest() &#123;
    Function&lt;Integer, Integer&gt; f = s -&gt; s++;
    Function&lt;Integer, Integer&gt; g = s -&gt; s * 2;

    /**
     * 下面表示在执行F时，先执行G，并且执行F时使用G的输出当作输入。
     * 相当于以下代码：
     * Integer a = g.apply(1);
     * System.out.println(f.apply(a));
     */
    System.out.println(f.compose(g).apply(1));

    /**
     * 表示执行F的Apply后使用其返回的值当作输入再执行G的Apply；
     * 相当于以下代码
     * Integer a = f.apply(1);
     * System.out.println(g.apply(a));
     */
    System.out.println(f.andThen(g).apply(1));

    /**
     * identity方法会返回一个不进行任何处理的Function，即输出与输入值相等； 
     */
    System.out.println(Function.identity().apply(&quot;a&quot;));
&#125;</code></pre>
<h2 id="2-3-Predicate"><a href="#2-3-Predicate" class="headerlink" title="2.3 Predicate"></a>2.3 Predicate</h2><p>Predicate 为函数式接口，predicate 的中文意思是 “断定”，即判断的意思，判断某个东西是否满足某种条件； 因此它包含 test 方法，根据输入值来做逻辑判断，其结果为 True 或者 False。 </p>
<p>它的使用方法示例如下：</p>
<pre><code>/**
 * Predicate测试
 */privatestaticvoidpredicateTest() &#123;
    Predicate&lt;String&gt; p = o -&gt; o.equals(&quot;test&quot;);
    Predicate&lt;String&gt; g = o -&gt; o.startsWith(&quot;t&quot;);

    /**
     * negate: 用于对原来的Predicate做取反处理；
     * 如当调用p.test(&quot;test&quot;)为True时，调用p.negate().test(&quot;test&quot;)就会是False；
     */
    Assert.assertFalse(p.negate().test(&quot;test&quot;));

    /**
     * and: 针对同一输入值，多个Predicate均返回True时返回True，否则返回False；
     */
    Assert.assertTrue(p.and(g).test(&quot;test&quot;));

    /**
     * or: 针对同一输入值，多个Predicate只要有一个返回True则返回True，否则返回False
     */
    Assert.assertTrue(p.or(g).test(&quot;ta&quot;));
&#125;</code></pre>
<h1 id="3-函数式编程接口的使用"><a href="#3-函数式编程接口的使用" class="headerlink" title="3 函数式编程接口的使用"></a>3 函数式编程接口的使用</h1><p>通过 Stream 以及 Optional 两个类，可以进一步利用函数式接口来简化代码。</p>
<h2 id="3-1-Stream"><a href="#3-1-Stream" class="headerlink" title="3.1 Stream"></a>3.1 Stream</h2><p>Stream 可以对多个元素进行一系列的操作，也可以支持对某些操作进行并发处理。</p>
<h3 id="3-1-1-Stream-对象的创建"><a href="#3-1-1-Stream-对象的创建" class="headerlink" title="3.1.1 Stream 对象的创建"></a>3.1.1 Stream 对象的创建</h3><p>Stream 对象的创建途径有以下几种</p>
<p>a. 创建空的 Stream 对象</p>
<pre><code>Stream stream = Stream.empty();</code></pre>
<p>b. 通过集合类中的 stream 或者 parallelStream 方法创建； </p>
<pre><code>List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
Stream listStream = list.stream();                   //获取串行的Stream对象
Stream parallelListStream = list.parallelStream();   //获取并行的Stream对象  </code></pre>
<p>c. 通过 Stream 中的 of 方法创建：</p>
<pre><code>Stream s = Stream.of(&quot;test&quot;);
Stream s1 = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</code></pre>
<p>d. 通过 Stream 中的 iterate 方法创建： </p>
<p>iterate 方法有两个不同参数的方法：</p>
<pre><code>publicstatic&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f);  
publicstatic&lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</code></pre>
<p>其中第一个方法将会返回一个无限有序值的 Stream 对象：它的第一个元素是 seed，第二个元素是 f.apply(seed); 第 N 个元素是 f.apply(n-1 个元素的值)；生成无限值的方法实际上与 Stream 的中间方法类似，在遇到中止方法前一般是不真正的执行的。因此无限值的这个方法一般与 limit 等方法一起使用，来获取前多少个元素。 </p>
<p>当然获取前多少个元素也可以使用第二个方法。  </p>
<p>第二个方法与第一个方法生成元素的方式类似，不同的是它返回的是一个有限值的 Stream；中止条件是由 hasNext 来断定的。  </p>
<p>第二种方法的使用示例如下： </p>
<pre><code>/**
 * 本示例表示从1开始组装一个序列，第一个是1，第二个是1+1即2，第三个是2+1即3..，直接10时中止；
 * 也可简化成以下形式：
 *        Stream.iterate(1,
 *        n -&gt; n &lt;= 10,
 *        n -&gt; n+1).forEach(System.out::println);
 * 写成以下方式是为简化理解
 */
Stream.iterate(1,
        new Predicate&lt;Integer&gt;() &#123;
            @Overridepublicbooleantest(Integer integer) &#123;
                return integer &lt;= 10;
            &#125;
        &#125;,
    new UnaryOperator&lt;Integer&gt;() &#123;
        @Overridepublic Integer apply(Integer integer) &#123;
            return integer+1;
        &#125;
&#125;).forEach(System.out::println);</code></pre>
<p>e. 通过 Stream 中的 generate 方法创建  </p>
<p>与 iterate 中创建无限元素的 Stream 类似，不过它的每个元素与前一元素无关，且生成的是一个无序的队列。也就是说每一个元素都可以随机生成。因此一般用来创建常量的 Stream 以及随机的 Stream 等。  </p>
<p>示例如下：</p>
<pre><code>/**
 * 随机生成10个Double元素的Stream并将其打印
 */
Stream.generate(new Supplier&lt;Double&gt;() &#123;
    @Overridepublic Double get() &#123;
        return Math.random();
    &#125;
&#125;).limit(10).forEach(System.out::println);

//上述写法可以简化成以下写法：
Stream.generate(() -&gt; Math.random()).limit(10).forEach(System.out::println);</code></pre>
<p>f. 通过 Stream 中的 concat 方法连接两个 Stream 对象生成新的 Stream 对象 </p>
<p>这个比较好理解不再赘述。  </p>
<h3 id="3-1-2-Stream-对象的使用"><a href="#3-1-2-Stream-对象的使用" class="headerlink" title="3.1.2 Stream 对象的使用"></a>3.1.2 Stream 对象的使用</h3><p>Stream 对象提供多个非常有用的方法，这些方法可以分成两类：  </p>
<p>中间操作：将原始的 Stream 转换成另外一个 Stream；如 filter 返回的是过滤后的 Stream。 </p>
<p>终端操作：产生的是一个结果或者其它的复合操作；如 count 或者 forEach 操作。</p>
<p>其清单如下所示，方法的具体说明及使用示例见后文。 </p>
<p>所有中间操作</p>
<p>方法说明sequential返回一个相等的串行的 Stream 对象，如果原 Stream 对象已经是串行就可能会返回原对象parallel返回一个相等的并行的 Stream 对象，如果原 Stream 对象已经是并行的就会返回原对象unordered返回一个不关心顺序的 Stream 对象，如果原对象已经是这类型的对象就会返回原对象onClose返回一个相等的 Steam 对象，同时新的 Stream 对象在执行 Close 方法时会调用传入的 Runnable 对象close关闭 Stream 对象filter元素过滤：对 Stream 对象按指定的 Predicate 进行过滤，返回的 Stream 对象中仅包含未被过滤的元素map元素一对一转换：使用传入的 Function 对象对 Stream 中的所有元素进行处理，返回的 Stream 对象中的元素为原元素处理后的结果mapToInt元素一对一转换：将原 Stream 中的使用传入的 IntFunction 加工后返回一个 IntStream 对象flatMap元素一对多转换：对原 Stream 中的所有元素进行操作，每个元素会有一个或者多个结果，然后将返回的所有元素组合成一个统一的 Stream 并返回；distinct去重：返回一个去重后的 Stream 对象sorted排序：返回排序后的 Stream 对象peek使用传入的 Consumer 对象对所有元素进行消费后，返回一个新的包含所有原来元素的 Stream 对象limit获取有限个元素组成新的 Stream 对象返回skip抛弃前指定个元素后使用剩下的元素组成新的 Stream 返回takeWhile如果 Stream 是有序的（Ordered），那么返回最长命中序列（符合传入的 Predicate 的最长命中序列）组成的 Stream；如果是无序的，那么返回的是所有符合传入的 Predicate 的元素序列组成的 Stream。dropWhile与 takeWhile 相反，如果是有序的，返回除最长命中序列外的所有元素组成的 Stream；如果是无序的，返回所有未命中的元素组成的 Stream。</p>
<p>所有终端操作</p>
<p>方法说明iterator返回 Stream 中所有对象的迭代器;spliterator返回对所有对象进行的 spliterator 对象forEach对所有元素进行迭代处理，无返回值forEachOrdered按 Stream 的 Encounter 所决定的序列进行迭代处理，无返回值toArray返回所有元素的数组reduce使用一个初始化的值，与 Stream 中的元素一一做传入的二合运算后返回最终的值。每与一个元素做运算后的结果，再与下一个元素做运算。它不保证会按序列执行整个过程。collect根据传入参数做相关汇聚计算min返回所有元素中最小值的 Optional 对象；如果 Stream 中无任何元素，那么返回的 Optional 对象为 Emptymax与 Min 相反count所有元素个数anyMatch只要其中有一个元素满足传入的 Predicate 时返回 True，否则返回 FalseallMatch所有元素均满足传入的 Predicate 时返回 True，否则 FalsenoneMatch所有元素均不满足传入的 Predicate 时返回 True，否则 FalsefindFirst返回第一个元素的 Optioanl 对象；如果无元素返回的是空的 Optional； 如果 Stream 是无序的，那么任何元素都可能被返回。findAny返回任意一个元素的 Optional 对象，如果无元素返回的是空的 Optioanl。isParallel判断是否当前 Stream 对象是并行的</p>
<p>下面就几个比较常用的方法举例说明其用法： </p>
<h4 id="3-1-2-1-filter"><a href="#3-1-2-1-filter" class="headerlink" title="3.1.2.1 filter"></a>3.1.2.1 filter</h4><p>用于对 Stream 中的元素进行过滤，返回一个过滤后的 Stream </p>
<p>其方法定义如下： </p>
<pre><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></pre>
<p>使用示例：</p>
<pre><code>Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;);
//查找所有包含t的元素并进行打印
s.filter(n -&gt; n.contains(&quot;t&quot;)).forEach(System.out::println);</code></pre>
<h4 id="3-1-2-2-map"><a href="#3-1-2-2-map" class="headerlink" title="3.1.2.2 map"></a>3.1.2.2 map</h4><p>元素一对一转换。 </p>
<p>它接收一个 Funcation 参数，用其对 Stream 中的所有元素进行处理，返回的 Stream 对象中的元素为 Function 对原元素处理后的结果 </p>
<p>其方法定义如下：</p>
<pre><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></pre>
<p>示例，假设我们要将一个 String 类型的 Stream 对象中的每个元素添加相同的后缀. txt，如 a 变成 a.txt，其写法如下： </p>
<pre><code>Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;);
s.map(n -&gt; n.concat(&quot;.txt&quot;)).forEach(System.out::println);</code></pre>
<h4 id="3-1-2-3-flatMap"><a href="#3-1-2-3-flatMap" class="headerlink" title="3.1.2.3 flatMap"></a>3.1.2.3 flatMap</h4><p>元素一对多转换：对原 Stream 中的所有元素使用传入的 Function 进行处理，每个元素经过处理后生成一个多个元素的 Stream 对象，然后将返回的所有 Stream 对象中的所有元素组合成一个统一的 Stream 并返回； </p>
<p>方法定义如下：</p>
<pre><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</code></pre>
<p>示例，假设要对一个 String 类型的 Stream 进行处理，将每一个元素的拆分成单个字母，并打印： </p>
<pre><code>Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;);
s.flatMap(n -&gt; Stream.of(n.split(&quot;&quot;))).forEach(System.out::println);</code></pre>
<h4 id="3-1-2-4-takeWhile"><a href="#3-1-2-4-takeWhile" class="headerlink" title="3.1.2.4 takeWhile"></a>3.1.2.4 takeWhile</h4><p>方法定义如下： </p>
<pre><code>default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</code></pre>
<p>如果 Stream 是有序的（Ordered），那么返回最长命中序列（符合传入的 Predicate 的最长命中序列）组成的 Stream；如果是无序的，那么返回的是所有符合传入的 Predicate 的元素序列组成的 Stream。 </p>
<p>与 Filter 有点类似，不同的地方就在当 Stream 是有序时，返回的只是最长命中序列。 </p>
<p>如以下示例，通过 takeWhile 查找”test”, “t1”, “t2”, “teeeee”, “aaaa”, “taaa” 这几个元素中包含 t 的最长命中序列： </p>
<pre><code>Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;, &quot;taaa&quot;);
//以下结果将打印： &quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;，最后的那个taaa不会进行打印 
s.takeWhile(n -&gt; n.contains(&quot;t&quot;)).forEach(System.out::println);</code></pre>
<h4 id="3-1-2-5-dropWhile"><a href="#3-1-2-5-dropWhile" class="headerlink" title="3.1.2.5 dropWhile"></a>3.1.2.5 dropWhile</h4><p>与 takeWhile 相反，如果是有序的，返回除最长命中序列外的所有元素组成的 Stream；如果是无序的，返回所有未命中的元素组成的 Stream; 其定义如下：</p>
<pre><code>default Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</code></pre>
<p>如以下示例，通过 dropWhile 删除”test”, “t1”, “t2”, “teeeee”, “aaaa”, “taaa” 这几个元素中包含 t 的最长命中序列：</p>
<pre><code>Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;, &quot;taaa&quot;);
//以下结果将打印：&quot;aaaa&quot;, &quot;taaa&quot; 　
s.dropWhile(n -&gt; n.contains(&quot;t&quot;)).forEach(System.out::println);</code></pre>
<h4 id="3-1-2-6-reduce-与-collect"><a href="#3-1-2-6-reduce-与-collect" class="headerlink" title="3.1.2.6 reduce 与 collect"></a>3.1.2.6 reduce 与 collect</h4><p>关于 reduce 与 collect 由于功能较为复杂，在后续将进行单独分析与学习，此处暂不涉及。</p>
<h2 id="3-2-Optional"><a href="#3-2-Optional" class="headerlink" title="3.2 Optional"></a>3.2 Optional</h2><p>用于简化 Java 中对空值的判断处理，以防止出现各种空指针异常。 </p>
<p>Optional 实际上是对一个变量进行封装，它包含有一个属性 value，实际上就是这个变量的值。</p>
<h3 id="3-2-1-Optional-对象创建"><a href="#3-2-1-Optional-对象创建" class="headerlink" title="3.2.1 Optional 对象创建"></a>3.2.1 Optional 对象创建</h3><p>它的构造函数都是 private 类型的，因此要初始化一个 Optional 的对象无法通过其构造函数进行创建。它提供了一系列的静态方法用于构建 Optional 对象:</p>
<h4 id="3-2-1-1-empty"><a href="#3-2-1-1-empty" class="headerlink" title="3.2.1.1 empty"></a>3.2.1.1 empty</h4><p>用于创建一个空的 Optional 对象；其 value 属性为 Null。 </p>
<p>如：</p>
<pre><code>Optional o = Optional.empty();</code></pre>
<h4 id="3-2-1-2-of"><a href="#3-2-1-2-of" class="headerlink" title="3.2.1.2 of"></a>3.2.1.2 of</h4><p>根据传入的值构建一个 Optional 对象;  </p>
<p>传入的值必须是非空值，否则如果传入的值为空值，则会抛出空指针异常。 </p>
<p>使用：</p>
<pre><code>o = Optional.of(&quot;test&quot;); </code></pre>
<h4 id="3-2-1-3-ofNullable"><a href="#3-2-1-3-ofNullable" class="headerlink" title="3.2.1.3 ofNullable"></a>3.2.1.3 ofNullable</h4><p>根据传入值构建一个 Optional 对象  </p>
<p>传入的值可以是空值，如果传入的值是空值，则与 empty 返回的结果是一样的。  </p>
<h3 id="3-2-2-方法"><a href="#3-2-2-方法" class="headerlink" title="3.2.2 方法"></a>3.2.2 方法</h3><p>Optional 包含以下方法：</p>
<p>方法名说明get获取 Value 的值，如果 Value 值是空值，则会抛出 NoSuchElementException 异常；因此返回的 Value 值无需再做空值判断，只要没有抛出异常，都会是非空值。isPresentValue 是否为空值的判断；ifPresent当 Value 不为空时，执行传入的 Consumer；ifPresentOrElseValue 不为空时，执行传入的 Consumer；否则执行传入的 Runnable 对象；filter当 Value 为空或者传入的 Predicate 对象调用 test(value) 返回 False 时，返回 Empty 对象；否则返回当前的 Optional 对象map一对一转换：当 Value 为空时返回 Empty 对象，否则返回传入的 Function 执行 apply(value) 后的结果组装的 Optional 对象；flatMap一对多转换：当 Value 为空时返回 Empty 对象，否则传入的 Function 执行 apply(value) 后返回的结果（其返回结果直接是 Optional 对象）or如果 Value 不为空，则返回当前的 Optional 对象；否则，返回传入的 Supplier 生成的 Optional 对象；stream如果 Value 为空，返回 Stream 对象的 Empty 值；否则返回 Stream.of(value) 的 Stream 对象；orElseValue 不为空则返回 Value，否则返回传入的值；orElseGetValue 不为空则返回 Value，否则返回传入的 Supplier 生成的值；orElseThrowValue 不为空则返回 Value，否则抛出 Supplier 中生成的异常对象；</p>
<h3 id="3-2-3-使用场景"><a href="#3-2-3-使用场景" class="headerlink" title="3.2.3 使用场景"></a>3.2.3 使用场景</h3><p>常用的使用场景如下：</p>
<h4 id="3-2-3-1-判断结果不为空后使用"><a href="#3-2-3-1-判断结果不为空后使用" class="headerlink" title="3.2.3.1 判断结果不为空后使用"></a>3.2.3.1 判断结果不为空后使用</h4><p>如某个函数可能会返回空值，以往的做法：</p>
<pre><code>String s = test();
if (null != s) &#123;
    System.out.println(s);
&#125;</code></pre>
<p>现在的写法就可以是：</p>
<pre><code>Optional&lt;String&gt; s = Optional.ofNullable(test());
s.ifPresent(System.out::println);</code></pre>
<p>乍一看代码复杂度上差不多甚至是略有提升；那为什么要这么做呢？ </p>
<p>一般情况下，我们在使用某一个函数返回值时，要做的第一步就是去分析这个函数是否会返回空值；如果没有进行分析或者分析的结果出现偏差，导致函数会抛出空值而没有做检测，那么就会相应的抛出空指针异常！ </p>
<p>而有了 Optional 后，在我们不确定时就可以不用去做这个检测了，所有的检测 Optional 对象都帮忙我们完成，我们要做的就是按上述方式去处理。</p>
<h4 id="3-2-3-2-变量为空时提供默认值"><a href="#3-2-3-2-变量为空时提供默认值" class="headerlink" title="3.2.3.2 变量为空时提供默认值"></a>3.2.3.2 变量为空时提供默认值</h4><p>如要判断某个变量为空时使用提供的值，然后再针对这个变量做某种运算；  </p>
<p>以往做法：</p>
<pre><code>if (null == s) &#123;
    s = &quot;test&quot;;
&#125;
System.out.println(s);</code></pre>
<p>现在的做法：</p>
<pre><code>Optional&lt;String&gt; o = Optional.ofNullable(s);
System.out.println(o.orElse(&quot;test&quot;));</code></pre>
<h4 id="3-2-3-3-变量为空时抛出异常，否则使用"><a href="#3-2-3-3-变量为空时抛出异常，否则使用" class="headerlink" title="3.2.3.3 变量为空时抛出异常，否则使用"></a>3.2.3.3 变量为空时抛出异常，否则使用</h4><p>以往写法：</p>
<pre><code>if (null == s) &#123;
    thrownew Exception(&quot;test&quot;);
&#125;
System.out.println(s);</code></pre>
<p>现在写法：</p>
<pre><code>Optional&lt;String&gt; o = Optional.ofNullable(s);
System.out.println(o.orElseThrow(()-&gt;new Exception(&quot;test&quot;)));</code></pre>
<p>其它场景待补充。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/icarusliu/article/details/79495534">https://blog.csdn.net/icarusliu/article/details/79495534</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/nio/2019-04-07_java_nio_debug.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/nio/2019-04-07_java_nio_debug.html" class="post-title-link" itemprop="url">Java NIO客户端主动关闭连接，导致服务器空轮询</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-07T00:00:00+00:00">2019-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-NIO/" itemprop="url" rel="index"><span itemprop="name">Java NIO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>当客户端连接关闭时，服务器select()不会阻塞，然后一直分发读就绪操作，且读到的字节长度都是0，这是什么情况。</p>
<p>服务器代码:</p>
<pre><code>try &#123;
    ServerSocketChannel serverChannel = ServerSocketChannel.open();
    serverChannel.bind(new InetSocketAddress(666));
    serverChannel.configureBlocking(false);
    Selector selector = Selector.open();
    serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    while (true) &#123;
        int count = selector.select(); //阻塞
        if (count &gt; 0) &#123;
            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();
            while (iterator.hasNext()) &#123;
                SelectionKey key = iterator.next();
                iterator.remove();
                if (key.isAcceptable()) &#123;
                    System.out.println(&quot;client connect&quot;);
                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                    SocketChannel sc = serverSocketChannel.accept();
                    sc.configureBlocking(false);
                    sc.register(selector, SelectionKey.OP_READ);
                &#125;
                if (key.isReadable()) &#123;
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(512);
                    socketChannel.read(buffer);
                    buffer.flip();
                    System.out.println(&quot;on read size:&quot; + buffer.remaining());
                &#125;
            &#125;
        &#125;
    &#125;
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre>
<p>客户端代码：</p>
<pre><code>public class NIOClientTest&#123;
    public static void main(String[] args) throws UnknownHostException, IOException&#123;
        try &#123;
            Socket socket = new Socket(&quot;127.0.0.1&quot;,666);
            try(OutputStreamWriter output = new OutputStreamWriter(socket.getOutputStream());)&#123;
                output.write(1);
                output.flush();
            &#125;catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
            socket.close();
        &#125; catch (Exception e1) &#123;
            e1.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>解决：</p>
<hr>
<p>当客户端主动切断连接的时候，服务端 Socket 的读事件（FD_READ）仍然起作用，也就是说，服务端 Socket 的状态仍然是有东西可读，当然此时读出来的字节肯定是 0。</p>
<p>socketChannel.read(buffer) 是有返回值的，这种情况下返回值是 -1，所以如果 read 方法返回的是 -1，就可以关闭和这个客户端的连接了。</p>
<p>SocketChannel.read 的返回值：<br><img src="./2019-04-07_java_nio_debug/1.png"> </p>
<p>这种情况也有可能会抛出 IOException，需要捕获异常并判断。</p>
<hr>
<p>nio的客户端如果关闭了，服务端还是会收到该channel的读事件，但是数目为0，而且会读到-1，其实-1在网络io中就是socket关闭的含义，在文件时末尾的含义，所以为了避免客户端关闭服务端一直收到读事件，必须检测上一次的读是不是-1，如果是-1，就关闭这个channel。</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(100);
SocketChannel sc = (SocketChannel) key.channel();
StringBuffer buf = new StringBuffer();
int c = 0;
while ((c = sc.read(buffer)) &gt; 0) &#123;
    buf.append(new String(buffer.array()));
&#125;
if (c == -1) &#123;
    System.out.println(&quot;断开&quot;);
    sc.close();
&#125;
String msg = buf.toString();
System.out.println(msg);</code></pre>
<hr>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/nio/2019-04-07_java_nio_%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/nio/2019-04-07_java_nio_%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9.html" class="post-title-link" itemprop="url">NIO 各种使用注意点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-07T00:00:00+00:00">2019-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-NIO/" itemprop="url" rel="index"><span itemprop="name">Java NIO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>找问题的时后发现了这篇文章，惊为天人，几乎涵盖了我所有碰到的坑，非常不错！</p>
<p>不得不说，NIO的API设计的够难用的，坑还巨多….这也是为什么大家都不直接使用nio的原因吧，一般会用mina或者netty啥的（这是个记录的博客，所以会不断更新）</p>
<p>关于通道本身的一些注意点，请参考我之前的：<a target="_blank" rel="noopener" href="http://www.360doc.com/content/12/0822/00/495229_231622420.shtml">nio通道(2)—几个注意点</a></p>
<p>其他一些参考<a target="_blank" rel="noopener" href="http://www.dazhuangzhuang.com/?p=144">nio summary</a></p>
<h1 id="1-坑爹的事件"><a href="#1-坑爹的事件" class="headerlink" title="1 坑爹的事件"></a>1 坑爹的事件</h1><p>SocetChannel和ServerSocketChannel各自支持的事件，在前面已经提到：</p>
<p><a target="_blank" rel="noopener" href="http://www.360doc.com/content/12/0902/17/495229_233773276.shtml">http://www.360doc.com/content/12/0902/17/495229_233773276.shtml</a></p>
<h2 id="1-1-什么时候可以register"><a href="#1-1-什么时候可以register" class="headerlink" title="1.1 什么时候可以register"></a>1.1 什么时候可以register</h2><p><strong>客户端：</strong><br>linux:SocketChannel: 注册了op_read,op_write,op_connect的SocketChannel<strong>在connect之前，open之后，都可以select到，只不过不能够read和write</strong><br>windows:SocketChannel:只有注册了op_connect的SocketChannel<strong>在connect之后，才被select到。是一个正确的符合逻辑的理解</strong>。</p>
<p><strong>服务器端：</strong></p>
<p>(2)如果只注册了读的操作，则select时，会发生阻塞，因为是没有为读准备好的socket<br>(3)如果没有可写的socket，则select时，不会发生阻塞，直接返回0。如果阻塞写，只能是发送区满。</p>
<p>另外：iterator到selectedKey之后，需要将该key移除出selectedKey。如果不移出，例如OP_ACCEPT，则再下次accept之后，会产生空的SocketChannel。</p>
<h2 id="1-2-connect事件（连接–成功or失败？）"><a href="#1-2-connect事件（连接–成功or失败？）" class="headerlink" title="1.2 connect事件（连接–成功or失败？）"></a>1.2 connect事件（连接–成功or失败？）</h2><p>在之前的Socket通道中，已经看到，非阻塞模式下，connect操作会返回false，后面会发出CONNECT事件来表示连接，但是这里其实没有区分成功还是失败。。</p>
<p>connect事件：表示连接通道连接就绪或者发生了错误，会被加到ready 集合中（下面面是API说明）</p>
<p>If the selector detects that the corresponding socket channel is ready to complete its connection sequence, or has an error pending, then it will add OP_CONNECT to the key’s ready set and add the key to its selected-key set.</p>
<p>所以这个事件发生的时候不能简单呢的认为连接成功，要使用finishConnect判断下，如果连接失败，会抛出异常</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhl_cn/article/details/6568893">NIO就绪处理之OP_CONNECT</a></p>
<pre><code>if (key.isValid() &amp;&amp; key.isConnectable()) &#123;
    SocketChannel ch = (SocketChannel) key.channel();
    if (ch.finishConnect()) &#123;
        // Connect successfully
        // key.interestOps(SelectionKey.OP_READ);
    &#125; else &#123;
        // Connect failed
    &#125;
&#125;</code></pre>
<h2 id="1-3-read-amp-关闭"><a href="#1-3-read-amp-关闭" class="headerlink" title="1.3 read&amp;关闭"></a>1.3 read&amp;关闭</h2><p>一直很奇怪，为啥没有close事件，终于在一次实验的时候发现：</p>
<p>1.启动一个客户端和服务端</p>
<p>2.关闭客户端，服务端会发生一个read事件，并且在read的时候抛出异常，来表示关闭</p>
<p><img src="https://pocket-image-cache.com/direct?url=http://userimage3.360doc.com/12/0902/22/495229_201209022226160388.jpg&resize=w640"></p>
<p>另外，这个事件会不断发生，就算从已准备好的集合移除也没有，必须将该channel关闭或者调用哪个该key的cancel方法，因为<strong>SelectionKey代表的是Selector和Channel之间的联系，所以在Channel关闭了之后，对于Selector来说，这个Channel永远都会发出关闭这个事件，表明自己关闭了，直到从该Selector移除去</strong></p>
<p>3.服务端关闭，client端在write的时候会抛出异常</p>
<p>java.io.IOException: 远程主机强迫关闭了一个现有的连接。</p>
<p> at sun.nio.ch.SocketDispatcher.write0(Native Method)</p>
<p> at sun.nio.ch.SocketDispatcher.write(Unknown Source)</p>
<h2 id="1-4-还是关闭-TIME-WAIT"><a href="#1-4-还是关闭-TIME-WAIT" class="headerlink" title="1.4 还是关闭(TIME_WAIT)"></a>1.4 还是关闭(TIME_WAIT)</h2><p><a target="_blank" rel="noopener" href="http://dennis-zane.iteye.com/blog/204969">NIO的SelectableChannel关闭的一个问题</a></p>
<p>如果在取消SelectionKey（这时候只是加入取消的键集合，下一次select才会执行）后没有调用到selector的select方法（因为Client一般在取消key后，我们都会终止调用select的循环，当然，server关闭一个注册的channel我们是不会终止select循环的），那么本地socket将进入CLOSE-WAIT状态（等待本地Socket关闭）。简单的解决办法是在 SelectableChannel.close方法之后调用Selector.selectNow方法</p>
<p><strong>Netty在超过256连接关闭的时候主动调用一次selectNow</strong></p>
<h2 id="1-5-write"><a href="#1-5-write" class="headerlink" title="1.5 write"></a>1.5 write</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhl_cn/article/details/6582435">NIO就绪处理之OP_WRITE</a></p>
<p>一开始很多人以为write事件，表示在调用channel的write方法之后，就会发生这个事件，然后channel再会把数据真正写出，但是实际上，<strong>写操作的就绪条件为底层缓冲区有空闲空间，而写缓冲区绝大部分时间都是有空闲空间的，所以当你注册写事件后，写操作一直是就绪的，选择处理线程全占用整个CPU资源。所以，只有当你确实有数据要写时再注册写操作，并在写完以后马上取消注册，</strong>一般的，Client端需要注册OP_CONNECT,OP_READ;Server端需要注册OP_ACCEPT并且连接之后注册OP_READ</p>
<p>当有数据在写时，将数据写到缓冲区中，并注册写事件。</p>
<p>[java]<a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhl_cn/article/details/6582435#">view plain</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhl_cn/article/details/6582435#">copy</a></p>
<pre><code>public void write(byte\[\] data) throws IOException &#123;
     writeBuffer.put(data);
     key.interestOps(SelectionKey.OP_WRITE);
&#125;</code></pre>
<p>注册写事件后，写操作就绪，这时将之前写入缓冲区的数据写入通道，并取消注册。[java]<a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhl_cn/article/details/6582435#">view plain</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhl_cn/article/details/6582435#">copy</a></p>
<p>大部分情况下，其实直接用write方法写就好了，没必要用写事件。</p>
<p>另外，关于write还可以参考下面的4.2的一些注意点</p>
<h1 id="2-Channel的bind方法"><a href="#2-Channel的bind方法" class="headerlink" title="2 Channel的bind方法"></a>2 Channel的bind方法</h1><p><strong>Socket/ServerSocket</strong></p>
<p>两者都有bind方法，表示绑定到某个端口，在绑定之后，<strong>前者调用connect方法，表示连接到某个服务端；后者要在后面调用accept方法，监听到来的连接请求（一个Socket句柄包含了两个地址对，本地ip:port—-远程ip:port）</strong></p>
<h1 id="3-Selector的select和wakeup机制"><a href="#3-Selector的select和wakeup机制" class="headerlink" title="3 Selector的select和wakeup机制"></a>3 Selector的select和wakeup机制</h1><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/haoel/article/details/2224055">Java NIO类库Selector机制解析（上）</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/haoel/article/details/2224069">Java NIO类库Selector机制解析（下）</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/haoel/article/details/2379586">Java NIO 类库Selector机制解析（续）</a></p>
<p>在windows平台下，调用Selector.open()方法，会自己和自己建立两条TCP连接，消耗了两个TCP连接和端口，也消耗了文件描述符</p>
<p>在linux平台下，会自己和自己建立两条管道，消耗了两个系统的文件描述符</p>
<p><img src="https://pocket-image-cache.com/direct?url=http://userimage3.360doc.com/12/0902/22/495229_201209022226160919.jpg&resize=w640"></p>
<p>一个阻塞seelct上的线程想要被唤醒，有3种方式：</p>
<p>1.有数据可读/.可写，或者出现异常</p>
<p>2.阻塞时间到，time out</p>
<p><strong>3.收到一个non-block信号，由kill或者pthread_kill发出</strong></p>
<p>这两个方法完全是来模仿Linux中的的kill和pthread_kill给阻塞在select上的线程发信号的。但因为发信号这个东西并不是一个跨平台的标准（pthread_kill这个系统调用也不是所有Unix/Linux都支持的），而pipe是所有的Unix/Linux所支持的，但Windows又不支持，所以，Windows用了TCP连接来实现这个事。(<strong>在Linux下使用pipe管道</strong>)</p>
<h1 id="4-一些特殊情况"><a href="#4-一些特殊情况" class="headerlink" title="4 一些特殊情况"></a>4 一些特殊情况</h1><h2 id="4-1-读不满"><a href="#4-1-读不满" class="headerlink" title="4.1 读不满"></a>4.1 读不满</h2><p>因为我们的数据都是偏业务性的，比如使用开头一个字节来表示后面数据的长度，接着就会等待读取到那么多数据，但是TCP是流式的协议，100字节的数据可能是一段段发送过来的，所以在没有读到完整的数据前需要等待。</p>
<p>这时候可以将buffer attach到key上，下次read发生的时候再继续读取，但是也有另外一种说法，在网络条件比较好的情况下，直接使用一个临时selector会减少上下文切换。。这个不太明白</p>
<h2 id="4-2-写不出去"><a href="#4-2-写不出去" class="headerlink" title="4.2 写不出去"></a>4.2 写不出去</h2><p>在发送缓冲区空间不够的情况下，write方法可能会返回能够写出去的字节数，比如只剩50字节，你写入100字节，这时候write会返回50，即往缓冲区写入了50字节</p>
<p>在网络较好的情况下，这应该是不太可能发生的，一般都是网络有问题，重传率很高</p>
<p>详细的情况可以参考：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_783ede0301013g5n.html">java nio对OP_WRITE的处理解决网速慢的连接</a></p>
<pre><code>    while (bb.hasRemaining()) &#123;
        int len = socketChannel.write(bb);
        if (len &lt; 0) &#123;
            throw new EOFException();
        &#125;
    &#125;</code></pre>
<p>由于缓冲区一直蛮，下面的代码会一直执行，占用CPU100%，因此推荐的方式如下</p>
<pre><code>while (bb.hasRemaining()) &#123;
    int len = socketChannel.write(bb);
    if (len &lt; 0) &#123;
        throw new EOFException();
    &#125;
    if (len == 0) &#123;
        selectionKey.interestOps(
                selectionKey.interestOps() | SelectionKey.OP_WRITE);
        mainSelector.wakeup();
        break;
    &#125;
&#125;</code></pre>
<p>如果返回0，表示缓冲区满，那么注册WRITE事件，缓冲区不满的情况下，就会触发WRITE事件，在那时候再写入，可以避免不要的消耗。（另外Grizzly还是用了另一种方式，也可以从上面的参考链接得到）</p>
<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/asdasdasd123123123/article/details/88253912">https://blog.csdn.net/asdasdasd123123123/article/details/88253912</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/netty/2019-03-26_%E5%9F%BA%E4%BA%8ENetty%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/netty/2019-03-26_%E5%9F%BA%E4%BA%8ENetty%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6.html" class="post-title-link" itemprop="url">基于Netty自己动手实现RPC框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-26T00:00:00+00:00">2019-03-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天我们要来做一道小菜，这道菜就是RPC通讯框架。它使用netty作为原料，fastjson序列化工具作为调料，来实现一个极简的多线程RPC服务框架。</p>
<p>我们暂且命名该RPC框架为rpckids。</p>
<p><img src="./2019-03-26_%E5%9F%BA%E4%BA%8ENetty%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6/1.png"></p>
<h1 id="食用指南"><a href="#食用指南" class="headerlink" title="食用指南"></a>食用指南</h1><p>在告诉读者完整的制作菜谱之前，我们先来试试这个小菜怎么个吃法，好不好吃，是不是吃起来很方便。如果读者觉得很难吃，那后面的菜谱就没有多大意义了，何必花心思去学习制作一门谁也不爱吃的大烂菜呢？</p>
<p>例子中我会使用rpckids提供的远程RPC服务，用于计算斐波那契数和指数，客户端通过rpckids提供的RPC客户端向远程服务传送参数，并接受返回结果，然后呈现出来。你可以使用rpckids定制任意的业务rpc服务。</p>
<p><img src="./2019-03-26_%E5%9F%BA%E4%BA%8ENetty%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6/2.png"></p>
<p>斐波那契数输入输出比较简单，一个Integer，一个Long。 指数输入有两个值，输出除了计算结果外还包含计算耗时，以纳秒计算。之所以包含耗时，只是为了呈现一个完整的自定义的输入和输出类。</p>
<h2 id="指数服务自定义输入输出类"><a href="#指数服务自定义输入输出类" class="headerlink" title="指数服务自定义输入输出类"></a>指数服务自定义输入输出类</h2><pre><code>// 指数RPC的输入
public class ExpRequest &#123;
        private int base;
        private int exp;

    // constructor &amp; getter &amp; setter
&#125;

// 指数RPC的输出
public class ExpResponse &#123;

        private long value;
        private long costInNanos;

        // constructor &amp; getter &amp; setter
&#125;</code></pre>
<h2 id="斐波那契和指数计算处理"><a href="#斐波那契和指数计算处理" class="headerlink" title="斐波那契和指数计算处理"></a>斐波那契和指数计算处理</h2><pre><code>public class FibRequestHandler implements IMessageHandler&lt;Integer&gt; &#123;

        private List&lt;Long&gt; fibs = new ArrayList&lt;&gt;();

        &#123;
                fibs.add(1L); // fib(0) = 1
                fibs.add(1L); // fib(1) = 1
        &#125;

        @Override
        public void handle(ChannelHandlerContext ctx, String requestId, Integer n) &#123;
                for (int i = fibs.size(); i &lt; n + 1; i++) &#123;
                        long value = fibs.get(i - 2) + fibs.get(i - 1);
                        fibs.add(value);
                &#125;
                // 输出响应
                ctx.writeAndFlush(new MessageOutput(requestId, &quot;fib_res&quot;, fibs.get(n)));
        &#125;

&#125;

public class ExpRequestHandler implements IMessageHandler&lt;ExpRequest&gt; &#123;

        @Override
        public void handle(ChannelHandlerContext ctx, String requestId, ExpRequest message) &#123;
                int base = message.getBase();
                int exp = message.getExp();
                long start = System.nanoTime();
                long res = 1;
                for (int i = 0; i &lt; exp; i++) &#123;
                        res *= base;
                &#125;
                long cost = System.nanoTime() - start;
                // 输出响应
                ctx.writeAndFlush(new MessageOutput(requestId, &quot;exp_res&quot;, new ExpResponse(res, cost)));
        &#125;

&#125;</code></pre>
<h2 id="构建RPC服务器"><a href="#构建RPC服务器" class="headerlink" title="构建RPC服务器"></a>构建RPC服务器</h2><p>RPC服务类要监听指定IP端口，设定io线程数和业务计算线程数，然后注册斐波那契服务输入类和指数服务输入类，还有相应的计算处理器。</p>
<pre><code>public class DemoServer &#123;

        public static void main(String[] args) &#123;
                RPCServer server = new RPCServer(&quot;localhost&quot;, 8888, 2, 16);
                server.service(&quot;fib&quot;, Integer.class, new FibRequestHandler())
                          .service(&quot;exp&quot;, ExpRequest.class, new ExpRequestHandler());
                server.start();
        &#125;

&#125;</code></pre>
<h2 id="构建RPC客户端"><a href="#构建RPC客户端" class="headerlink" title="构建RPC客户端"></a>构建RPC客户端</h2><p>RPC客户端要链接远程IP端口，并注册服务输出类(RPC响应类)，然后分别调用20次斐波那契服务和指数服务，输出结果</p>
<pre><code>public class DemoClient &#123;

        private RPCClient client;

        public DemoClient(RPCClient client) &#123;
                this.client = client;
                // 注册服务返回类型
                this.client.rpc(&quot;fib_res&quot;, Long.class).rpc(&quot;exp_res&quot;, ExpResponse.class);
        &#125;

        public long fib(int n) &#123;
                return (Long) client.send(&quot;fib&quot;, n);
        &#125;

        public ExpResponse exp(int base, int exp) &#123;
                return (ExpResponse) client.send(&quot;exp&quot;, new ExpRequest(base, exp));
        &#125;

        public static void main(String[] args) &#123;
                RPCClient client = new RPCClient(&quot;localhost&quot;, 8888);
                DemoClient demo = new DemoClient(client);
                for (int i = 0; i &lt; 20; i++) &#123;
                        System.out.printf(&quot;fib(%d) = %d\n&quot;, i, demo.fib(i));
                &#125;
                for (int i = 0; i &lt; 20; i++) &#123;
                        ExpResponse res = demo.exp(2, i);
                        System.out.printf(&quot;exp2(%d) = %d cost=%dns\n&quot;, i, res.getValue(), res.getCostInNanos());
                &#125;
        &#125;

&#125;</code></pre>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先运行服务器，服务器输出如下，从日志中可以看到客户端链接过来了，然后发送了一系列消息，最后关闭链接走了。</p>
<pre><code>server started @ localhost:8888
connection comes
read a message
read a message
...
connection leaves</code></pre>
<p>再运行客户端，可以看到一些列的计算结果都成功完成了输出。</p>
<pre><code>fib(0) = 1
fib(1) = 1
fib(2) = 2
fib(3) = 3
fib(4) = 5
...
exp2(0) = 1 cost=559ns
exp2(1) = 2 cost=495ns
exp2(2) = 4 cost=524ns
exp2(3) = 8 cost=640ns
exp2(4) = 16 cost=711ns
...</code></pre>
<h1 id="牢骚"><a href="#牢骚" class="headerlink" title="牢骚"></a>牢骚</h1><p>本以为是小菜一碟，但是编写完整的代码和文章却将近花费了一天的时间，深感写码要比做菜耗时太多了。因为只是为了教学目的，所以在实现细节上还有好多没有仔细去雕琢的地方。如果是要做一个开源项目，力求非常完美的话。至少还要考虑一下几点。</p>
<ol>
<li> 客户端连接池</li>
<li> 多服务进程负载均衡</li>
<li> 日志输出</li>
<li> 参数校验，异常处理</li>
<li> 客户端流量攻击</li>
<li> 服务器压力极限</li>
</ol>
<p>如果要参考grpc的话，还得实现流式响应处理。如果还要为了节省网络流量的话，又需要在协议上下功夫。这一大堆的问题还是抛给读者自己思考去吧。</p>
<p>关注公众号「<strong>码洞</strong>」，发送「RPC」即可获取以上完整菜谱的GitHub开源代码链接。读者有什么不明白的地方，洞主也会一一解答。</p>
<p>下面我们接着讲RPC服务器和客户端精细的制作过程</p>
<h1 id="服务器菜谱"><a href="#服务器菜谱" class="headerlink" title="服务器菜谱"></a>服务器菜谱</h1><p>定义消息输入输出格式，消息类型、消息唯一ID和消息的json序列化字符串内容。消息唯一ID是用来客户端验证服务器请求和响应是否匹配。</p>
<pre><code>public class MessageInput &#123;
        private String type;
        private String requestId;
        private String payload;

        public MessageInput(String type, String requestId, String payload) &#123;
                this.type = type;
                this.requestId = requestId;
                this.payload = payload;
        &#125;

        public String getType() &#123;
                return type;
        &#125;

        public String getRequestId() &#123;
                return requestId;
        &#125;

    // 因为我们想直接拿到对象，所以要提供对象的类型参数
        public &lt;T&gt; T getPayload(Class&lt;T&gt; clazz) &#123;
                if (payload == null) &#123;
                        return null;
                &#125;
                return JSON.parseObject(payload, clazz);
        &#125;

&#125;

public class MessageOutput &#123;

        private String requestId;
        private String type;
        private Object payload;

        public MessageOutput(String requestId, String type, Object payload) &#123;
                this.requestId = requestId;
                this.type = type;
                this.payload = payload;
        &#125;

        public String getType() &#123;
                return this.type;
        &#125;

        public String getRequestId() &#123;
                return requestId;
        &#125;

        public Object getPayload() &#123;
                return payload;
        &#125;

&#125;</code></pre>
<p>消息解码器，使用Netty的ReplayingDecoder实现。简单起见，这里没有使用checkpoint去优化性能了，感兴趣的话读者可以参考一下我之前在公众号里发表的相关文章，将checkpoint相关的逻辑自己添加进去。</p>
<pre><code>public class MessageDecoder extends ReplayingDecoder&lt;MessageInput&gt; &#123;

        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
                String requestId = readStr(in);
                String type = readStr(in);
                String content = readStr(in);
                out.add(new MessageInput(type, requestId, content));
        &#125;

        private String readStr(ByteBuf in) &#123;
                // 字符串先长度后字节数组，统一UTF8编码
                int len = in.readInt();
                if (len &lt; 0 || len &gt; (1 &lt;&lt; 20)) &#123;
                        throw new DecoderException(&quot;string too long len=&quot; + len);
                &#125;
                byte[] bytes = new byte[len];
                in.readBytes(bytes);
                return new String(bytes, Charsets.UTF8);
        &#125;

&#125;</code></pre>
<p>消息处理器接口，每个自定义服务必须实现handle方法</p>
<pre><code>public interface IMessageHandler&lt;&gt; &#123;

        Tvoid handle(ChannelHandlerContext ctx, String requestId, T message);

&#125;

// 找不到类型的消息统一使用默认处理器处理
public class DefaultHandler implements IMessageHandler&lt;MessageInput&gt; &#123;

        @Override
        public void handle(ChannelHandlerContext ctx, String requesetId, MessageInput input) &#123;
                System.out.println(&quot;unrecognized message type=&quot; + input.getType() + &quot; comes&quot;);
        &#125;

&#125;</code></pre>
<p>消息类型注册中心和消息处理器注册中心，都是用静态字段和方法，其实也是为了图方便，写成非静态的可能会优雅一些。</p>
<pre><code>public class MessageRegistry &#123;
        private static Map&lt;String, Class&lt;?&gt;&gt; clazzes = new HashMap&lt;&gt;();

        public static void register(String type, Class&lt;?&gt; clazz) &#123;
                clazzes.put(type, clazz);
        &#125;

        public static Class&lt;?&gt; get(String type) &#123;
                return clazzes.get(type);
        &#125;
&#125;

public class MessageHandlers &#123;

        private static Map&lt;String, IMessageHandler&lt;?&gt;&gt; handlers = new HashMap&lt;&gt;();
        public static DefaultHandler defaultHandler = new DefaultHandler();

        public static void register(String type, IMessageHandler&lt;?&gt; handler) &#123;
                handlers.put(type, handler);
        &#125;

        public static IMessageHandler&lt;?&gt; get(String type) &#123;
                IMessageHandler&lt;?&gt; handler = handlers.get(type);
                return handler;
        &#125;

&#125;</code></pre>
<p>响应消息的编码器比较简单</p>
<pre><code>@Sharable
public class MessageEncoder extends MessageToMessageEncoder&lt;MessageOutput&gt; &#123;

        @Override
        protected void encode(ChannelHandlerContext ctx, MessageOutput msg, List&lt;Object&gt; out) throws Exception &#123;
                ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer();
                writeStr(buf, msg.getRequestId());
                writeStr(buf, msg.getType());
                writeStr(buf, JSON.toJSONString(msg.getPayload()));
                out.add(buf);
        &#125;

        private void writeStr(ByteBuf buf, String s) &#123;
                buf.writeInt(s.length());
                buf.writeBytes(s.getBytes(Charsets.UTF8));
        &#125;

&#125;</code></pre>
<p>好，接下来进入关键环节，将上面的小模小块凑在一起，构建一个完整的RPC服务器框架，这里就需要读者有必须的Netty基础知识了，需要编写Netty的事件回调类和服务构建类。</p>
<pre><code>@Sharable
public class MessageCollector extends ChannelInboundHandlerAdapter &#123;
    // 业务线程池
        private ThreadPoolExecutor executor;

        public MessageCollector(int workerThreads) &#123;
                // 业务队列最大1000，避免堆积
                // 如果子线程处理不过来，io线程也会加入处理业务逻辑(callerRunsPolicy)
                BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(1000);
                // 给业务线程命名
                ThreadFactory factory = new ThreadFactory() &#123;

                        AtomicInteger seq = new AtomicInteger();

                        @Override
                        public Thread newThread(Runnable r) &#123;
                                Thread t = new Thread(r);
                                t.setName(&quot;rpc-&quot; + seq.getAndIncrement());
                                return t;
                        &#125;

                &#125;;
                // 闲置时间超过30秒的线程自动销毁
                this.executor = new ThreadPoolExecutor(1, workerThreads, 30, TimeUnit.SECONDS, queue, factory,
                                new CallerRunsPolicy());
        &#125;

        public void closeGracefully() &#123;
                // 优雅一点关闭，先通知，再等待，最后强制关闭
                this.executor.shutdown();
                try &#123;
                        this.executor.awaitTermination(10, TimeUnit.SECONDS);
                &#125; catch (InterruptedException e) &#123;
                &#125;
                this.executor.shutdownNow();
        &#125;

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                // 客户端来了一个新链接
                System.out.println(&quot;connection comes&quot;);
        &#125;

        @Override
        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
                // 客户端走了一个
                System.out.println(&quot;connection leaves&quot;);
                ctx.close();
        &#125;

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                if (msg instanceof MessageInput) &#123;
                        System.out.println(&quot;read a message&quot;);
                        // 用业务线程池处理消息
                        this.executor.execute(() -&gt; &#123;
                                this.handleMessage(ctx, (MessageInput) msg);
                        &#125;);
                &#125;
        &#125;

        private void handleMessage(ChannelHandlerContext ctx, MessageInput input) &#123;
                // 业务逻辑在这里
                Class&lt;?&gt; clazz = MessageRegistry.get(input.getType());
                if (clazz == null) &#123;
                        // 没注册的消息用默认的处理器处理
                        MessageHandlers.defaultHandler.handle(ctx, input.getRequestId(), input);
                        return;
                &#125;
                Object o = input.getPayload(clazz);
                // 这里是小鲜的瑕疵，代码外观上比较难看，但是大厨表示才艺不够，很无奈
                // 读者如果感兴趣可以自己想办法解决
                @SuppressWarnings(&quot;unchecked&quot;)
                IMessageHandler&lt;Object&gt; handler = (IMessageHandler&lt;Object&gt;) MessageHandlers.get(input.getType());
                if (handler != null) &#123;
                        handler.handle(ctx, input.getRequestId(), o);
                &#125; else &#123;
                        // 用默认的处理器处理吧
                        MessageHandlers.defaultHandler.handle(ctx, input.getRequestId(), input);
                &#125;
        &#125;

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
                // 此处可能因为客户端机器突发重启
                // 也可能是客户端链接闲置时间超时，后面的ReadTimeoutHandler抛出来的异常
                // 也可能是消息协议错误，序列化异常
                // etc.
                // 不管它，链接统统关闭，反正客户端具备重连机制
                System.out.println(&quot;connection error&quot;);
                cause.printStackTrace();
                ctx.close();
        &#125;

&#125;

public class RPCServer &#123;

        private String ip;
        private int port;
        private int ioThreads; // 用来处理网络流的读写线程
        private int workerThreads; // 用于业务处理的计算线程

        public RPCServer(String ip, int port, int ioThreads, int workerThreads) &#123;
                this.ip = ip;
                this.port = port;
                this.ioThreads = ioThreads;
                this.workerThreads = workerThreads;
        &#125;

        private ServerBootstrap bootstrap;
        private EventLoopGroup group;
        private MessageCollector collector;
        private Channel serverChannel;

    // 注册服务的快捷方式
        public RPCServer service(String type, Class&lt;?&gt; reqClass, IMessageHandler&lt;?&gt; handler) &#123;
                MessageRegistry.register(type, reqClass);
                MessageHandlers.register(type, handler);
                return this;
        &#125;

    // 启动RPC服务
        public void start() &#123;
                bootstrap = new ServerBootstrap();
                group = new NioEventLoopGroup(ioThreads);
                bootstrap.group(group);
                collector = new MessageCollector(workerThreads);
                MessageEncoder encoder = new MessageEncoder();
                bootstrap.channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception &#123;
                                ChannelPipeline pipe = ch.pipeline();
                                // 如果客户端60秒没有任何请求，就关闭客户端链接
                                pipe.addLast(new ReadTimeoutHandler(60));
                                // 挂上解码器
                                pipe.addLast(new MessageDecoder());
                                // 挂上编码器
                                pipe.addLast(encoder);
                                // 将业务处理器放在最后
                                pipe.addLast(collector);
                        &#125;
                &#125;);
                bootstrap.option(ChannelOption.SO_BACKLOG, 100)  // 客户端套件字接受队列大小
                         .option(ChannelOption.SO_REUSEADDR, true) // reuse addr，避免端口冲突
                         .option(ChannelOption.TCP_NODELAY, true) // 关闭小流合并，保证消息的及时性
                         .childOption(ChannelOption.SO_KEEPALIVE, true); // 长时间没动静的链接自动关闭
                serverChannel = bootstrap.bind(this.ip, this.port).channel();
                System.out.printf(&quot;server started @ %s:%d\n&quot;, ip, port);
        &#125;

        public void stop() &#123;
                // 先关闭服务端套件字
                serverChannel.close();
                // 再斩断消息来源，停止io线程池
                group.shutdownGracefully();
                // 最后停止业务线程
                collector.closeGracefully();
        &#125;

&#125;</code></pre>
<p>上面就是完整的服务器菜谱，代码较多，读者如果没有Netty基础的话，可能会看得眼花缭乱。如果你不常使用JDK的Executors框架，阅读起来估计也够呛。如果读者需要相关学习资料，可以找我索取。</p>
<h1 id="客户端菜谱"><a href="#客户端菜谱" class="headerlink" title="客户端菜谱"></a>客户端菜谱</h1><p>服务器使用NIO实现，客户端也可以使用NIO实现，不过必要性不大，用同步的socket实现也是没有问题的。更重要的是，同步的代码比较简短，便于理解。所以简单起见，这里使用了同步IO。</p>
<p>定义RPC请求对象和响应对象，和服务器一一对应。</p>
<pre><code>public class RPCRequest &#123;

        private String requestId;
        private String type;
        private Object payload;

        public RPCRequest(String requestId, String type, Object payload) &#123;
                this.requestId = requestId;
                this.type = type;
                this.payload = payload;
        &#125;

        public String getRequestId() &#123;
                return requestId;
        &#125;

        public String getType() &#123;
                return type;
        &#125;

        public Object getPayload() &#123;
                return payload;
        &#125;

&#125;

public class RPCResponse &#123;

        private String requestId;
        private String type;
        private Object payload;

        public RPCResponse(String requestId, String type, Object payload) &#123;
                this.requestId = requestId;
                this.type = type;
                this.payload = payload;
        &#125;

        public String getRequestId() &#123;
                return requestId;
        &#125;

        public void setRequestId(String requestId) &#123;
                this.requestId = requestId;
        &#125;

        public String getType() &#123;
                return type;
        &#125;

        public void setType(String type) &#123;
                this.type = type;
        &#125;

        public Object getPayload() &#123;
                return payload;
        &#125;

        public void setPayload(Object payload) &#123;
                this.payload = payload;
        &#125;

&#125;</code></pre>
<p>定义客户端异常，用于统一抛出RPC错误</p>
<pre><code>public class RPCException extends RuntimeException &#123;

        private static final long serialVersionUID = 1L;

        public RPCException(String message, Throwable cause) &#123;
                super(message, cause);
        &#125;

        public RPCException(String message) &#123;
                super(message);
        &#125;

        public RPCException(Throwable cause) &#123;
                super(cause);
        &#125;

&#125;</code></pre>
<p>请求ID生成器，简单的UUID64</p>
<pre><code>public class RequestId &#123;

        public static String next() &#123;
                return UUID.randomUUID().toString();
        &#125;

&#125;</code></pre>
<p>响应类型注册中心，和服务器对应</p>
<pre><code>public class ResponseRegistry &#123;
        private static Map&lt;String, Class&lt;?&gt;&gt; clazzes = new HashMap&lt;&gt;();

        public static void register(String type, Class&lt;?&gt; clazz) &#123;
                clazzes.put(type, clazz);
        &#125;

        public static Class&lt;?&gt; get(String type) &#123;
                return clazzes.get(type);
        &#125;
&#125;</code></pre>
<p>好，接下来进入客户端的关键环节，链接管理、读写消息、链接重连都在这里</p>
<pre><code>public class RPCClient &#123;

        private String ip;
        private int port;
        private Socket sock;
        private DataInputStream input;
        private OutputStream output;

        public RPCClient(String ip, int port) &#123;
                this.ip = ip;
                this.port = port;
        &#125;

        public void connect() throws IOException &#123;
                SocketAddress addr = new InetSocketAddress(ip, port);
                sock = new Socket();
                sock.connect(addr, 5000); // 5s超时
                input = new DataInputStream(sock.getInputStream());
                output = sock.getOutputStream();
        &#125;

        public void close() &#123;
                // 关闭链接
                try &#123;
                        sock.close();
                        sock = null;
                        input = null;
                        output = null;
                &#125; catch (IOException e) &#123;
                &#125;
        &#125;

        public Object send(String type, Object payload) &#123;
                // 普通rpc请求，正常获取响应
                try &#123;
                        return this.sendInternal(type, payload, false);
                &#125; catch (IOException e) &#123;
                        throw new RPCException(e);
                &#125;
        &#125;

        public RPCClient rpc(String type, Class&lt;?&gt; clazz) &#123;
                // rpc响应类型注册快捷入口
                ResponseRegistry.register(type, clazz);
                return this;
        &#125;

        public void cast(String type, Object payload) &#123;
                // 单向消息，服务器不得返回结果
                try &#123;
                        this.sendInternal(type, payload, true);
                &#125; catch (IOException e) &#123;
                        throw new RPCException(e);
                &#125;
        &#125;

        private Object sendInternal(String type, Object payload, boolean cast) throws IOException &#123;
                if (output == null) &#123;
                        connect();
                &#125;
                String requestId = RequestId.next();
                ByteArrayOutputStream bytes = new ByteArrayOutputStream();
                DataOutputStream buf = new DataOutputStream(bytes);
                writeStr(buf, requestId);
                writeStr(buf, type);
                writeStr(buf, JSON.toJSONString(payload));
                buf.flush();
                byte[] fullLoad = bytes.toByteArray();
                try &#123;
                        // 发送请求
                        output.write(fullLoad);
                &#125; catch (IOException e) &#123;
                        // 网络异常要重连
                        close();
                        connect();
                        output.write(fullLoad);
                &#125;
                if (!cast) &#123;
                        // RPC普通请求，要立即获取响应
                        String reqId = readStr();
                        // 校验请求ID是否匹配
                        if (!requestId.equals(reqId)) &#123;
                                close();
                                throw new RPCException(&quot;request id mismatch&quot;);
                        &#125;
                        String typ = readStr();
                        Class&lt;?&gt; clazz = ResponseRegistry.get(typ);
                        // 响应类型必须提前注册
                        if (clazz == null) &#123;
                                throw new RPCException(&quot;unrecognized rpc response type=&quot; + typ);
                        &#125;
                        // 反序列化json串
                        String payld = readStr();
                        Object res = JSON.parseObject(payld, clazz);
                        return res;
                &#125;
                return null;
        &#125;

        private String readStr() throws IOException &#123;
                int len = input.readInt();
                byte[] bytes = new byte[len];
                input.readFully(bytes);
                return new String(bytes, Charsets.UTF8);
        &#125;

        private void writeStr(DataOutputStream out, String s) throws IOException &#123;
                out.writeInt(s.length());
                out.write(s.getBytes(Charsets.UTF8));
        &#125;
&#125;</code></pre>
<h1 id="牢骚重提"><a href="#牢骚重提" class="headerlink" title="牢骚重提"></a>牢骚重提</h1><p>本以为是小菜一碟，但是编写完整的代码和文章却将近花费了一天的时间，深感写码要比做菜耗时太多了。因为只是为了教学目的，所以在实现细节上还有好多没有仔细去雕琢的地方。如果是要做一个开源项目，力求非常完美的话。至少还要考虑一下几点。</p>
<ol>
<li> 客户端连接池</li>
<li> 多服务进程负载均衡</li>
<li> 日志输出</li>
<li> 参数校验，异常处理</li>
<li> 客户端流量攻击</li>
<li> 服务器压力极限</li>
</ol>
<p>如果要参考grpc的话，还得实现流式响应处理。如果还要为了节省网络流量的话，又需要在协议上下功夫。这一大堆的问题还是抛给读者自己思考去吧。</p>
<p>关注公众号「<strong>码洞</strong>」，发送「RPC」即可获取以上完整菜谱的GitHub开源代码链接。读者有什么不明白的地方，洞主也会一一解答。<br>原文：<a target="_blank" rel="noopener" href="https://juejin.im/post/5ad2a99ff265da238d51264d">https://juejin.im/post/5ad2a99ff265da238d51264d</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2019-03-06_java_os.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/advance/2019-03-06_java_os.html" class="post-title-link" itemprop="url">Java 和操作系统交互细节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+00:00">2019-03-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="结合-CPU-理解一行-Java-代码是怎么执行的"><a href="#结合-CPU-理解一行-Java-代码是怎么执行的" class="headerlink" title="结合 CPU 理解一行 Java 代码是怎么执行的"></a>结合 CPU 理解一行 Java 代码是怎么执行的</h2><p>根据冯·诺依曼思想，计算机采用二进制作为数制基础，必须包含:运算器、控制器、存储设备，以及输入输出设备，如下图所示。</p>
<p><img src="./2019-03-06_java_os/1.png"></p>
<p>(该图来源于百度)</p>
<p>我们先来分析 CPU 的工作原理，现代 CPU 芯片中大都集成了，控制单元，运算单元，存储单元。控制单元是 CPU 的控制中心， CPU 需要通过它才知道下一步做什么，也就是执行什么指令，控制单元又包含:指令寄存器( IR )，指令译码器( ID )和操作控制器( OC ).<br>当程序被加载进内存后，指令就在内存中了，这个时候说的内存是独立于 CPU 外的主存设备，也就是 PC 机中的内存条，指令指针寄存器IP 指向内存中下一条待执行指令的地址，控制单元根据 IP寄存器的指向，将主存中的指令装载到指令寄存器，这个指令寄存器也是一个存储设备，不过他集成在 CPU 内部，指令从主存到达 CPU 后只是一串 010101 的二进制串，还需要通过译码器解码，分析出<br>操作码是什么，操作数在哪，之后就是具体的运算单元进行算术运算(加减乘除)，逻辑运算(比较，位移).而 CPU 指令执行过程大致为:取址(去主存获取指令放到寄存器)，译码(从主存获取操作数放入高速缓存 L1 )，执行(运算).</p>
<p><img src="./2019-03-06_java_os/2.jpg"></p>
<blockquote>
<p>这里解释下上图中 CPU 内部集成的存储单元 SRAM ，正好和主存中的 DRAM 对应， RAM 是随机访问内存，就是给一个地址就能访问到数据，而磁盘这种存储媒介必须顺序访问，而 RAM 又分为动态和静态两种，静态 RAM 由于集成度较低，一般容量小，速度快，而动态 RAM 集成度较高，主要通过给电容充电和放电实现，速度没有静态 RAM 快，所以一般将动态 RAM 做为主存，而静态 RAM 作为 CPU 和主存之间的高速缓存(cache)，用来屏蔽 CPU 和主存速度上的差异，也就是我们经常看到的 L1 ， L2 缓存。每一级别缓存速度变低，容量变大。<br>下图展示了存储器的层次化架构，以及 CPU 访问主存的过程，这里有两个知识点，一个是多级缓存之间为保证数据的一致性，而推出的缓存一致性协议，具体可以参考这篇文章，另外一个知识点是， cache 和主存的映射，首先要明确的是 cahce 缓存的单位是缓存行，对应主存中的一个内存块，并不是一个变量，这个主要是因为 ** CPU 访问的空间局限性:被访问的某个存储单元，在一个较短时间内，很有可能再次被访问到，以及空间局限性:被访问的某个存储单元，在较短时间内，他的相邻存储单元也会被访问到。**<br>而映射方式有很多种，类似于 cache 行号 = 主存块号 mod cache总行数 ，这样每次获取到一个主存地址，根据这个地址计算出在主存中的块号就可以计算出在 cache 中的行号。</p>
</blockquote>
<p><img src="./2019-03-06_java_os/3.jpg"></p>
<p>下面我们接着聊 CPU 的指令执行。取址，译码，执行，这是一个指令的执行过程，所有指令都会严格按照这个顺序执行，但是多个指令之间其实是可以并行的，对于单核 CPU 来说，同一时刻只能有一条指令能够占有执行单元运行，这里说的执行是 CPU 指令处理(取指，译码，执行)三步骤中的第三步，也就是运算单元的计算任务，所以为了提升 CPU 的指令处理速度，所以需要保证运算单元在执行前的准备工作都完成，这样运算单元就可以一直处于运算中，而刚刚的串行流程中，取指，解码的时候运算单元是空闲的，而且取指和解码如果没有命中高速缓存还需要从主存取，而主存的速度和 CPU 不在一个级别上，所以<strong>指令流水线</strong> 可以大大提高 CPU 的处理速度，下图是一个3级流水线的示例图，而现在的奔腾 CPU 都是32级流水线，具体做法就是将上面三个流程拆分的更细。</p>
<p><img src="./2019-03-06_java_os/4.png"></p>
<p>除了指令流水线， CPU 还有分支预测，乱序执行等优化速度的手段。好了，我们回到正题，一行 Java 代码是怎么执行的。</p>
<p>一行代码能够执行，必须要有可以执行的上下文环境，包括，指令寄存器，数据寄存器，栈空间等内存资源，然后这行代码必须作为一个执行流能够被操作系统的任务调度器识别，并给他分配 CPU 资源，当然这行代码所代表的指令必须是 CPU 可以解码识别的，所以一行 Java 代码必须被解释成对应的 CPU 指令才能执行。下面我们看下System.out.println(“Hello world”)这行代码的转译过程。</p>
<p>Java 是一门高级语言，这类语言不能直接运行在硬件上，必须运行在能够识别 Java 语言特性的虚拟机上，而 Java 代码必须通过 Java 编译器将其转换成虚拟机所能识别的指令序列，也称为 Java 字节码，之所以称为字节码是因为 Java 字节码的操作指令(OpCode)被固定为一个字节，以下为 System.out.println(“Hello world”) 编译后的字节码</p>
<pre><code>0x00:  b2 00 02         getstatic  Java .lang.System.out
0x03:  12 03            ldc &quot;Hello, World!&quot;
0x05:  b6 00 04         invokevirtual  Java .io.PrintStream.println
0x08:  b1               return</code></pre>
<p>最左列是偏移；中间列是给虚拟机读的字节码；最右列是高级语言的代码，下面是通过汇编语言转换成的机器指令，中间是机器码，第三列为对应的机器指令，最后一列是对应的汇编代码</p>
<pre><code>0x00:  55                    push   rbp
0x01:  48 89 e5              mov    rbp,rsp
0x04:  48 83 ec 10           sub    rsp,0x10
0x08:  48 8d 3d 3b 00 00 00  lea    rdi,[rip+0x3b]
                                    ; 加载 &quot;Hello, World!\n&quot;
0x0f:  c7 45 fc 00 00 00 00  mov    DWORD PTR [rbp-0x4]，0x0
0x16:  b0 00                 mov    al,0x0
0x18:  e8 0d 00 00 00        call   0x12
                                    ; 调用 printf 方法
0x1d:  31 c9                 xor    ecx,ecx
0x1f:  89 45 f8              mov    DWORD PTR [rbp-0x8]，eax
0x22:  89 c8                 mov    eax,ecx
0x24:  48 83 c4 10           add    rsp,0x10
0x28:  5d                    pop    rbp
0x29:  c3                    ret</code></pre>
<p>JVM 通过类加载器加载 class 文件里的字节码后，会通过解释器解释成汇编指令，最终再转译成 CPU 可以识别的机器指令，解释器是软件来实现的，主要是为了实现同一份 Java 字节码可以在不同的硬件平台上运行，而将汇编指令转换成机器指令由硬件直接实现，这一步速度是很快的，当然 JVM 为了提高运行效率也可以将某些热点代码(一个方法内的代码)一次全部编译成机器指令后然后在执行，也就是和解释执行对应的即时编译(JIT)， JVM 启动的时候可以通过 -Xint 和 -Xcomp 来控制执行模式。</p>
<p>从软件层面上， class 文件被加载进虚拟机后，类信息会存放在方法区，在实际运行的时候会执行方法区中的代码，在 JVM 中所有的线程共享堆内存和方法区，而每个线程有自己独立的 Java 方法栈，本地方法栈(面向 native 方法)，PC寄存器(存放线程执行位置)，当调用一个方法的时候， Java 虚拟机会在当前线程对应的方法栈中压入一个栈帧，用来存放 Java 字节码操作数以及局部变量，这个方法执行完会弹出栈帧，一个线程会连续执行多个方法，对应不同的栈帧的压入和弹出，压入栈帧后就是 JVM 解释执行的过程了。</p>
<p><img src="./2019-03-06_java_os/5.jpg"></p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>刚刚说到， CPU 只要一上电就像一个永动机， 不停的取指令，运算，周而复始，而中断便是操作系统的灵魂，故名思议，中断就是打断 CPU 的执行过程，转而去做点别的，例如系统执行期间发生了致命错误，需要结束执行，例如用户程序调用了一个系统调用的方法，例如mmp等，就会通过中断让 CPU 切换上下文，转到内核空间，例如一个等待用户输入的程序正在阻塞，而当用户通过键盘完成输入，内核数据已经准备好后，就会发一个中断信号，唤醒用户程序把数据从内核取走，不然内核可能会数据溢出，当磁盘报了一个致命异常，也会通过中断通知 CPU ，定时器完成时钟滴答也会发时钟中断通知 CPU .</p>
<p>中断的种类，我们这里就不做细分了，中断有点类似于我们经常说的事件驱动编程，而这个事件通知机制是怎么实现的呢，硬件中断的实现通过一个导线和 CPU 相连来传输中断信号，软件上会有特定的指令，例如执行系统调用创建线程的指令，而 CPU 每执行完一个指令，就会检查中断寄存器中是否有中断，如果有就取出然后执行该中断对应的处理程序。</p>
<blockquote>
<p>陷入内核 : 我们在设计软件的时候，会考虑程序上下文切换的频率，频率太高肯定会影响程序执行性能，而陷入内核是针对 CPU 而言的， CPU 的执行从用户态转向内核态，以前是用户程序在使用 CPU ，现在是内核程序在使用 CPU ，这种切换是通过系统调用产生的，系统调用是执行操作系统底层的程序，Linux的设计者，为了保护操作系统，将进程的执行状态用内核态和用户态分开，同一个进程中，内核和用户共享同一个地址空间，一般 4G 的虚拟地址，其中 1G 给内核态， 3G 给用户态。在程序设计的时候我们要尽量减少用户态到内核态的切换，例如创建线程是一个系统调用，所以我们有了线程池的实现。</p>
</blockquote>
<h2 id="从-Linux-内存管理角度理解-JVM-内存模型"><a href="#从-Linux-内存管理角度理解-JVM-内存模型" class="headerlink" title="从 Linux 内存管理角度理解 JVM 内存模型"></a>从 Linux 内存管理角度理解 JVM 内存模型</h2><h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p>我们可以将程序理解为一段可执行的指令集合，而这个程序启动后，操作系统就会为他分配 CPU ，内存等资源，而这个正在运行的程序就是我们说的进程，进程是操作系统对处理器中运行的程序的一种抽象，而为进程分配的内存以及 CPU 资源就是这个进程的上下文，保存了当前执行的指令，以及变量值，而 JVM 启动后也是linux上的一个普通进程，进程的物理实体和支持进程运行的环境合称为上下文，而上下文切换就是将当前正在运行的进程换下，换一个新的进程到处理器运行，以此来让多个进程并发的执行，上下文切换可能来自操作系统调度，也有可能来自程序内部，例如读取IO的时候，会让用户代码和操作系统代码之间进行切换。</p>
<p><img src="./2019-03-06_java_os/6.jpg"></p>
<h4 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h4><p>当我们同时启动多个 JVM 执行: System.out.println(new Object()); 将会打印这个对象的 hashcode ，hashcode 默认为内存地址，最后发现他们打印的都是 Java .lang.Object@4fca772d ，也就是多个进程返回的内存地址竟然是一样的。</p>
<p>通过上面的例子我们可以证明，linux中每个进程有单独的地址空间，在此之前，我们先了解下 CPU 是如何访问内存的?</p>
<p>假设我们现在还没有虚拟地址，只有物理地址，编译器在编译程序的时候，需要将高级语言转换成机器指令，那么 CPU 访问内存的时候必须指定一个地址，这个地址如果是一个绝对的物理地址，那么程序就必须放在内存中的一个固定的地方，而且这个地址需要在编译的时候就要确认，大家应该想到这样有多坑了吧， 如果我要同时运行两个 office word 程序，那么他们将操作同一块内存，那就乱套了，伟大的计算机前辈设计出，让 CPU<br>采用 段基址 + 段内偏移地址 的方式访问内存，其中段基地址在程序启动的时候确认，尽管这个段基地址还是绝对的物理地址，但终究可以同时运行多个程序了， CPU 采用这种方式访问内存，就需要段基址寄存器和段内偏移地址寄存器来存储地址，最终将两个地址相加送上地址总线。而内存分段，相当于每个进程都会分配一个内存段，而且这个内存段需要是一块连续的空间，主存里维护着多个内存段，当某个进程需要更多内存，并且超出物理内存的时候，就需要将某个不常用的内存段换到硬盘上，等有充足内存的时候在从硬盘加载进来，也就是 swap .每次交换都需要操作整个段的数据。</p>
<p>首先连续的地址空间是很宝贵的，例如一个 50M 的内存，在内存段之间有空隙的情况下，将无法支持 5 个需要 10M 内存才能运行的程序，如何才能让段内地址不连续呢? 答案是内存分页。</p>
<p>在保护模式下，每一个进程都有自己独立的地址空间，所以段基地址是固定的，只需要给出段内偏移地址就可以了，而这个偏移地址称为线性地址，线性地址是连续的，而内存分页将连续的线性地址和分页后的物理地址相关联，这样逻辑上的连续线性地址可以对应不连续的物理地址。物理地址空间可以被多个进程共享，而这个映射关系将通过页表( page table)进行维护。 标准页的尺寸一般为 4KB ，分页后，物理内存被分成若干个 4KB 的数据页，进程申请内存的时候，可以映射为多个 4KB 大小的物理内存，而应用程序读取数据的时候会以页为最小单位，当需要和硬盘发生交换的时候也是以页为单位。</p>
<p>现代计算机多采用虚拟存储技术，虚拟存储让每个进程以为自己独占整个内存空间，其实这个虚拟空间是主存和磁盘的抽象，这样的好处是，每个进程拥有一致的虚拟地址空间，简化了内存管理，进程不需要和其他进程竞争内存空间，因为他是独占的，也保护了各自进程不被其他进程破坏，另外，他把主存看成磁盘的一个缓存，主存中仅保存活动的程序段和数据段，当主存中不存在数据的时候发生缺页中断，然后从磁盘加载进来，当物理内存不足的时候会发生 swap 到磁盘。页表保存了虚拟地址和物理地址的映射，页表是一个数组，每个元素为一个页的映射关系，这个映射关系可能是和主存地址，也可能和磁盘，页表存储在主存，我们将存储在高速缓冲区 cache 中的页表称为快表 TLAB 。</p>
<p><img src="./2019-03-06_java_os/7.jpg"></p>
<ul>
<li><p>  装入位 表示对于页是否在主存，如果地址页每页表示，数据还在磁盘</p>
</li>
<li><p>  存放位置 建立虚拟页和物理页的映射，用于地址转换，如果为null表示是一个未分配页</p>
</li>
<li><p>  修改位 用来存储数据是否修改过</p>
</li>
<li><p>  权限位 用来控制是否有读写权限</p>
</li>
<li><p>  禁止缓存位 主要用来保证 cache 主存 磁盘的数据一致性</p>
</li>
</ul>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>正常情况下，我们读取文件的流程为，先通过系统调用从磁盘读取数据，存入操作系统的内核缓冲区，然后在从内核缓冲区拷贝到用户空间，而内存映射，是将磁盘文件直接映射到用户的虚拟存储空间中，通过页表维护虚拟地址到磁盘的映射，通过内存映射的方式读取文件的好处有，因为减少了从内核缓冲区到用户空间的拷贝，直接从磁盘读取数据到内存，减少了系统调用的开销，对用户而言，仿佛直接操作的磁盘上的文件，另外由于使用了虚拟存储，所以不需要连续的主存空间来存储数据。</p>
<p><img src="./2019-03-06_java_os/8.jpg"></p>
<p>在 Java 中，我们使用 MappedByteBuffer 来实现内存映射，这是一个堆外内存，在映射完之后，并没有立即占有物理内存，而是访问数据页的时候，先查页表，发现还没加载，发起缺页异常，然后在从磁盘将数据加载进内存，所以一些对实时性要求很高的中间件，例如rocketmq,消息存储在一个大小为1G的文件中，为了加快读写速度，会将这个文件映射到内存后，在每个页写一比特数据，这样就可以把整个1G文件都加载进内存，在实际读写的时候就不会发生缺页了，这个在rocketmq内部叫做文件预热。</p>
<p>下面我们贴一段 rocketmq 消息存储模块的代码，位于 MappedFile 类中，这个类是 rocketMq 消息存储的核心类感兴趣的可以自行研究，下面两个方法一个是创建文件映射，一个是预热文件，每预热 1000 个数据页，就让出 CPU 权限。</p>
<pre><code>private void init(final String fileName, final int fileSize) throws IOException &#123;
    this.fileName = fileName;
    this.fileSize = fileSize;
    this.file = new File(fileName);
    this.fileFromOffset = Long.parseLong(this.file.getName());
    boolean ok = false;

    ensureDirOK(this.file.getParent());

    try &#123;
        this.fileChannel = new RandomAccessFile(this.file, &quot;rw&quot;).getChannel();
        this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);
        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);
        TOTAL_MAPPED_FILES.incrementAndGet();
        ok = true;
    &#125; catch (FileNotFoundException e) &#123;
        log.error(&quot;create file channel &quot; + this.fileName + &quot; Failed. &quot;, e);
        throw e;
    &#125; catch (IOException e) &#123;
        log.error(&quot;map file &quot; + this.fileName + &quot; Failed. &quot;, e);
        throw e;
    &#125; finally &#123;
        if (!ok &amp;&amp; this.fileChannel != null) &#123;
            this.fileChannel.close();
        &#125;
    &#125;
&#125;


//文件预热，OS_PAGE_SIZE = 4kb 相当于每 4kb 就写一个 byte 0 ，将所有的页都加载到内存，真正使用的时候就不会发生缺页异常了
 public void warmMappedFile(FlushDiskType type, int pages) &#123;
    long beginTime = System.currentTimeMillis();
    ByteBuffer byteBuffer = this.mappedByteBuffer.slice();
    int flush = 0;
    long time = System.currentTimeMillis();
    for (int i = 0, j = 0; i &lt; this.fileSize; i += MappedFile.OS_PAGE_SIZE, j++) &#123;
        byteBuffer.put(i, (byte) 0);
        // force flush when flush disk type is sync
        if (type == FlushDiskType.SYNC_FLUSH) &#123;
            if ((i / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE) &gt;= pages) &#123;
                flush = i;
                mappedByteBuffer.force();
            &#125;
        &#125;

        // prevent gc
        if (j % 1000 == 0) &#123;
            log.info(&quot;j=&#123;&#125;， costTime=&#123;&#125;&quot;, j, System.currentTimeMillis() - time);
            time = System.currentTimeMillis();
            try &#123;
            // 这里sleep(0)，让线程让出 CPU 权限，供其他更高优先级的线程执行，此线程从运行中转换为就绪
                Thread.sleep(0);
            &#125; catch (InterruptedException e) &#123;
                log.error(&quot;Interrupted&quot;, e);
            &#125;
        &#125;
    &#125;

    // force flush when prepare load finished
    if (type == FlushDiskType.SYNC_FLUSH) &#123;
        log.info(&quot;mapped file warm-up done, force to disk, mappedFile=&#123;&#125;， costTime=&#123;&#125;&quot;,
            this.getFileName()， System.currentTimeMillis() - beginTime);
        mappedByteBuffer.force();
    &#125;
    log.info(&quot;mapped file warm-up done. mappedFile=&#123;&#125;， costTime=&#123;&#125;&quot;, this.getFileName()，
        System.currentTimeMillis() - beginTime);

    this.mlock();
&#125;</code></pre>
<h4 id="JVM-中对象的内存布局"><a href="#JVM-中对象的内存布局" class="headerlink" title="JVM 中对象的内存布局"></a>JVM 中对象的内存布局</h4><p>在linux中只要知道一个变量的起始地址就可以读出这个变量的值，因为从这个起始地址起前8位记录了变量的大小，也就是可以定位到结束地址，在 Java 中我们可以通过 Field.get(object) 的方式获取变量的值，也就是反射，最终是通过 UnSafe 类来实现的。我们可以分析下具体代码</p>
<pre><code>Field 对象的 getInt方法  先安全检查 ，然后调用 FieldAccessor
    @CallerSensitive
    public int getInt(Object obj)
        throws IllegalArgumentException, IllegalAccessException
    &#123;
        if (!override) &#123;
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;
                Class&lt;?&gt; caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            &#125;
        &#125;
        return getFieldAccessor(obj).getInt(obj);
    &#125;


 获取field在所在对象中的地址的偏移量 fieldoffset
    UnsafeFieldAccessorImpl(Field var1) &#123;
            this.field = var1;
            if(Modifier.isStatic(var1.getModifiers())) &#123;
                this.fieldOffset = unsafe.staticFieldOffset(var1);
            &#125; else &#123;
                this.fieldOffset = unsafe.objectFieldOffset(var1);
            &#125;

            this.isFinal = Modifier.isFinal(var1.getModifiers());
     &#125;


 UnsafeStaticIntegerFieldAccessorImpl 调用unsafe中的方法
     public int getInt(Object var1) throws IllegalArgumentException &#123;
          return unsafe.getInt(this.base, this.fieldOffset);
     &#125;</code></pre>
<p>通过上面的代码我们可以通过属性相对对象起始地址的偏移量，来读取和写入属性的值，这也是 Java 反射的原理，这种模式在jdk中很多场景都有用到，例如LockSupport.park中设置阻塞对象。 那么属性的偏移量具体根据什么规则来确定的呢? 下面我们借此机会分析下 Java 对象的内存布局  </p>
<p>在 Java 虚拟机中，每个 Java 对象都有一个对象头 (object header) ，由标记字段和类型指针构成，标记字段用来存储对象的哈希码， GC 信息， 持有的锁信息，而类型指针指向该对象的类 Class ，在 64 位操作系统中，标记字段占有 64 位，而类型指针也占 64 位，也就是说一个 Java 对象在<br>什么属性都没有的情况下要占有 16 字节的空间，当前 JVM 中默认开启了压缩指针，这样类型指针可以只占 32 位，所以对象头占 12 字节， 压缩指针可以作用于对象头，以及引用类型的字段。 JVM 为了内存对齐，会对字段进行重排序，这里的对齐主要指 Java 虚拟机堆中的对象的起始地址为 8 的倍数，如果一个对象用不到 8N 个字节，那么剩下的就会被填充，另外子类继承的属性的偏移量和父类一致，<br>以 Long 为例，他只有一个非 static 属性 value ，而尽管对象头只占有 12 字节，而属性 value 的偏移量只能是 16, 其中 4 字节只能浪费掉，所以字段重排就是为了避免内存浪费， 所以我们很难在 Java 字节码被加载之前分析出这个 Java 对象占有的实际空间有多大，我们只能通过递归父类的所有属性来预估对象大小，而真实占用的大小可以通过 Java agent 中的 Instrumentation获取。<br>当然内存对齐另外一个原因是为了让字段只出现在同一个 CPU 的缓存行中，如果字段不对齐，就有可能出现一个字段的一部分在缓存行 1 中，而剩下的一半在 缓存行 2 中，这样该字段的读取需要替换两个缓存行，而字段的写入会导致两个缓存行上缓存的其他数据都无效，这样会影响程序性能。</p>
<p>通过内存对齐可以避免一个字段同时存在两个缓存行里的情况，但还是无法完全规避缓存伪共享的问题，也就是一个缓存行中存了多个变量，而这几个变量在多核 CPU 并行的时候，会导致竞争缓存行的写权限，当其中一个 CPU 写入数据后，这个字段对应的缓存行将失效，导致这个缓存行的其他字段也失效。</p>
<p><img src="./2019-03-06_java_os/9.jpg"></p>
<p>在 Disruptor 中，通过填充几个无意义的字段，让对象的大小刚好在 64 字节，一个缓存行的大小为64字节，这样这个缓存行就只会给这一个变量使用，从而避免缓存行伪共享，但是在 jdk7 中，由于无效字段被清除导致该方法失效，只能通过继承父类字段来避免填充字段被优化，而 jdk8 提供了注解<br>@Contended 来标示这个变量或对象将独享一个缓存行，使用这个注解必须在 JVM 启动的时候加上 -XX:-RestrictContended 参数，其实也是用空间换取时间。</p>
<pre><code>jdk6  --- 32 位系统下
    public final static class VolatileLong
    &#123;
        public volatile long value = 0L;
        public long p1, p2, p3, p4, p5, p6; // 填充字段
    &#125;

jdk7 通过继承

   public class VolatileLongPadding &#123;
       public volatile long p1, p2, p3, p4, p5, p6; // 填充字段
   &#125;
   public class VolatileLong extends VolatileLongPadding &#123;
       public volatile long value = 0L;
   &#125;

jdk8 通过注解

   @Contended
   public class VolatileLong &#123;
       public volatile long value = 0L;
   &#125;</code></pre>
<p>NPTL和 Java 的线程模型  </p>
<p>按照教科书的定义，进程是资源管理的最小单位，而线程是 CPU 调度执行的最小单位，线程的出现是为了减少进程的上下文切换(线程的上下文切换比进程小很多)，以及更好适配多核心 CPU 环境，例如一个进程下多个线程可以分别在不同的 CPU 上执行，而多线程的支持，既可以放在Linux内核实现，也可以在核外实现，如果放在核外，只需要完成运行栈的切换，调度开销小，但是这种方式无法适应多 CPU 环境，底层的进程还是运行在一个 CPU 上，另外由于对用户编程要求高，所以目前主流的操作系统都是在内核支持线程，而在Linux中，线程是一个轻量级进程，只是优化了线程调度的开销。而在 JVM 中的线程和内核线程是一一对应的，线程的调度完全交给了内核，当调用<br>Thread.run 的时候，就会通过系统调用 fork() 创建一个内核线程，这个方法会在用户态和内核态之间进行切换，性能没有在用户态实现线程高，当然由于直接使用内核线程，所以能够创建的最大线程数也受内核控制。目前 Linux上 的线程模型为 NPTL ( Native POSIX Thread Library)，他使用一对一模式，兼容 POSIX 标准，没有使用管理线程，可以更好地在多核 CPU 上运行。</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>对进程而言，就三种状态，就绪，运行，阻塞，而在 JVM 中，阻塞有四种类型，我们可以通过 jstack 生成 dump 文件查看线程的状态。</p>
<ul>
<li><p>  BLOCKED (on object monitor) 通过 synchronized(obj) 同步块获取锁的时候，等待其他线程释放对象锁，dump 文件会显示 waiting to lock &lt;0x00000000e1c9f108&gt;</p>
</li>
<li><p>  TIMED WAITING (on object monitor) 和 WAITING (on object monitor) 在获取锁后，调用了 object.wait() 等待其他线程调用 object.notify()，两者区别是是否带超时时间</p>
</li>
<li><p>  TIMED WAITING (sleeping) 程序调用了 thread.sleep()，这里如果 sleep(0) 不会进入阻塞状态，会直接从运行转换为就绪</p>
</li>
<li><p>  TIMED WAITING (parking) 和 WAITING (parking) 程序调用了 Unsafe.park()，线程被挂起，等待某个条件发生，waiting on condition</p>
</li>
</ul>
<p>而在 POSIX 标准中，thread_block 接受一个参数 stat ，这个参数也有三种类型，TASK_BLOCKED, TASK_WAITING, TASK_HANGING,而调度器只会对线程状态为 READY 的线程执行调度，另外一点是线程的阻塞是线程自己操作的，相当于是线程主动让出 CPU 时间片，所以等线程被唤醒后，他的剩余时间片不会变，该线程只能在剩下的时间片运行，如果该时间片到期后线程还没结束，该线程状态会由 RUNNING 转换为 READY ，等待调度器的下一次调度。</p>
<p>好了，关于线程就分析到这，关于 Java 并发包，核心都在 AQS 里，底层是通过 UnSafe类的 cas 方法，以及 park 方法实现，后面我们在找时间单独分析，现在我们在看看 Linux 的进程同步方案。</p>
<blockquote>
<p>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX,缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准。</p>
<p>CAS 操作需要 CPU 支持，将比较 和 交换 作为一条指令来执行， CAS 一般有三个参数，内存位置，预期原值，新值 ，所以UnSafe 类中的 compareAndSwap 用属性相对对象初始地址的偏移量，来定位内存位置。</p>
</blockquote>
<h4 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h4><p>线程同步出现的根本原因是访问公共资源需要多个操作，而这多个操作的执行过程不具备原子性，被任务调度器分开了，而其他线程会破坏共享资源，所以需要在临界区做线程的同步，这里我们先明确一个概念，就是临界区，他是指多个任务访问共享资源如内存或文件时候的指令，他是指令并不是受访问的资源。</p>
<p>POSIX 定义了五种同步对象，互斥锁，条件变量，自旋锁，读写锁，信号量，这些对象在 JVM 中也都有对应的实现，并没有全部使用 POSIX 定义的 api,通过 Java 实现灵活性更高，也避免了调用native方法的性能开销，当然底层最终都依赖于 pthread 的 互斥锁 mutex 来实现，这是一个系统调用，开销很大，所以 JVM 对锁做了自动升降级，基于AQS的实现以后在分析，这里主要说一下关键字 synchronized .</p>
<p>当声明 synchronized 的代码块时，编译而成的字节码会包含一个 monitorenter 和 多个 monitorexit (多个退出路径，正常和异常情况)，当执行 monitorenter 的时候会检查目标锁对象的计数器是否为0,如果为0则将锁对象的持有线程设置为自己，然后计数器加1,获取到锁，如果不为0则检查锁对象的持有线程是不是自己，如果是自己就将计数器加1获取锁，如果不是则阻塞等待，退出的时候计数器减1,当减为0的时候清楚锁对象的持有线程标记，可以看出 synchronized 是支持可重入的。</p>
<p>刚刚说到线程的阻塞是一个系统调用，开销大，所以 JVM 设计了自适应自旋锁，就是当没有获取到锁的时候， CPU 回进入自旋状态等待其他线程释放锁，自旋的时间主要看上次等待多长时间获取的锁，例如上次自旋5毫秒没有获取锁，这次就6毫秒，自旋会导致 CPU 空跑，另一个副总用就是不公平的锁机制，因为该线程自旋获取到锁，而其他正在阻塞的线程还在等待。除了自旋锁， JVM 还通过 CAS 实现了轻量级锁和偏向锁来分别针对多个线程在不同时间访问锁和锁仅会被一个线程使用的情况。后两种锁相当于并没有调用底层的信号量实现(通过信号量来控制线程A释放了锁例如调用了 wait()，而线程B就可以获取锁，这个只有内核才能实现，后面两种由于场景里没有竞争所以也就不需要通过底层信号量控制)，只是自己在用户空间维护了锁的持有关系，所以更高效。</p>
<p><img src="./2019-03-06_java_os/10.jpg"></p>
<p>如上图所示，如果线程进入 monitorenter 会将自己放入该 objectmonitor 的 entryset 队列，然后阻塞，如果当前持有线程调用了 wait 方法，将会释放锁，然后将自己封装成 objectwaiter 放入 objectmonitor 的 waitset 队列，这时候 entryset 队列里的某个线程将会竞争到锁，并进入 active 状态，如果这个线程调用了 notify 方法，将会把 waitset 的第一个 objectwaiter 拿出来放入 entryset (这个时候根据策略可能会先自旋)，当调用 notify 的那个线程执行 moniterexit 释放锁的时候， entryset 里的线程就开始竞争锁后进入 active 状态。</p>
<p>为了让应用程序免于数据竞争的干扰， Java 内存模型中定义了 happen-before 来描述两个操作的内存可见性，也就是 X 操作 happen-before 操作 Y ， 那么 X 操作结果 对 Y 可见。 JVM 中针对 volatile 以及 锁 的实现有 happen-before 规则， JVM 底层通过插入内存屏障来限制编译器的重排序，以 volatile 为例，内存屏障将不允许 在 volatile 字段写操作之前的语句被重排序到写操作后面 ， 也不允许读取 volatile 字段之后的语句被重排序带读取语句之前。插入内存屏障的指令，会根据指令类型不同有不同的效果，例如在 monitorexit 释放锁后会强制刷新缓存，而 volatile 对应的内存屏障会在每次写入后强制刷新到主存，并且由于 volatile 字段的特性，编译器无法将其分配到寄存器，所以每次都是从主存读取，所以 volatile 适用于读多写少得场景，最好只有个线程写多个线程读，如果频繁写入导致不停刷新缓存会影响性能。</p>
<blockquote>
<p>关于应用程序中设置多少线程数合适的问题，我们一般的做法是设置 CPU 最大核心数 * 2 ，我们编码的时候可能不确定运行在什么样的硬件环境中，可以通过 Runtime.getRuntime().availableProcessors() 获取 CPU 核心，<br>但是具体设置多少线程数，主要和线程内运行的任务中的阻塞时间有关系，如果任务中全部是计算密集型，那么只需要设置 CPU 核心数的线程就可以达到 CPU 利用率最高，如果设置的太大，反而因为线程上下文切换影响性能，如果任务中有阻塞操作，而在阻塞的时间就可以让 CPU 去执行其他线程里的任务，我们可以通过 线程数量=内核数量 / （1 - 阻塞率）这个公式去计算最合适的线程数，阻塞率我们可以通过计算任务总的执行时间和阻塞的时间获得，目前微服务架构下有大量的RPC调用，所以利用多线程可以大大提高执行效率，我们可以借助分布式链路监控来统计RPC调用所消耗的时间，而这部分时间就是任务中阻塞的时间，当然为了做到极致的效率最大，我们需要设置不同的值然后进行测试。</p>
</blockquote>
<h2 id="Java-中如何实现定时任务"><a href="#Java-中如何实现定时任务" class="headerlink" title="Java 中如何实现定时任务"></a>Java 中如何实现定时任务</h2><p>定时器已经是现代软件中不可缺少的一部分，例如每隔5秒去查询一下状态，是否有新邮件，实现一个闹钟等， Java 中已经有现成的 api 供使用，但是如果你想设计更高效，更精准的定时器任务，就需要了解底层的硬件知识，比如实现一个分布式任务调度中间件，你可能要考虑到各个应用间时钟同步的问题。</p>
<p>Java 中我们要实现定时任务，有两种方式，一种通过 timer 类， 另外一种是 JUC 中的 ScheduledExecutorService ，不知道大家有没有好奇 JVM 是如何实现定时任务的，难道一直轮询时间，看是否时间到了，如果到了就调用对应的处理任务，但是这种一直轮询不释放 CPU 肯定是不可取的，要么就是线程阻塞，等到时间到了在来唤醒线程，那么 JVM 怎么知道时间到了，如何唤醒呢?</p>
<p>首先我们翻一下 JDK ，发现和时间相关的 API 大概有3处，而且这 3 处还都对时间的精度做了区分:</p>
<ul>
<li><p>object.wait(long millisecond) 参数是毫秒，必须大于等于 0 ，如果等于 0 ，就一直阻塞直到其他线程来唤醒 ，timer 类就是通过 wait() 方法来实现，下面我们看一下wait的另外一个方法</p>
<pre><code>  public final void wait(long timeout, int nanos) throws InterruptedException &#123;
       if (timeout &lt; 0) &#123;
           throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
       &#125;
       if (nanos &lt; 0 || nanos &gt; 999999) &#123;
           throw new IllegalArgumentException(
                               &quot;nanosecond timeout value out of range&quot;);
       &#125;
       if (nanos &gt; 0) &#123;
           timeout++;
       &#125;
       wait(timeout);
   &#125;</code></pre>
</li>
</ul>
<pre><code>这个方法是想提供一个可以支持纳秒级的超时时间，然而只是粗暴的加 1 毫秒。</code></pre>
<ul>
<li><p>Thread.sleep(long millisecond) 目前一般通过这种方式释放 CPU ，如果参数为 0 ，表示释放 CPU 给更高优先级的线程，自己从运行状态转换为可运行态等待 CPU 调度，他也提供了一个可以支持纳秒级的方法实现，跟 wait 额区别是它通过 500000 来分隔是否要加 1 毫秒。</p>
<pre><code>  public static void sleep(long millis, int nanos)
   throws InterruptedException &#123;
       if (millis &lt; 0) &#123;
           throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
       &#125;
       if (nanos &lt; 0 || nanos &gt; 999999) &#123;
           throw new IllegalArgumentException(
                               &quot;nanosecond timeout value out of range&quot;);
       &#125;
       if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;
           millis++;
       &#125;
       sleep(millis);
   &#125;</code></pre>
</li>
<li><p>  LockSupport.park(long nans) Condition.await()调用的该方法， ScheduledExecutorService 用的 condition.await() 来实现阻塞一定的超时时间，其他带超时参数的方法也都通过他来实现，目前大多定时器都是通过这个方法来实现的，该方法也提供了一个布尔值来确定时间的精度</p>
</li>
<li><p>  System.currentTimeMillis() 以及 System.nanoTime() 这两种方式都依赖于底层操作系统，前者是毫秒级，经测试 windows 平台的频率可能超过 10ms ，而后者是纳秒级别，频率在 100ns 左右，所以如果要获取更精准的时间建议用后者</p>
</li>
</ul>
<p>好了，api 了解完了，我们来看下定时器的底层是怎么实现的，现代PC机中有三种硬件时钟的实现，他们都是通过晶体振动产生的方波信号输入来完成时钟信号同步的。</p>
<ul>
<li><p>  实时时钟 RTC ，用于长时间存放系统时间的设备，即使关机也可以依靠主板中的电池继续计时。 Linux 启动的时候会从 RTC 中读取时间和日期作为初始值，之后在运行期间通过其他计时器去维护系统时间</p>
</li>
<li><p>  可编程间隔定时器 PIT ，该计数器会有一个初始值，每过一个时钟周期，该初始值会减1,当该初始值被减到0时，就通过导线向 CPU 发送一个时钟中断， CPU 就可以执行对应的中断程序，也就是回调对应的任务</p>
</li>
<li><p>  时间戳计数器 TSC ， 所有的 Intel8086 CPU 中都包含一个时间戳计数器对应的寄存器，该寄存器的值会在每次 CPU 收到一个时钟周期的中断信号后就会加 1 .他比 PIT 精度高，但是不能编程，只能读取。</p>
</li>
</ul>
<blockquote>
<p>时钟周期:硬件计时器在多长时间内产生时钟脉冲，而时钟周期频率为1秒内产生时钟脉冲的个数。目前通常为1193180.</p>
<p>时钟滴答:当PIT中的初始值减到0的时候，就会产生一次时钟中断，这个初始值由编程的时候指定。</p>
</blockquote>
<p>Linux启动的时候，先通过 RTC 获取初始时间，之后内核通过 PIT 中的定时器的时钟滴答来维护日期，并且会定时将该日期写入 RTC,而应用程序的定时器主要是通过设置 PIT 的初始值设置的，当初始值减到0的时候，就表示要执行回调函数了，这里大家会不会有疑问，这样同一时刻只能有一个定时器程序了，而我们在应用程序中，以及多个应用程序之间，<br>肯定有好多定时器任务，其实我们可以参考 ScheduledExecutorService 的实现，只需要将这些定时任务按照时间做一个排序，越靠前待执行的任务放在前面，第一个任务到了在设置第二个任务相对当前时间的值，毕竟 CPU 同一时刻也只能运行一个任务，关于时间的精度问题，我们无法在软件层面做的完全精准，毕竟 CPU 的调度不完全受用户程序控制，当然更大的依赖是硬件的时钟周期频率，目前 TSC 可以提高更高的精度。</p>
<p>现在我们知道了， Java 中的超时时间，是通过可编程间隔定时器设置一个初始值然后等待中断信号实现的，精度上受硬件时钟周期的影响，一般为毫秒级别，毕竟1纳秒光速也只有3米，所以 JDK 中带纳秒参数的实现都是粗暴做法，预留着等待精度更高的定时器出现，而获取当前时间 System.currentTimeMillis() 效率会更高，但他是毫秒级精度，他读取的 Linux 内核维护的日期，而 System.nanoTime() 会优先使用 TSC ，性能稍微低一点，但他是纳秒级，Random 类为了防止冲突就用nanoTime生成种子。</p>
<h2 id="Java-如何和外部设备通信"><a href="#Java-如何和外部设备通信" class="headerlink" title="Java 如何和外部设备通信"></a>Java 如何和外部设备通信</h2><p>计算机的外部设备有鼠标、键盘、打印机、网卡等，通常我们将外部设备和和主存之间的信息传递称为 I/O 操作 ， 按操作特性可以分为，输出型设备，输入型设备，存储设备。现代设备都采用通道方式和主存进行交互，通道是一个专门用来处理IO任务的设备， CPU 在处理主程序时遇到I/O请求，启动指定通道上选址的设备，一旦启动成功，通道开始控制设备进行操作，而 CPU 可以继续执行其他任务，I/O 操作完成后，通道发出 I/O 操作结束的中断，处理器转而处理 IO 结束后的事件。其他处理 IO 的方式，例如轮询、中断、DMA,在性能上都不见通道，这里就不介绍了。当然 Java 程序和外部设备通信也是通过系统调用完成，这里也不在继续深入了。</p>
<p>作者简介</p>
<p>小强，铜板街资金端后台开发工程师，2015年6月加入铜板街。目前负责铜板街资金端清结算相关的开发。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c983bd46fb9a0710a1bd3e1">https://juejin.im/post/5c983bd46fb9a0710a1bd3e1</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/nio/2019-02-27_java_nio_model.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/nio/2019-02-27_java_nio_model.html" class="post-title-link" itemprop="url">谈一谈 Java IO 模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+00:00">2019-02-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-NIO/" itemprop="url" rel="index"><span itemprop="name">Java NIO</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java IO 模型对于 Java 开发工程师来说，是日常工作中经常接触的内容，特别是随着分布式系统的兴起，IO 也显得越来越重要，Java 的 IO 模型本质上还是利用操作系统提供的接口来实现，不熟悉这一部分内容的话，可以先看一下上篇文章<a target="_blank" rel="noopener" href="https://tech.fenxiangz.com/topic/70/unix-%E7%BD%91%E7%BB%9C-io-%E6%A8%A1%E5%9E%8B%E5%8F%8A-linux-%E7%9A%84-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B">Unix 网络 IO 模型及 Linux 的 IO 多路复用模型</a>，本文跟上篇的内容是紧密相连的，特别是本文的重点 —— Java NIO 部分，其底层原理就是 UNIX 的 IO 多路复用，IO 多路复用在上篇文章中讲述了很多。</p>
<p>这篇文章大概内容如下：</p>
<ol>
<li> Java IO 模型的简单介绍；</li>
<li> BIO 、NIO、AIO 模型的介绍，会详细介绍 NIO；</li>
<li> 几种 IO 模型的对比。</li>
</ol>
<h2 id="Java-IO-模型介绍"><a href="#Java-IO-模型介绍" class="headerlink" title="Java IO 模型介绍"></a>Java IO 模型介绍</h2><hr>
<p>在 JDK 推出 Java NIO 之前，基于 Java 的所有 Socket 通信都采用了同步阻塞模式（BIO），这种一对一的通信模型虽然简化了开发的难度，但在性能和可靠性方面却存在这巨大的瓶颈，特别是无法处理高并发的场景，使得 Java 在服务器端应用十分有限。</p>
<p>正是由于 Java 传统 BIO 的拙劣表现，使得 Java 不得不去开发新版的 IO 模型，最终，JDK1.4 提供了新的 NIO 类库，Java 可以支持非阻塞 IO；之后，JDK1.7 正式发布，不但对 NIO 进行了升级，还提供了 AIO 功能。本文就是在对 Java 这些 IO 模型学习后，总结的一篇笔记。</p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><hr>
<p>网络编程的基本模型是 Client/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的 IP 地址和端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接成功，双方就可以通过网络套接字（socket）进行通信（可以参考TCP的三次握手和四次挥手），下面先看一下两种对 IO 模型常见的分类方式。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><hr>
<p>描述的是用户线程与内核的交互方式，与消息的通知机制有关：</p>
<ol>
<li> 同步：当一个同步调用发出后，需要等待返回消息（用户线程不断去询问），才能继续进行；</li>
<li> 异步：当一个异步调用发出后，调用者不能立即得到返回消息，完成后会通过状态、通知和回调来通知调用者。</li>
</ol>
<p>简单来说就是：</p>
<ol>
<li> 同步：同步等待消息通知，消息返回才能继续进行；</li>
<li> 异步：异步等待消息通知，完成后被调系统通过回调等来通知调用者。</li>
</ol>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><hr>
<p>阻塞和非阻塞指的是不能立刻得到结果之前，会不会阻塞当前线程。</p>
<ol>
<li> 阻塞：当前线程会被挂起，直到结果返回；</li>
<li> 非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回（会导致线程切换的增加）。</li>
</ol>
<p>举个栗子说明：</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">示例</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">同步阻塞</td>
<td align="left">在银行排队，不干别的事情</td>
<td align="left">效率最低</td>
</tr>
<tr>
<td align="left">同步非阻塞</td>
<td align="left">排队时，边打电话边抬头看是否到自己了</td>
<td align="left">效率低下</td>
</tr>
<tr>
<td align="left">异步阻塞</td>
<td align="left">在银行领一个号后，在银行里等，不能做别的事情</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">异步非阻塞</td>
<td align="left">领完号后，在忙着自己的事情，直到柜台通知</td>
<td align="left">效率较高</td>
</tr>
</tbody></table>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><hr>
<p>BIO 模型是 Java IO 最开始提供的一种 IO 模型，BIO 又可以细分为两种模型，一是传统的同步阻塞模型，二是在对传统 BIO 模型的基本上进行的优化，又称为伪异步 IO 模型。</p>
<h3 id="传统的-BIO-模型"><a href="#传统的-BIO-模型" class="headerlink" title="传统的 BIO 模型"></a>传统的 BIO 模型</h3><hr>
<p>传统 BIO 中，ServerSocket 负责绑定 IP 地址，启动监听端口；Socket 负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通信。采用 BIO 通信模型的 Server，通常由一个独立的 Acceptor 线程负责监听 Client 端的连接，它接受到 Client 端连接请求后为每个 Client 创建一个新的线程进行处理，处理完之后，通过输出流返回给 Client 端，线程销毁，过程如下图所示（图来自《Netty 权威指南》）。</p>
<p><img src="./2019-02-27_java_nio_model/1.png"> </p>
<p>这个模型最大的问题是：</p>
<ul>
<li>  缺乏扩展性，不能处理高性能、高并发场景，线程是 JVM 中非常宝贵的资源，当线程数膨胀后，系统的性能就会急剧下降，随着并发访问量的继续增大，系统就会出现线程堆栈溢出、创建新线程失败等问题，导致 Server 不能对外提供服务。</li>
</ul>
<p>示例代码参考 <a target="_blank" rel="noopener" href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/bio/">Java BIO 示例</a>。</p>
<h3 id="伪异步-IO-模型"><a href="#伪异步-IO-模型" class="headerlink" title="伪异步 IO 模型"></a>伪异步 IO 模型</h3><hr>
<p>为了改进这种一对一的连接模型，后来又演进出了一种通过线程池或者消息队列实现 1 个或者多个线程处理所有 Client 请求的模型，由于它底层依然是同步阻塞 IO，所以被称为【伪异步 IO 模型】。相比于传统 BIO 后端不断创建新的线程处理 Client 请求，它在后端使用一个<strong>线程池</strong>来代替，通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程资源耗尽，过程如下图所示（图来自《Netty 权威指南》）。</p>
<p><img src="./2019-02-27_java_nio_model/2.png"> </p>
<p>看似这个模型解决了 BIO 面对的问题，实际上，由于它是面向数据流的模型，底层依然是同步阻塞模型，在处理一个 socket 输入流，它会一直阻塞下去，除非：有数据可读、可用数据读取完毕、有异常，否则会一直一直阻塞下去。这个模型最大的问题是：</p>
<ul>
<li>  阻塞的时间取决于对应 IO 线程的处理速度和网络 IO 的传输速度，处理效率不可控。</li>
</ul>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><hr>
<p>Java NIO 是 Java IO 模型中最重要的 IO 模型，也是本文主要讲述的内容，正式由于 NIO 的出现，Java 才能在服务端获得跟 C 和 C++ 一样的运行效率，NIO 是 New IO（或者 Non-block IO）的简称。</p>
<p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同套接字通道的实现，它们都支持阻塞和非阻塞两种模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞 IO 以降低复杂度，但是高负载、高并发的网络应用，需要使用 NIO 的非阻塞模式进行开发。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><hr>
<p>在 NIO 中有三种非常重要的概念：</p>
<ul>
<li>  缓冲区（buffer）：本质上是一个数组，它包含一些要读写的数据；</li>
<li>  通道（channel）：是一个通道，通过它读写数据，类似于自来水管；</li>
<li>  多路复用器（selector）：用于选择已经就绪的任务，selector 会轮询注册在其上的 channel，选出已经就绪的 channel。</li>
</ul>
<p><img src="./2019-02-27_java_nio_model/3.png"> </p>
<p>三者之间的关系如上图所示，这里先简单概括一下：</p>
<ul>
<li>  Buffer：是缓冲区，任何时候访问 NIO 数据，都是通过 Buffer 进行；</li>
<li>  Channel：通过它读写 Buffer 中的数据，可以用于读、写或同时读写；</li>
<li>  Selector：多路复用器，Selector 不断轮询注册在其上的 Channel，如果某个 Channel 有新的 TCP 链接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过<code>SelectionKey()</code> 可以获取就绪 Channel 的集合，进行后续的 IO 操作。</li>
</ul>
<p>下面详细介绍一下这三个概念。</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel 是全双工的，可以比流更好地映射底层操作系统的 API，与流也非常相似，有以下几点区别：</p>
<ul>
<li>  Channel 可以读也可以写，但流（InputStream 或 OutputStream）是单向的；</li>
<li>  通道可以异步读写；</li>
<li>  它是基于缓冲区（Buffer）进行读写；</li>
</ul>
<p>在 Java 中提供以下几种 Channel：</p>
<ol>
<li> FileChannel：用于文件的读写；</li>
<li> DatagramChannel：用于 UDP 数据读写；</li>
<li> SocketChannel：用于 Socket 数据读写；</li>
<li> ServerSocketChannel：监听 TCP 连接请求。</li>
</ol>
<p>这些 Channel 类之间的继承关系如下图所示</p>
<p><img src="./2019-02-27_java_nio_model/4.png"> </p>
<p>从上图中，可以看出，Channel 可以分为两大类：用于网络读写的 <code>SelectableChannel</code> 和用于文件操作的 <code>FileChannel</code>。</p>
<p>其中，FileChannel 只能在阻塞模式下工作，具体可以参考<a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-filechannel.html">Java NIO FileChannel文件通道</a>。</p>
<h5 id="NIO-Scatter-Gather"><a href="#NIO-Scatter-Gather" class="headerlink" title="NIO Scatter/Gather"></a>NIO Scatter/Gather</h5><p>Java NIO 发布时内置了对 scatter/gather的支持：</p>
<ul>
<li>  Scattering read 指的是从通道读取的操作能把数据写入多个 Buffer，也就是 scatter 代表了数据从一个 Channel 到多个 Buffer的过程。</li>
<li>  Gathering write 则正好相反，表示的是从多个 Buffer 把数据写入到一个 Channel中。</li>
</ul>
<p><img src="./2019-02-27_java_nio_model/5.png"> </p>
<p>示例如下，具体参考 <a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-scatter-gather.html">Java NIO Scatter / Gather</a></p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer，本质上是一块内存区，可以用来读写数据，它包含一些要写入或者要读出的数据。在 NIO 中，所有数据都是通过 Buffer 处理的，读取数据时，它是直接读到缓冲区中，写入数据时，写入到缓冲区。</p>
<p>最常用的缓冲区是 ByteBuffer，一个 ByteBuffer 提供了一组功能用于操作 byte 数组，除了 ByteBuffer，还有其他的一些 Buffer，如：CharBuffer、IntBuffer 等，它们之间的关系如下图所示。</p>
<p><img src="./2019-02-27_java_nio_model/6.png"> </p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>Buffer 基本用法（读写数据过程）：</p>
<ol>
<li> 把数据写入 Buffer；</li>
<li> 调用 <code>flip()</code>，Buffer 由写模式变为读模式；</li>
<li> Buffer 中读取数据；</li>
<li> 调用 <code>clear()</code> 清空 buffer，等待下次写入。</li>
</ol>
<p>示例如下：</p>
<h5 id="Buffer-位置信息"><a href="#Buffer-位置信息" class="headerlink" title="Buffer 位置信息"></a>Buffer 位置信息</h5><p>Buffer 实质上就是一块内存，用于读写数据，这块内存被 NIO Buffer 管理，一个 Buffer 有三个属性是必须掌握的，分别是：</p>
<ul>
<li>  capacity：容量；</li>
<li>  position：位置；</li>
<li>  limit：限制；</li>
</ul>
<p>其中，position 和 limit 的具体含义取决于当前 buffer 的模式，capacity 在两种模式下都表示容量，Buffer 读模式和写模式如下图所示。</p>
<p><img src="./2019-02-27_java_nio_model/7.png"> </p>
<ol>
<li>容量（capacity）<ul>
<li>  Buffer 有一块固定的内存，其大小就是 capacity，一旦 Buffer 写满，就需要清空已读数据以便下次继续写入新的数据；</li>
</ul>
</li>
<li>位置（Position）<ul>
<li>  写模式时，当写入数据到 Buffer 的时候从一个确定的位置开始，初始化时这个位置 position 为0，写入数据后，position 的值就会指向数据之后的单元，position 最大的值可以达到 <code>capacity-1</code>；</li>
<li>  读模式时，也需要从一个确定的位置开始，Buffer 从写模式变为读模式时，position 会归零，每次读取后，position 向后移动；</li>
</ul>
</li>
<li>上限（limit）<ul>
<li>  写模式时，limit 就是能写入的最大数据量，等同于 Buffer 的容量；</li>
<li>  读模式时，limit 代表我们能读取的最大容量，它的值等同于写模式下 position 位置。</li>
</ul>
</li>
</ol>
<h5 id="Buffer-常用方法"><a href="#Buffer-常用方法" class="headerlink" title="Buffer 常用方法"></a>Buffer 常用方法</h5><ul>
<li>  <code>flip()</code>：把 buffer 从模式调整为读模式，在读模式下，可以读取所有已经写入的数据；</li>
<li>  <code>clear()</code>：清空整个 buffer；</li>
<li>  <code>compact()</code>：只清空已读取的数据，未被读取的数据会被移动到 buffer 的开始位置，写入位置则紧跟着未读数据之后；</li>
<li>  <code>rewind()</code>：将 position 置为0，这样我们可以重复读取 Buffer 中的数据，limit 保持不变；</li>
<li>  <code>mark()</code>和<code>reset()</code>：通过mark方法可以标记当前的position，通过reset来恢复mark的位置</li>
<li>  <code>equals()</code>：判断两个 Buffer 是否相等，需满足：类型相同、Buffer 中剩余字节数相同、所有剩余字节相等；</li>
<li>  <code>compareTo()</code>：compareTo 比较 Buffer 中的剩余元素，只不过这个方法适用于比较排序的。</li>
</ul>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector 是 Java NIO 核心部分，简单来说，它的作用就是：Selector 不断轮询注册在其上的 Channel，如果某个 Channel 上面有新的 TCP 连接、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 <code>SelectorKey()</code> 可以获取就绪 Channel 的集合，进行后续的 IO 操作。</p>
<p>一个 Selector 可以轮询多个 Channel，由于 JDK 底层使用了 <code>epoll()</code> 实现，它并没有最大连接句柄 1024/2048 的限制，这就意味着只需要一个线程负责 Selector 的轮询，就可以连接上千上万的 Client。</p>
<h5 id="注册-Channel"><a href="#注册-Channel" class="headerlink" title="注册 Channel"></a>注册 Channel</h5><p>举一个栗子，简单介绍 <code>Selector</code> 的使用。</p>
<p><code>register()</code> 的第二个参数代表的是 selector 监听的事件类型，Selector 可以监听事件类型总共有以下四种：</p>
<ol>
<li> SelectionKey.OP_CONNECT：只会注册一次，成功之后（TCP 连接建立之后），这个监听事件就取消了；</li>
<li> SelectionKey.OP_ACCEPT：主要用于服务端，就是监听是否有新的连接请求；</li>
<li> SelectionKey.OP_READ：注册之后不会取消，监听是否数据到来；</li>
<li> SelectionKey.OP_WRITE：最好的使用方法是每当发送数据时，就注册一次，然后再取消，否则每次 select 轮询时，注册 OP_WRITE 事件的 Channel 都是 ready 的，除非 socket send buffer 满了（参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23136079/communicating-between-nio-op-read-and-op-write-operations">Communicating between nio OP_READ and OP_WRITE operations</a>）。</li>
</ol>
<h5 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h5><p><code>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</code> 返回的是已经就绪的 Channel 集合，<code>SelectionKey</code> 对象的详细属性如下图所示。</p>
<p><img src="./2019-02-27_java_nio_model/8.png"> </p>
<h3 id="NIO-原理"><a href="#NIO-原理" class="headerlink" title="NIO 原理"></a>NIO 原理</h3><hr>
<p>Java NIO 实现的关键是 IO 多路复用（具体可以参考上篇文章：<a target="_blank" rel="noopener" href="https://tech.fenxiangz.com/topic/70/unix-%E7%BD%91%E7%BB%9C-io-%E6%A8%A1%E5%9E%8B%E5%8F%8A-linux-%E7%9A%84-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B#linux-%E7%9A%84-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B">Linux 的 IO 多路复用模型</a>），在 Linux 平台，Java NIO 是基于 epoll（2.6以上，之前是 Select） 来实现的。</p>
<p>Linux 的 select/epoll 使用的是 Reactor 网络 IO 模式。网络编程中，有两种常用的设计模式，它们都是基于事件驱动：</p>
<ul>
<li>  Reactor 模式：主动模式，应用程序不断去轮询，问操作系统 IO 是否就绪，实际的 IO 操作还是由应用实现（IO 多路复用采用的模式）；</li>
<li>  Proactor 模式：被动模式，操作系统把 IO 完成后通知应用程序，此时数据已经就绪。</li>
</ul>
<p>这两种模式详细内容可以参考<a target="_blank" rel="noopener" href="https://tech.fenxiangz.com/topic/72/%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%80%A7%E8%83%BD-i-o-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-reactor-%E5%92%8C-proactor">两种高性能 I/O 设计模式 Reactor 和 Proactor</a>一文。</p>
<h3 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h3><hr>
<p>关于 Java NIO，有两种最常见的使用方式：</p>
<ul>
<li>  使用原生的 Java NIO（如 Kafka）；</li>
<li>  使用 Netty（Hadoop 的 RPC 框架 Avro 底层使用 Netty 做通信框架）。</li>
</ul>
<p>在实际使用中，推荐第二种，使用 Netty 将会大大提高开发效率，后续会写篇关于 Netty 的文章，介绍一下 Netty 的具体内容，这里使用一个基于 Java 原生 NIO API 的小示例，讲述一下 NIO 的使用方法。</p>
<h4 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h4><p>NIO Client 创建序列图如下图所示（图片来自《Netty 权威指南》）。</p>
<p><img src="./2019-02-27_java_nio_model/9.png"> </p>
<p>具体的代码及注释参考：<a target="_blank" rel="noopener" href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/nio/client/">NIO Client 端代码</a>。</p>
<h4 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h4><p>NIO Server 创建序列图如下图所示（图片来自《Netty 权威指南》）。</p>
<p><img src="./2019-02-27_java_nio_model/10.png"> </p>
<p>具体的代码及注释参考：<a target="_blank" rel="noopener" href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/nio/server/">NIO Server 端代码</a>。</p>
<h2 id="IO-模型对比"><a href="#IO-模型对比" class="headerlink" title="IO 模型对比"></a>IO 模型对比</h2><hr>
<p>在对比之前，先简单介绍 Java AIO 模型，这里就不再进行相应的展开了。</p>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><hr>
<p>NIO 2.0 中引入异步通道的概念，并提供了异步文件通道和异步套接字导通的实现，它是真正的异步非阻塞I IO，底层是利用事件驱动（AIO）实现，不需要多路复用器（Selector）对注册的通道进行轮组操作即可实现异步读写。</p>
<p>可以参考<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/">在 Java 7 中体会 NIO.2 异步执行的快乐</a></p>
<h3 id="几种-IO-模型功能和特性对比"><a href="#几种-IO-模型功能和特性对比" class="headerlink" title="几种 IO 模型功能和特性对比"></a>几种 IO 模型功能和特性对比</h3><hr>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">传统 BIO</th>
<th align="left">伪异步 IO</th>
<th align="left">NIO</th>
<th align="left">AIO</th>
</tr>
</thead>
<tbody><tr>
<td align="left">client 数：IO 线程数</td>
<td align="left">1：1</td>
<td align="left">M：N（M 可以大于 N）</td>
<td align="left">M：1</td>
<td align="left">M：0（不需要额外的线程，被动回调）</td>
</tr>
<tr>
<td align="left">IO 类型（阻塞）</td>
<td align="left">阻塞IO</td>
<td align="left">阻塞IO</td>
<td align="left">非阻塞IO</td>
<td align="left">非阻塞IO</td>
</tr>
<tr>
<td align="left">IO 类型（同步）</td>
<td align="left">同步 IO</td>
<td align="left">同步 IO</td>
<td align="left">同步 IO（IO 多路复用）</td>
<td align="left">异步 IO</td>
</tr>
<tr>
<td align="left">可靠性</td>
<td align="left">非常差</td>
<td align="left">差</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">吞吐量</td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
</tbody></table>
<p>本文主要是对 Java IO 模型总结，特别是对 NIO 模型的总结。</p>
<p>参考</p>
<ul>
<li>  《Netty 权威指南》；</li>
<li>  Java NIO <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/index.html">英文版</a>，<a target="_blank" rel="noopener" href="http://ifeve.com/java-nio-all/">中文版</a>；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/basic/2019-01-21_java_thread_source.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/basic/2019-01-21_java_thread_source.html" class="post-title-link" itemprop="url">从源码的角度再学「Thread」</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-21 09:46:24" itemprop="dateCreated datePublished" datetime="2019-01-21T09:46:24+00:00">2019-01-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java 基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原创： zhangshaolin <strong>张少林同学</strong><br>微信号: zhangshaolin_tonxue</p>
<p>功能介绍 分享</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Java</code>中的线程是使用<code>Thread</code>类实现的，<code>Thread</code>在初学<code>Java</code>的时候就学过了，也在实践中用过，不过一直没从源码的角度去看过它的实现，今天从源码的角度出发，再次学习<code>Java Thread</code>，愿此后对<code>Thread</code>的实践更加得心应手。</p>
<h2 id="从注释开始"><a href="#从注释开始" class="headerlink" title="从注释开始"></a>从注释开始</h2><p>相信阅读过<code>JDK</code>源码的同学都能感受到<code>JDK</code>源码中有非常详尽的注释，阅读某个类的源码应当先看看注释对它的介绍，注释原文就不贴了，以下是我对它的总结：</p>
<ul>
<li><p>  <code>Thread</code>是程序中执行的线程，<code>Java</code>虚拟机允许应用程序同时允许多个执行线程</p>
</li>
<li><p>  每个线程都有优先级的概念，具有较高优先级的线程优先于优先级较低的线程执行</p>
</li>
<li><p>  每个线程都可以被设置为守护线程</p>
</li>
<li><p>  当在某个线程中运行的代码创建一个新的<code>Thread</code>对象时，新的线程优先级跟创建线程一致</p>
</li>
<li><p>  当<code>Java</code>虚拟机启动的时候都会启动一个叫做<code>main</code>的线程，它没有守护线程，<code>main</code>线程会继续执行，直到以下情况发送</p>
</li>
</ul>
<ul>
<li><p>  <code>Runtime</code> 类的退出方法<code>exit</code>被调用并且安全管理器允许进行退出操作</p>
</li>
<li><p>  所有非守护线程均已死亡，或者<code>run</code>方法执行结束正常返回结果，或者<code>run</code>方法抛出异常</p>
</li>
</ul>
<ul>
<li><p>创建线程第一种方式：继承<code>Thread</code>类，重写<code>run</code>方法</p>
<pre><code>   1  //定义线程类
   2  class PrimeThread extends Thread &#123;
   3        long minPrime;
   4        PrimeThread(long minPrime) &#123;
   5            this.minPrime = minPrime;
   6        &#125;
   7        public void run() &#123;
   8            // compute primes larger than minPrime
   9            &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
  10        &#125;
  11    &#125;
  12  //启动线程
  13  PrimeThread p = new PrimeThread(143);
  14  p.start();</code></pre>
</li>
<li><p>创建线程第二种方式：实现<code>Runnable</code>接口，重写<code>run</code>方法，因为<code>Java</code>的单继承限制，通常使用这种方式创建线程更加灵活</p>
<pre><code>   1  //定义线程
   2   class PrimeRun implements Runnable &#123;
   3        long minPrime;
   4        PrimeRun(long minPrime) &#123;
   5            this.minPrime = minPrime;
   6        &#125;
   7        public void run() &#123;
   8            // compute primes larger than minPrime
   9            &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
  10        &#125;
  11    &#125;
  12  //启动线程
  13  PrimeRun p = new PrimeRun(143);
  14  new Thread(p).start();</code></pre>
</li>
<li><p>  创建线程时可以给线程指定名字，如果没有指定，会自动为它生成名字</p>
</li>
<li><p>  除非另有说明，否则将<code>null</code>参数传递给<code>Thread</code>类中的构造函数或方法将导致抛出 <code>NullPointerException</code></p>
</li>
</ul>
<h2 id="Thread-常用属性"><a href="#Thread-常用属性" class="headerlink" title="Thread 常用属性"></a>Thread 常用属性</h2><p>阅读一个<code>Java</code>类，先从它拥有哪些属性入手：</p>
<pre><code>     1  //线程名称，创建线程时可以指定线程的名称
     2  private volatile String name;
     3  
     4  //线程优先级，可以设置线程的优先级
     5  private int priority;
     6  
     7  //可以配置线程是否为守护线程，默认为false
     8  private boolean daemon = false;
     9  
    10  //最终执行线程任务的`Runnable`
    11  private Runnable target;
    12  
    13  //描述线程组的类
    14  private ThreadGroup group;
    15  
    16  //此线程的上下文ClassLoader
    17  private ClassLoader contextClassLoader;
    18  
    19  //所有初始化线程的数目，用于自动编号匿名线程，当没有指定线程名称时，会自动为其编号
    20  private static int threadInitNumber;
    21  
    22  //此线程请求的堆栈大小，如果创建者没有指定堆栈大小，则为0。, 虚拟机可以用这个数字做任何喜欢的事情。, 一些虚拟机会忽略它。
    23  private long stackSize;
    24  
    25  //线程id
    26  private long tid;
    27  
    28  //用于生成线程ID
    29  private static long threadSeqNumber;
    30  
    31  //线程状态
    32  private volatile int threadStatus = 0;
    33  
    34  //线程可以拥有的最低优先级
    35  public final static int MIN_PRIORITY = 1;
    36  
    37  //分配给线程的默认优先级。
    38  public final static int NORM_PRIORITY = 5;
    39  
    40  //线程可以拥有的最大优先级
    41  public final static int MAX_PRIORITY = 10;</code></pre>
<h2 id="Thread-构造方法"><a href="#Thread-构造方法" class="headerlink" title="Thread 构造方法"></a>Thread 构造方法</h2><p>了解了属性之后，看看<code>Thread</code>实例是怎么构造的？先预览下它大致有多少个构造方法：</p>
<p><img src="/assets/uploads/files/1548122247324-a77dcb75-2e68-4785-81f8-a4b242b67382-image.png" alt="a77dcb75-2e68-4785-81f8-a4b242b67382-image.png"> </p>
<p>查看每个构造方法内部源码，发现均调用的是名为<code>init</code>的私有方法，再看<code>init</code>方法有两个重载，而其核心方法如下：</p>
<pre><code> 1   /**
 2     * Initializes a Thread.
 3     *
 4     * @param g                   线程组
 5     * @param target              最终执行任务的 `run()` 方法的对象
 6     * @param name                新线程的名称
 7     * @param stackSize           新线程所需的堆栈大小，或者 0 表示要忽略此参数
 8     * @param acc                 要继承的AccessControlContext，如果为null，则为 AccessController.getContext()
 9     * @param inheritThreadLocals 如果为 true，从构造线程继承可继承的线程局部的初始值
10     */
11    private void init(ThreadGroup g, Runnable target, String name,
12                      long stackSize, AccessControlContext acc,
13                      boolean inheritThreadLocals) &#123;
14        //线程名称为空，直接抛出空指针异常
15        if (name == null) &#123;
16            throw new NullPointerException(&quot;name cannot be null&quot;);
17        &#125;
18        //初始化当前线程对象的线程名称
19        this.name = name;
20        //获取当前正在执行的线程为父线程
21        Thread parent = currentThread();
22        //获取系统安全管理器
23        SecurityManager security = System.getSecurityManager();
24        //如果线程组为空
25        if (g == null) &#123;
26            //如果安全管理器不为空
27            if (security != null) &#123;
28                //获取SecurityManager中的线程组
29                g = security.getThreadGroup();
30            &#125;
31            //如果获取的线程组还是为空
32            if (g == null) &#123;
33                //则使用父线程的线程组
34                g = parent.getThreadGroup();
35            &#125;
36        &#125;
37
38        //检查安全权限
39        g.checkAccess();
40
41        //使用安全管理器检查是否有权限
42        if (security != null) &#123;
43            if (isCCLOverridden(getClass())) &#123;
44                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
45            &#125;
46        &#125;
47
48        //线程组中标记未启动的线程数+1，这里方法是同步的，防止出现线程安全问题
49        g.addUnstarted();
50
51        //初始化当前线程对象的线程组
52        this.group = g;
53        //初始化当前线程对象的是否守护线程属性，注意到这里初始化时跟父线程一致
54        this.daemon = parent.isDaemon();
55        //初始化当前线程对象的线程优先级属性，注意到这里初始化时跟父线程一致
56        this.priority = parent.getPriority();
57        //这里初始化类加载器
58        if (security == null || isCCLOverridden(parent.getClass()))
59            this.contextClassLoader = parent.getContextClassLoader();
60        else
61            this.contextClassLoader = parent.contextClassLoader;
62        this.inheritedAccessControlContext =
63                acc != null ? acc : AccessController.getContext();
64        //初始化当前线程对象的最终执行任务对象
65        this.target = target;
66        //这里再对线程的优先级字段进行处理
67        setPriority(priority);
68        if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)
69            this.inheritableThreadLocals =
70                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
71        //初始化当前线程对象的堆栈大小
72        this.stackSize = stackSize;
73
74        //初始化当前线程对象的线程ID，该方法是同步的，内部实际上是threadSeqNumber++
75        tid = nextThreadID();
76    &#125;</code></pre>
<p>另一个重载<code>init</code>私有方法如下，实际上内部调用的是上述<code>init</code>方法：</p>
<pre><code>1   private void init(ThreadGroup g, Runnable target, String name,
2                      long stackSize) &#123;
3        init(g, target, name, stackSize, null, true);
4   &#125;</code></pre>
<p>接下来看看所有构造方法：</p>
<ol>
<li><p>空构造方法</p>
<pre><code> 1    public Thread() &#123;
 2        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
 3    &#125;</code></pre>
<p> 内部调用的是<code>init</code>第二个重载方法，参数基本都是默认值，线程名称写死为<code>&quot;Thread-&quot; + nextThreadNum()</code>格式，<code>nextThreadNum()</code>为一个同步方法，内部维护一个静态属性表示线程的初始化数量+1：</p>
<pre><code> 1   private static int threadInitNumber;
 2    private static synchronized int nextThreadNum() &#123;
 3        return threadInitNumber++;
 4    &#125;</code></pre>
<p> 与第一个构造方法区别在于可以自定义<code>Runnable</code>对象</p>
</li>
<li><p>自定义执行任务<code>Runnable</code>对象的构造方法</p>
<pre><code> 1    private static int threadInitNumber;
 2    private static synchronized int nextThreadNum() &#123;
 3        return threadInitNumber++;
 4    &#125;</code></pre>
</li>
<li><p>自定义执行任务<code>Runnable</code>对象和<code>AccessControlContext</code>对象的构造方法</p>
<pre><code> 1 Thread(Runnable target, AccessControlContext acc) &#123;
 2    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc, false);
 3 &#125;</code></pre>
</li>
<li><p>自定义线程组<code>ThreadGroup</code>和执行任务<code>Runnable</code>对象的构造方法</p>
<pre><code> 1  public Thread(ThreadGroup group, Runnable target) &#123;
 2    init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义线程名称<code>name</code>的构造方法</p>
<pre><code> 1  public Thread(String name) &#123;
 2    init(null, null, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义线程组<code>ThreadGroup</code>和线程名称<code>name</code>的构造方法</p>
<pre><code> 1  public Thread(String name) &#123;
 2     init(null, null, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义执行任务<code>Runnable</code>对象和线程名称<code>name</code>的构造方法</p>
<pre><code> 1  public Thread(Runnable target, String name) &#123;
 2     init(null, target, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>自定义线程组<code>ThreadGroup</code>和线程名称<code>name</code>和执行任务<code>Runnable</code>对象的构造方法</p>
<pre><code> 1  public Thread(ThreadGroup group, Runnable target, String name) &#123;
 2     init(group, target, name, 0);
 3  &#125;</code></pre>
</li>
<li><p>全部属性都是自定义的构造方法</p>
<pre><code> 1  public Thread(ThreadGroup group, Runnable target, String name,
 2                long stackSize) &#123;
 3     init(group, target, name, stackSize);
 4  &#125;</code></pre>
</li>
</ol>
<p><code>Thread</code>提供了非常灵活的重载构造方法，方便开发者自定义各种参数的<code>Thread</code>对象。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>这里记录一些比较常见的方法吧，对于<code>Thread</code>中存在的一些本地方法，我们暂且不用管它～</p>
<h4 id="设置线程名称"><a href="#设置线程名称" class="headerlink" title="设置线程名称"></a>设置线程名称</h4><p>设置线程名称，该方法为同步方法，为了防止出现线程安全问题，可以手动调用<code>Thread</code>的实例方法设置名称，也可以在构造<code>Thread</code>时在构造方法中传入线程名称，我们通常都是在构造参数时设置</p>
<pre><code>     1   public final synchronized void setName(String name) &#123;
     2       　　//检查安全权限
     3          checkAccess();
     4       　　//如果形参为空，抛出空指针异常
     5          if (name == null) &#123;
     6              throw new NullPointerException(&quot;name cannot be null&quot;);
     7          &#125;
     8        //给当前线程对象设置名称
     9          this.name = name;
    10          if (threadStatus != 0) &#123;
    11              setNativeName(name);
    12          &#125;
    13      &#125;</code></pre>
<h4 id="获取线程名称"><a href="#获取线程名称" class="headerlink" title="获取线程名称"></a>获取线程名称</h4><p>内部直接返回当前线程对象的名称属性</p>
<pre><code>    1  public final String getName() &#123;
    2        return name;
    3    &#125;</code></pre>
<h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><pre><code>     1  public synchronized void start() &#123;
     2      //如果不是刚创建的线程，抛出异常
     3      if (threadStatus != 0)
     4          throw new IllegalThreadStateException();
     5
     6      //通知线程组，当前线程即将启动，线程组当前启动线程数+1，未启动线程数-1
     7      group.add(this);
     8
     9      //启动标识
    10      boolean started = false;
    11      try &#123;
    12          //直接调用本地方法启动线程
    13          start0();
    14          //设置启动标识为启动成功
    15          started = true;
    16      &#125; finally &#123;
    17          try &#123;
    18              //如果启动呢失败
    19              if (!started) &#123;
    20                  //线程组内部移除当前启动的线程数量-1，同时启动失败的线程数量+1
    21                  group.threadStartFailed(this);
    22              &#125;
    23          &#125; catch (Throwable ignore) &#123;
    24              /* do nothing. If start0 threw a Throwable then
    25                it will be passed up the call stack */
    26          &#125;
    27      &#125;
    28  &#125;</code></pre>
<p>我们正常的启动线程都是调用<code>Thread</code>的<code>start()</code>方法，然后<code>Java</code>虚拟机内部会去调用<code>Thred</code>的<code>run</code>方法，可以看到<code>Thread</code>类也是实现<code>Runnable</code>接口，重写了<code>run</code>方法的：</p>
<pre><code>    1 @Override
    2 public void run() &#123;
    3     //当前执行任务的Runnable对象不为空，则调用其run方法
    4     if (target != null) &#123;
    5         target.run();
    6     &#125;
    7 &#125;</code></pre>
<p><code>Thread</code>的两种使用方式：</p>
<ul>
<li><p>  继承<code>Thread</code>类，重写<code>run</code>方法，那么此时是直接执行<code>run</code>方法的逻辑，不会使用<code>target.run();</code></p>
</li>
<li><p>  实现<code>Runnable</code>接口，重写<code>run</code>方法，因为<code>Java</code>的单继承限制，通常使用这种方式创建线程更加灵活，这里真正的执行逻辑就会交给自定义<code>Runnable</code>去实现</p>
</li>
</ul>
<h4 id="设置守护线程"><a href="#设置守护线程" class="headerlink" title="设置守护线程"></a>设置守护线程</h4><p>本质操作是设置<code>daemon</code>属性</p>
<pre><code>     1  public final void setDaemon(boolean on) &#123;
     2      //检查是否有安全权限
     3      checkAccess();
     4      //本地方法，测试此线程是否存活。, 如果一个线程已经启动并且尚未死亡，则该线程处于活动状态
     5      if (isAlive()) &#123;
     6          //如果线程先启动后再设置守护线程，将抛出异常
     7          throw new IllegalThreadStateException();
     8      &#125;
     9      //设置当前守护线程属性
    10      daemon = on;
    11  &#125;</code></pre>
<h4 id="判断线程是否为守护线程"><a href="#判断线程是否为守护线程" class="headerlink" title="判断线程是否为守护线程"></a>判断线程是否为守护线程</h4><pre><code>    1 public final boolean isDaemon() &#123;
    2     //直接返回当前对象的守护线程属性
    3     return daemon;
    4 &#125;</code></pre>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>先来个线程状态图：</p>
<p><img src="./2019-01-21_java_thread_source/java_thread_source_1.png" alt="java_thread_source_1.png"> </p>
<p>获取线程状态：</p>
<pre><code>    1 public State getState() &#123;
    2     //由虚拟机实现，获取当前线程的状态
    3     return sun.misc.VM.toThreadState(threadStatus);
    4 &#125;</code></pre>
<p>线程状态主要由内部枚举类<code>State</code>组成：</p>
<pre><code>     1  public enum State &#123;
     2
     3     NEW,
     4
     5
     6     RUNNABLE,
     7
     8
     9     BLOCKED,
    10
    11
    12     WAITING,
    13
    14
    15     TIMED_WAITING,
    16
    17
    18     TERMINATED;
    19 &#125;</code></pre>
<ul>
<li><p>  NEW：刚刚创建，尚未启动的线程处于此状态</p>
</li>
<li><p>  RUNNABLE：在Java虚拟机中执行的线程处于此状态</p>
</li>
<li><p>  BLOCKED：被阻塞等待监视器锁的线程处于此状态，比如线程在执行过程中遇到<code>synchronized</code>同步块，就会进入此状态，此时线程暂停执行，直到获得请求的锁</p>
</li>
<li><p>  WAITING：无限期等待另一个线程执行特定操作的线程处于此状态</p>
</li>
</ul>
<ul>
<li><p>  通过 wait() 方法等待的线程在等待 notify() 方法</p>
</li>
<li><p>  通过 join() 方法等待的线程则会等待目标线程的终止</p>
</li>
</ul>
<ul>
<li>  TIMED_WAITING：正在等待另一个线程执行动作，直到指定等待时间的线程处于此状态</li>
</ul>
<ul>
<li><p>  通过 wait() 方法，携带超时时间，等待的线程在等待 notify() 方法</p>
</li>
<li><p>  通过 join() 方法，携带超时时间，等待的线程则会等待目标线程的终止</p>
</li>
</ul>
<ul>
<li>  TERMINATED：已退出的线程处于此状态，此时线程无法再回到 RUNNABLE 状态</li>
</ul>
<h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p>这是一个静态的本地方法，使当前执行的线程休眠暂停执行 <code>millis</code> 毫秒，当休眠被中断时会抛出<code>InterruptedException</code>中断异常</p>
<pre><code>     1 /**
     2  * Causes the currently executing thread to sleep (temporarily cease
     3  * execution) for the specified number of milliseconds, subject to
     4  * the precision and accuracy of system timers and schedulers. The thread
     5  * does not lose ownership of any monitors.
     6  *
     7  * @param  millis
     8  *         the length of time to sleep in milliseconds
     9  *
    10  * @throws  IllegalArgumentException
    11  *          if the value of &#123;@code millis&#125; is negative
    12  *
    13  * @throws  InterruptedException
    14  *          if any thread has interrupted the current thread. The
    15  *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
    16  *          cleared when this exception is thrown.
    17  */
    18 public static native void sleep(long millis) throws InterruptedException;</code></pre>
<h4 id="检查线程是否存活"><a href="#检查线程是否存活" class="headerlink" title="检查线程是否存活"></a>检查线程是否存活</h4><p>本地方法，测试此线程是否存活。 如果一个线程已经启动并且尚未死亡，则该线程处于活动状态。</p>
<pre><code>    1  /**
    2   * Tests if this thread is alive. A thread is alive if it has
    3   * been started and has not yet died.
    4   *
    5   * @return  &lt;code&gt;true&lt;/code&gt; if this thread is alive;
    6   *          &lt;code&gt;false&lt;/code&gt; otherwise.
    7   */
    8  public final native boolean isAlive();</code></pre>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>设置线程优先级</p>
<pre><code>   1  /**
   2   * Changes the priority of this thread.
   3   * &lt;p&gt;
   4   * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
   5   * with no arguments. This may result in throwing a
   6   * &lt;code&gt;SecurityException&lt;/code&gt;.
   7   * &lt;p&gt;
   8   * Otherwise, the priority of this thread is set to the smaller of
   9   * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted
  10   * priority of the thread&#39;s thread group.
  11   *
  12   * @param newPriority priority to set this thread to
  13   * @exception  IllegalArgumentException  If the priority is not in the
  14   *               range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to
  15   *               &lt;code&gt;MAX_PRIORITY&lt;/code&gt;.
  16   * @exception  SecurityException  if the current thread cannot modify
  17   *               this thread.
  18   * @see        #getPriority
  19   * @see        #checkAccess()
  20   * @see        #getThreadGroup()
  21   * @see        #MAX_PRIORITY
  22   * @see        #MIN_PRIORITY
  23   * @see        ThreadGroup#getMaxPriority()
  24   */
  25  public final void setPriority(int newPriority) &#123;
  26      //线程组
  27      ThreadGroup g;
  28      //检查安全权限
  29      checkAccess();
  30      //检查优先级形参范围
  31      if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;
  32          throw new IllegalArgumentException();
  33      &#125;
  34      if((g = getThreadGroup()) != null) &#123;
  35          //如果优先级形参大于线程组最大线程最大优先级
  36          if (newPriority &gt; g.getMaxPriority()) &#123;
  37              //则使用线程组的优先级数据
  38              newPriority = g.getMaxPriority();
  39          &#125;
  40          //调用本地设置线程优先级方法
  41          setPriority0(priority = newPriority);
  42      &#125;
  43  &#125;</code></pre>
</li>
</ul>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>有一个<code>stop()</code>实例方法可以强制终止线程，不过这个方法因为太过于暴力，已经被标记为过时方法，不建议程序员再使用，因为<strong>强制终止线程</strong>会导致数据不一致的问题。</p>
<p>这里关于线程中断的方法涉及三个：</p>
<pre><code>    1 //实例方法，通知线程中断，设置标志位
    2 public void interrupt()&#123;&#125;
    3 //静态方法，检查当前线程的中断状态，同时会清除当前线程的中断标志位状态
    4 public static boolean interrupted()&#123;&#125;
    5 //实例方法，检查当前线程是否被中断，其实是检查中断标志位
    6 public boolean isInterrupted()&#123;&#125;</code></pre>
<p><strong>interrupt() 方法解析</strong></p>
<pre><code>     1  /**
     2   * Interrupts this thread.
     3   *
     4   * &lt;p&gt; Unless the current thread is interrupting itself, which is
     5   * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method
     6   * of this thread is invoked, which may cause a &#123;@link
     7   * SecurityException&#125; to be thrown.
     8   *
     9   * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link
    10   * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link
    11   * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;
    12   * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link
    13   * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,
    14   * methods of this class, then its interrupt status will be cleared and it
    15   * will receive an &#123;@link InterruptedException&#125;.
    16   *
    17   * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link
    18   * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;
    19   * then the channel will be closed, the thread&#39;s interrupt
    20   * status will be set, and the thread will receive a &#123;@link
    21   * java.nio.channels.ClosedByInterruptException&#125;.
    22   *
    23   * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;
    24   * then the thread&#39;s interrupt status will be set and it will return
    25   * immediately from the selection operation, possibly with a non-zero
    26   * value, just as if the selector&#39;s &#123;@link
    27   * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.
    28   *
    29   * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
    30   * status will be set. &lt;/p&gt;
    31   *
    32   * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
    33   *
    34   * @throws  SecurityException
    35   *          if the current thread cannot modify this thread
    36   *
    37   * @revised 6.0
    38   * @spec JSR-51
    39   */
    40  public void interrupt() &#123;
    41      //检查是否是自身调用
    42      if (this != Thread.currentThread())
    43          //检查安全权限,这可能导致抛出&#123;@link * SecurityException&#125;。
    44          checkAccess();
    45
    46      //同步代码块
    47      synchronized (blockerLock) &#123;
    48          Interruptible b = blocker;
    49          //检查是否是阻塞线程调用
    50          if (b != null) &#123;
    51              //设置线程中断标志位
    52              interrupt0(); 
    53              //此时抛出异常，将中断标志位设置为false,此时我们正常会捕获该异常，重新设置中断标志位
    54              b.interrupt(this);
    55              return;
    56          &#125;
    57      &#125;
    58      //如无意外，则正常设置中断标志位
    59      interrupt0();
    60  &#125;</code></pre>
<ul>
<li><p>  线程中断方法不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出啦～</p>
</li>
<li><p>  只能由自身调用，否则可能会抛出 <code>SecurityException</code></p>
</li>
<li><p>  调用中断方法是由目标线程自己决定是否中断，而如果同时调用了<code>wait</code>,<code>join</code>,<code>sleep</code>等方法，会使当前线程进入阻塞状态，此时有可能发生<code>InterruptedException</code>异常</p>
</li>
<li><p>  被阻塞的线程再调用中断方法是不合理的</p>
</li>
<li><p>  中断不活动的线程不会产生任何影响</p>
</li>
</ul>
<p>检查线程是否被中断:</p>
<pre><code>     1  /**
     2   * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
     3   * status&lt;/i&gt; of the thread is unaffected by this method.
     4
     5   测试此线程是否已被中断。, 线程的&lt;i&gt;中断*状态&lt;/ i&gt;不受此方法的影响。
     6   *
     7   * &lt;p&gt;A thread interruption ignored because a thread was not alive
     8   * at the time of the interrupt will be reflected by this method
     9   * returning false.
    10   *
    11   * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;
    12   *          &lt;code&gt;false&lt;/code&gt; otherwise.
    13   * @see     #interrupted()
    14   * @revised 6.0
    15   */
    16  public boolean isInterrupted() &#123;
    17      return isInterrupted(false);
    18  &#125;</code></pre>
<p>静态方法,会清空当前线程的中断标志位：</p>
<pre><code>     1   /**
     2     *测试当前线程是否已被中断。, 此方法清除线程的* &lt;i&gt;中断状态&lt;/ i&gt;。, 换句话说，如果要连续两次调用此方法，则* second调用将返回false（除非当前线程再次被中断，在第一次调用已清除其中断的*状态   之后且在第二次调用已检查之前）, 它）
     3     *
     4     * &lt;p&gt;A thread interruption ignored because a thread was not alive
     5     * at the time of the interrupt will be reflected by this method
     6     * returning false.
     7     *
     8     * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;
     9     *          &lt;code&gt;false&lt;/code&gt; otherwise.
    10     * @see #isInterrupted()
    11     * @revised 6.0
    12     */
    13    public static boolean interrupted() &#123;
    14        return currentThread().isInterrupted(true);
    15    &#125;</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录自己阅读<code>Thread</code>类源码的一些思考，不过对于其中用到的很多本地方法只能望而却步，还有一些代码没有看明白，暂且先这样吧，如果有不足之处，请留言告知我，谢谢！后续会在实践中对<code>Thread</code>做出更多总结记录。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/design/2019-01-05_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_3_%E5%8D%81%E4%B8%80%E7%A7%8D%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/design/2019-01-05_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_3_%E5%8D%81%E4%B8%80%E7%A7%8D%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html" class="post-title-link" itemprop="url">Java 经典设计模式（3）：十一种行为型模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-05T00:00:00+00:00">2019-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>行为型模式细分为如下11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>接下来对11种行为型模式逐个进行介绍。</p>
<h3 id="一、策略模式"><a href="#一、策略模式" class="headerlink" title="一、策略模式"></a>一、策略模式</h3><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类，视实际需求是否添加），提供辅助函数。</p>
<p>首先统一接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.behaviour;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.behaviour;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] split(String exp, String opt) &#123;</span><br><span class="line">        String array[] = exp.split(opt);</span><br><span class="line">        <span class="keyword">int</span> arrayInt[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        arrayInt[<span class="number">0</span>] = Integer.parseInt(array[<span class="number">0</span>]);</span><br><span class="line">        arrayInt[<span class="number">1</span>] = Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> arrayInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/design/2019-01-05_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_3_%E5%8D%81%E4%B8%80%E7%A7%8D%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/design/2019-01-04_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_2_%E4%B8%83%E5%A4%A7%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/design/2019-01-04_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_2_%E4%B8%83%E5%A4%A7%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.html" class="post-title-link" itemprop="url">Java经典设计模式（2）：七大结构型模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-04T00:00:00+00:00">2019-01-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>接下来我们看看结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中适配器模式主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。其中的对象的适配器模式是各种结构型模式的起源。</p>
<h2 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h2><p>适配器模式主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。有点抽象，我们来看看详细的内容。</p>
<h3 id="1-1、类的适配器模式"><a href="#1-1、类的适配器模式" class="headerlink" title="1.1、类的适配器模式"></a>1.1、类的适配器模式</h3><p>类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;this is original method!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 与原类中的方法相同 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 新类的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is the targetable method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Targetable target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.method1();</span><br><span class="line">        target.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdapterTest的运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is original method!</span><br><span class="line"><span class="keyword">this</span> is the targetable method!</span><br></pre></td></tr></table></figure>
<h2 id="1-2、对象的适配器模式"><a href="#1-2、对象的适配器模式" class="headerlink" title="1.2、对象的适配器模式"></a>1.2、对象的适配器模式</h2><p>对象的适配器模式的基本思路和类的适配器模式相同，只是将Adapter类作修改成Wrapper，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is the targetable method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        source.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Source source = <span class="keyword">new</span> Source();</span><br><span class="line">        Targetable target = <span class="keyword">new</span> Wrapper(source);</span><br><span class="line">        target.method1();</span><br><span class="line">        target.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果跟类的适配器模式例子的一样。</p>
<h2 id="1-3、接口的适配器模式"><a href="#1-3、接口的适配器模式" class="headerlink" title="1.3、接口的适配器模式"></a>1.3、接口的适配器模式</h2><p>接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行了。</p>
<p>这里看文字描述已经试够清楚的了，因此就不贴代码实例了。</p>
<h2 id="二、装饰模式"><a href="#二、装饰模式" class="headerlink" title="二、装饰模式"></a>二、装饰模式</h2><p>装饰模式：在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p>装饰模式的特点：</p>
<p>（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2） 装饰对象包含一个真实对象的引用（reference）<br>（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。继承不能做到这一点，继承的功能是静态的，不能动态增删。</p>
<p>具体看看代码实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the original method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Sourceable source;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Sourceable source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before decorator!&quot;</span>);</span><br><span class="line">        source.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;after decorator!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</span></span><br><span class="line">        <span class="comment">//（2） 装饰对象包含一个真实对象的引用（reference）</span></span><br><span class="line">        <span class="comment">//（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</span></span><br><span class="line">        <span class="comment">//（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。</span></span><br><span class="line">        <span class="comment">//    在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</span></span><br><span class="line">        <span class="comment">//    继承不能做到这一点，继承的功能是静态的，不能动态增删。</span></span><br><span class="line">        Sourceable source = <span class="keyword">new</span> Source();</span><br><span class="line">        Sourceable obj = <span class="keyword">new</span> Decorator(source);</span><br><span class="line">        obj.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before decorator!</span><br><span class="line">the original method!</span><br><span class="line">after decorator!</span><br></pre></td></tr></table></figure>

<h2 id="三、代理模式"><a href="#三、代理模式" class="headerlink" title="三、代理模式"></a>三、代理模式</h2><p>代理模式就是多一个代理类出来，替原对象进行一些操作。代理类就像中介，它比我们掌握着更多的信息。</p>
<p>具体看看代码实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the original method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        source.method();</span><br><span class="line">        atfer();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sourceable source = <span class="keyword">new</span> Proxy();</span><br><span class="line">        source.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before proxy!</span><br><span class="line">the original method!</span><br><span class="line">after proxy!</span><br></pre></td></tr></table></figure>

<p>补充：（代理模式看起来很像装饰器模式。</p>
<p>对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。</p>
<p>此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。</p>
<p>然而，实际上，在装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p>我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。 ）</p>
<h2 id="四、外观模式"><a href="#四、外观模式" class="headerlink" title="四、外观模式"></a>四、外观模式</h2><p>外观模式是为了解决类与类之间的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</p>
<p>我们以一个计算机的启动过程为例，看看如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cpu startup!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cpu shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disk</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disk startup!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disk shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;memory startup!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;memory shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> Disk disk;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">        memory = <span class="keyword">new</span> Memory();</span><br><span class="line">        disk = <span class="keyword">new</span> Disk();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start the computer!&quot;</span>);</span><br><span class="line">        cpu.startup();</span><br><span class="line">        memory.startup();</span><br><span class="line">        disk.startup();</span><br><span class="line">        System.out.println(<span class="string">&quot;start computer finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin to close the computer!&quot;</span>);</span><br><span class="line">        cpu.shutdown();</span><br><span class="line">        memory.shutdown();</span><br><span class="line">        disk.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;computer closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.startup();</span><br><span class="line">        computer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start the computer!</span><br><span class="line">cpu startup!</span><br><span class="line">memory startup!</span><br><span class="line">disk startup!</span><br><span class="line">start computer finished!</span><br><span class="line">begin to close the computer!</span><br><span class="line">cpu shutdown!</span><br><span class="line">memory shutdown!</span><br><span class="line">disk shutdown!</span><br><span class="line">computer closed!</span><br></pre></td></tr></table></figure>

<h2 id="五、桥接模式"><a href="#五、桥接模式" class="headerlink" title="五、桥接模式"></a>五、桥接模式</h2><p>在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。</p>
<p>在提出桥梁模式的时候指出，桥梁模式的用意是”将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。这句话有三个关键词，也就是抽象化、实现化和脱耦。</p>
<p>抽象化：存在于多个实体中的共同的概念性联系，就是抽象化。作为一个过程，抽象化就是忽略一些信息，从而把不同的实体当做同样的实体对待。<br>实现化：抽象化给出的具体实现，就是实现化。<br>脱耦：所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。</p>
<p>下面我们来看看代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlDriver</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;connect mysql done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DB2Driver</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;connect db2 done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.connect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Driver <span class="title">getDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driver;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(Driver driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDriverManager</span> <span class="keyword">extends</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        DriverManager driverManager = <span class="keyword">new</span> MyDriverManager();</span><br><span class="line">        Driver driver1 = <span class="keyword">new</span> MysqlDriver();</span><br><span class="line">        driverManager.setDriver(driver1);</span><br><span class="line">        driverManager.connect();</span><br><span class="line"> </span><br><span class="line">        Driver driver2 = <span class="keyword">new</span> DB2Driver();</span><br><span class="line">        driverManager.setDriver(driver2);</span><br><span class="line">        driverManager.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect mysql done!</span><br><span class="line">connect db2 done!</span><br></pre></td></tr></table></figure>
<p>如果看完代码实例还不是很理解，我们想想如下两个维度扩展：（1）假设我想加一个OracleDriver，这是一个维度，很好理解，不多解释。（2）假设我们想在连接前后固定输出点什么，我们只需要加一个MyDriverManager2，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDriverManager2</span> <span class="keyword">extends</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before connect&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.connect();</span><br><span class="line">        System.out.println(<span class="string">&quot;after connect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再将Client代码中的MyDriverManager 改成 MyDriverManager2 ，执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before connect</span><br><span class="line">connect mysql done!</span><br><span class="line">after connect</span><br><span class="line">before connect</span><br><span class="line">connect db2 done!</span><br><span class="line">after connect</span><br></pre></td></tr></table></figure>

<h2 id="六、组合模式"><a href="#六、组合模式" class="headerlink" title="六、组合模式"></a>六、组合模式</h2><p>组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。掌握组合模式的重点是要理解清楚 “部分/整体” 还有 ”单个对象“ 与 “组合对象” 的含义。</p>
<p>组合模式让你可以优化处理递归或分级数据结构。</p>
<p>《设计模式》：将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>涉及角色：</p>
<p>Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。</p>
<p>Leaf：在组合中表示叶子结点对象，叶子结点没有子结点。</p>
<p>Composite：定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</p>
<p>比如现实中公司内各部门的层级关系，请看代码：</p>
<p>Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Company company)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">romove</span><span class="params">(Company company)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Composite：定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompany</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;Company&gt; cList;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCompany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCompany</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        cList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">        cList.add(company);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(sb) + <span class="keyword">this</span>.getName());</span><br><span class="line">        <span class="keyword">for</span> (Company c : cList) &#123;</span><br><span class="line">            c.display(depth + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">romove</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">        cList.remove(company);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Leaf：在组合中表示叶子结点对象，叶子结点没有子结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HRDepartment</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HRDepartment</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(sb) + <span class="keyword">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">romove</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinanceDepartment</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinanceDepartment</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(sb) + <span class="keyword">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">romove</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company root = <span class="keyword">new</span> ConcreteCompany();</span><br><span class="line">        root.setName(<span class="string">&quot;北京总公司&quot;</span>);</span><br><span class="line">        root.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;总公司人力资源部&quot;</span>));</span><br><span class="line">        root.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;总公司财务部&quot;</span>));</span><br><span class="line">        Company shandongCom = <span class="keyword">new</span> ConcreteCompany(<span class="string">&quot;山东分公司&quot;</span>);</span><br><span class="line">        shandongCom.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;山东分公司人力资源部&quot;</span>));</span><br><span class="line">        shandongCom.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;山东分公司账务部&quot;</span>));</span><br><span class="line">        Company zaozhuangCom = <span class="keyword">new</span> ConcreteCompany(<span class="string">&quot;枣庄办事处&quot;</span>);</span><br><span class="line">        zaozhuangCom.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;枣庄办事处财务部&quot;</span>));</span><br><span class="line">        zaozhuangCom.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;枣庄办事处人力资源部&quot;</span>));</span><br><span class="line">        Company jinanCom = <span class="keyword">new</span> ConcreteCompany(<span class="string">&quot;济南办事处&quot;</span>);</span><br><span class="line">        jinanCom.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;济南办事处财务部&quot;</span>));</span><br><span class="line">        jinanCom.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;济南办事处人力资源部&quot;</span>));</span><br><span class="line">        shandongCom.add(jinanCom);</span><br><span class="line">        shandongCom.add(zaozhuangCom);</span><br><span class="line">        Company huadongCom = <span class="keyword">new</span> ConcreteCompany(<span class="string">&quot;上海华东分公司&quot;</span>);</span><br><span class="line">        huadongCom.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;上海华东分公司人力资源部&quot;</span>));</span><br><span class="line">        huadongCom.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;上海华东分公司账务部&quot;</span>));</span><br><span class="line">        Company hangzhouCom = <span class="keyword">new</span> ConcreteCompany(<span class="string">&quot;杭州办事处&quot;</span>);</span><br><span class="line">        hangzhouCom.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;杭州办事处财务部&quot;</span>));</span><br><span class="line">        hangzhouCom.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;杭州办事处人力资源部&quot;</span>));</span><br><span class="line">        Company nanjingCom = <span class="keyword">new</span> ConcreteCompany(<span class="string">&quot;南京办事处&quot;</span>);</span><br><span class="line">        nanjingCom.add(<span class="keyword">new</span> FinanceDepartment(<span class="string">&quot;南京办事处财务部&quot;</span>));</span><br><span class="line">        nanjingCom.add(<span class="keyword">new</span> HRDepartment(<span class="string">&quot;南京办事处人力资源部&quot;</span>));</span><br><span class="line">        huadongCom.add(hangzhouCom);</span><br><span class="line">        huadongCom.add(nanjingCom);</span><br><span class="line">        root.add(shandongCom);</span><br><span class="line">        root.add(huadongCom);</span><br><span class="line">        root.display(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">北京总公司</span><br><span class="line">--总公司人力资源部</span><br><span class="line">--总公司财务部</span><br><span class="line">--山东分公司</span><br><span class="line">----山东分公司人力资源部</span><br><span class="line">----山东分公司账务部</span><br><span class="line">----济南办事处</span><br><span class="line">------济南办事处财务部</span><br><span class="line">------济南办事处人力资源部</span><br><span class="line">----枣庄办事处</span><br><span class="line">------枣庄办事处财务部</span><br><span class="line">------枣庄办事处人力资源部</span><br><span class="line">--上海华东分公司</span><br><span class="line">----上海华东分公司人力资源部</span><br><span class="line">----上海华东分公司账务部</span><br><span class="line">----杭州办事处</span><br><span class="line">------杭州办事处财务部</span><br><span class="line">------杭州办事处人力资源部</span><br><span class="line">----南京办事处</span><br><span class="line">------南京办事处财务部</span><br><span class="line">------南京办事处人力资源部</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="七、享元模式"><a href="#七、享元模式" class="headerlink" title="七、享元模式"></a>七、享元模式</h2><p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p>一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<p>看下数据库连接池的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.structure;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Connection&gt; pool;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 公有属性 */</span></span><br><span class="line">    <span class="keyword">private</span> String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> poolSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConnectionPool instance = <span class="keyword">null</span>;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 构造方法，做一些初始化工作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> Vector&lt;Connection&gt;(poolSize);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(driverClassName);</span><br><span class="line">                conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">                pool.add(conn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 返回连接到连接池 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pool.add(conn);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 返回连接池中的一个数据库连接 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Connection conn = pool.get(<span class="number">0</span>);</span><br><span class="line">            pool.remove(conn);</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！</p>
<p>原文：<a target="_blank" rel="noopener" href="http://blog.csdn.net/u013142781/article/details/50821155">http://blog.csdn.net/u013142781/article/details/50821155</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/design/2019-01-03_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1_%E4%BA%94%E5%A4%A7%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/design/2019-01-03_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1_%E4%BA%94%E5%A4%A7%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.html" class="post-title-link" itemprop="url">Java 经典设计模式（1）：五大创建型模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-03 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-03T00:00:00+00:00">2019-01-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="一、概况"><a href="#一、概况" class="headerlink" title="一、概况"></a>一、概况</h2><h3 id="总体来说设计模式分为三大类："><a href="#总体来说设计模式分为三大类：" class="headerlink" title="总体来说设计模式分为三大类："></a>总体来说设计模式分为三大类：</h3><p>（1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>（2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>（3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p><img src="2019-01-03_Java%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1_%E4%BA%94%E5%A4%A7%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.png"></p>
<h2 id="二、设计模式的六大原则"><a href="#二、设计模式的六大原则" class="headerlink" title="二、设计模式的六大原则"></a>二、设计模式的六大原则</h2><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h3><p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p>
<h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h3><p>其官方描述比较抽象，可自行百度。实际上可以这样理解：<br>（1）子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。<br>（2）返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。<br>（3）还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。</p>
<p>而不能声明抛出父类没有声明的异常。</p>
<h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。</p>
<h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<h3 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h3><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="三、创建型模式"><a href="#三、创建型模式" class="headerlink" title="三、创建型模式"></a>三、创建型模式</h2><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<h3 id="3-1、工厂方法模式"><a href="#3-1、工厂方法模式" class="headerlink" title="3.1、工厂方法模式"></a>3.1、工厂方法模式</h3><p>工厂方法模式分为三种：普通工厂模式、多个工厂方法模式和静态工厂方法模式。</p>
<h3 id="3-1-1、普通工厂模式"><a href="#3-1-1、普通工厂模式" class="headerlink" title="3.1.1、普通工厂模式"></a>3.1.1、普通工厂模式</h3><p>普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassOne</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClassOne&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassTwo</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClassTwo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;One&quot;</span>.equals(type)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyClassOne();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Two&quot;</span>.equals(type)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyClassTwo();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;没有要找的类型&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyFactory factory = <span class="keyword">new</span> MyFactory();  </span><br><span class="line">        MyInterface myi = factory.produce(<span class="string">&quot;One&quot;</span>);  </span><br><span class="line">        myi.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回头来理解这句话：普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
<h3 id="3-1-2、多个工厂方法模式"><a href="#3-1-2、多个工厂方法模式" class="headerlink" title="3.1.2、多个工厂方法模式"></a>3.1.2、多个工厂方法模式</h3><p>多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。</p>
<p>直接看代码吧，我们修改MyFactory和FactoryTest如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">produceOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClassOne();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">produceTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClassTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyFactory factory = <span class="keyword">new</span> MyFactory();  </span><br><span class="line">        MyInterface myi = factory.produceOne();</span><br><span class="line">        myi.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回头来理解这句话：多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象。</p>
<h3 id="3-1-3、静态工厂方法模式"><a href="#3-1-3、静态工厂方法模式" class="headerlink" title="3.1.3、静态工厂方法模式"></a>3.1.3、静态工厂方法模式</h3><p>静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p>
<p>直接看代码吧，我们修改MyFactory和FactoryTest如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyInterface <span class="title">produceOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClassOne();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyInterface <span class="title">produceTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClassTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        MyInterface myi = MyFactory.produceOne();</span><br><span class="line">        myi.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回顾：静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p>
<h3 id="3-2、抽象工厂模式"><a href="#3-2、抽象工厂模式" class="headerlink" title="3.2、抽象工厂模式"></a>3.2、抽象工厂模式</h3><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则。</p>
<p>为解决这个问题，我们来看看抽象工厂模式：创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<p>这样就符合闭包原则了。</p>
<p>下面来看看代码：</p>
<p>MyInterface、MyClassOne、MyClassTwo不变。</p>
<p>新增如下接口和类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">produce</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryOne</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClassOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryTwo</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClassTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改测试类FactoryTest如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        Provider provider = <span class="keyword">new</span> MyFactoryOne();</span><br><span class="line">        MyInterface myi = provider.produce();</span><br><span class="line">        myi.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回顾：抽象工厂模式就是创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<h3 id="3-3、单例模式"><a href="#3-3、单例模式" class="headerlink" title="3.3、单例模式"></a>3.3、单例模式</h3><p>单例模式，不需要过多的解释。</p>
<p>直接看代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样会引发多线程问题，详细解说可以看《Java多线程编程核心技术》书中的第六章。博主之前推荐过这本书，里面有电子完整版下载地址：<a target="_blank" rel="noopener" href="http://blog.csdn.net/u013142781/article/details/50805655">http://blog.csdn.net/u013142781/article/details/50805655</a></p>
<h3 id="3-4、建造者模式"><a href="#3-4、建造者模式" class="headerlink" title="3.4、建造者模式"></a>3.4、建造者模式</h3><p>建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>字面看来非常抽象，实际上它也十分抽象！！！！</p>
<p>建造者模式通常包括下面几个角色：</p>
<p>（1）Builder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。</p>
<p>（2）ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。</p>
<p>（3）Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p>
<p>（4）Product：要创建的复杂对象。</p>
<p>在游戏开发中建造小人是经常的事了，要求是：小人必须包括头，身体和脚。</p>
<p>下面我们看看如下代码：</p>
<p>Product（要创建的复杂对象。）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String head;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="keyword">private</span> String foot;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(String head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foot;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoot</span><span class="params">(String foot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.foot = foot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder（给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">buildPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteBuilder（实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManBuilder</span> <span class="keyword">implements</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setBody(<span class="string">&quot;建造男人的身体&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setFoot(<span class="string">&quot;建造男人的脚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setHead(<span class="string">&quot;建造男人的头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">buildPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDirector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">constructPerson</span><span class="params">(PersonBuilder pb)</span> </span>&#123;</span><br><span class="line">        pb.buildHead();</span><br><span class="line">        pb.buildBody();</span><br><span class="line">        pb.buildFoot();</span><br><span class="line">        <span class="keyword">return</span> pb.buildPerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDirector pd = <span class="keyword">new</span> PersonDirector();</span><br><span class="line">        Person person = pd.constructPerson(<span class="keyword">new</span> ManBuilder());</span><br><span class="line">        System.out.println(person.getBody());</span><br><span class="line">        System.out.println(person.getFoot());</span><br><span class="line">        System.out.println(person.getHead());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾：建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h3 id="3-5、原型模式"><a href="#3-5、原型模式" class="headerlink" title="3.5、原型模式"></a>3.5、原型模式</h3><p>该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。</p>
<p>说道复制对象，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：</p>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p>
<p>写一个深浅复制的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer obj;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 浅复制 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 因为Cloneable接口是个空接口，你可以任意定义实现类的方法名</span></span><br><span class="line">        <span class="comment">// 如cloneA或者cloneB，因为此处的重点是super.clone()这句话</span></span><br><span class="line">        <span class="comment">// super.clone()调用的是Object的clone()方法</span></span><br><span class="line">        <span class="comment">// 而在Object类中，clone()是native（本地方法）的</span></span><br><span class="line">        Prototype proto = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">return</span> proto;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 深复制 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 写入当前对象的二进制流 */</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 读出二进制流产生的新对象 */</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBase</span><span class="params">(<span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Integer obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mode.create;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> Prototype();</span><br><span class="line">        prototype.setBase(<span class="number">1</span>);</span><br><span class="line">        prototype.setObj(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">/* 浅复制 */</span> </span><br><span class="line">        Prototype prototype1 = (Prototype) prototype.clone();</span><br><span class="line">        <span class="comment">/* 深复制 */</span></span><br><span class="line">        Prototype prototype2 = (Prototype) prototype.deepClone();</span><br><span class="line">        System.out.println(prototype1.getObj()==prototype1.getObj());</span><br><span class="line">        System.out.println(prototype1.getObj()==prototype2.getObj());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文：<a target="_blank" rel="noopener" href="http://blog.csdn.net/u013142781/article/details/50816245">http://blog.csdn.net/u013142781/article/details/50816245</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
