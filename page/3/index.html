<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="分享之">
<meta property="og:url" content="https://blog.fenxiangz.com/page/3/index.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="Share everything">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="JAVA,Linux,技术分享,网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.fenxiangz.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/netty/2020-05-24_Netty%20%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/netty/2020-05-24_Netty%20%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB.html" class="post-title-link" itemprop="url">Netty 笔记汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-24T00:00:00+00:00">2020-05-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="netty概要"><a href="#netty概要" class="headerlink" title="netty概要"></a>netty概要</h1><p>netty是一个异步非阻塞的通信框架（类似的框架还有mina，grizzly）。</p>
<p>底层封装了NIO2.0模块，即AIO。</p>
<p>好处：使用起来无需关注如何连接，只需关注业务逻辑处理代码，而且性能高效。遵循servlet3.0标准规范的，和tomcat等web容器不同的是异步非阻塞。tomcat容器支持最大并发量大概在800左右。而且netty也不算是web容器。</p>
<p>使用流程：<br>服务端：配置端口，长连接还是短连接（针对业务，比如聊天一般用长连接，和客户端保持连接，短连接是针对是数据量大连接次数少的情况，比如一小时上传文件4到5次），最后要调用下异步关闭，否则服务端会关闭的，一般我们是不允许服务端关闭的。</p>
<p>应用场景：作为路由网关、文件上传和下载，消息通信，心跳检测等。</p>
<p>拆包粘包问题：设置定长（一次只能传输200K以下的数据，小于200k的后面以空格补全）、设置特殊分割符（编解码）、自定义协议（实现编解码的接口，进行扩展而已）。</p>
<p>编解码（序列化）：传输数据如果为对象，实体类必须要实现serialable接口，但java序列化码流大，传输慢，性能低。可以使用joss框架Marshalling+压缩解压缩这样的方式实现。</p>
<p>业务问题：<br>1、若客户端和服务端为短连接，规定时间内（比如5秒）不传输数据默认断开，如何实现？<br>调用readTimeoutHandler(5)。<br>2、若客户端和服务端断开连接后，客户端再次发送请求，如何才能保证服务端接收到数据？<br>在客户端初始化的时候，判断下客户端是否服务端保持连接，如果没有，重新连接下。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://github.com/ouzhrm/netty_study/blob/master/README.md">https://github.com/ouzhrm/netty_study/blob/master/README.md</a></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><img src="./2020-05-24_Netty%20%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/1.png"> </p>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><h2 id="Channel-和-Unsafe"><a href="#Channel-和-Unsafe" class="headerlink" title="Channel 和 Unsafe"></a>Channel 和 Unsafe</h2><h3 id="OioServerSocketChannel-和-OioSocketChannel"><a href="#OioServerSocketChannel-和-OioSocketChannel" class="headerlink" title="OioServerSocketChannel 和 OioSocketChannel"></a>OioServerSocketChannel 和 OioSocketChannel</h3><h3 id="NioServerSocketChannel-和-NioSocketChannel"><a href="#NioServerSocketChannel-和-NioSocketChannel" class="headerlink" title="NioServerSocketChannel 和 NioSocketChannel"></a>NioServerSocketChannel 和 NioSocketChannel</h3><h2 id="ChannelPipeline-和-ChannelHandler"><a href="#ChannelPipeline-和-ChannelHandler" class="headerlink" title="ChannelPipeline 和 ChannelHandler"></a>ChannelPipeline 和 ChannelHandler</h2><h2 id="Future-和-Promise"><a href="#Future-和-Promise" class="headerlink" title="Future 和 Promise"></a>Future 和 Promise</h2><h2 id="EventLoop-和-EventLoopGroup"><a href="#EventLoop-和-EventLoopGroup" class="headerlink" title="EventLoop 和 EventLoopGroup"></a>EventLoop 和 EventLoopGroup</h2><h2 id="ServerBootstrap-和-Bootstrap"><a href="#ServerBootstrap-和-Bootstrap" class="headerlink" title="ServerBootstrap 和 Bootstrap"></a>ServerBootstrap 和 Bootstrap</h2><p>启动类</p>
<h2 id="Encode-和-Decoder"><a href="#Encode-和-Decoder" class="headerlink" title="Encode 和 Decoder"></a>Encode 和 Decoder</h2><p>协议～</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2019-05-21_java%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FDCL%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E5%8D%95%E4%BE%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/advance/2019-05-21_java%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FDCL%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E5%8D%95%E4%BE%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95.html" class="post-title-link" itemprop="url">Java 中单例模式DCL的缺陷及单例的正确写法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-21T00:00:00+00:00">2020-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先在说明单例设计模式中的 DCL 问题之前我们首先看看实现单例设计模式的两种方式：饿汉式和懒汉式。</p>
<h2 id="什么是饿汉式？"><a href="#什么是饿汉式？" class="headerlink" title="什么是饿汉式？"></a>什么是饿汉式？</h2><p>饿汉式就是不管你是否用的上，一开始就先初始化对象（也叫做提前初始化）</p>
<p><strong>代码示例：</strong></p>
<pre><code>public class EagerInitialization&#123;
    private EagerInitialization() &#123;&#125;
    private static Resource resource = new Resource();
    public static Resource getResource()&#123;
        return resource;
    &#125;
&#125;</code></pre>
<h3 id="什么是懒汉式？"><a href="#什么是懒汉式？" class="headerlink" title="什么是懒汉式？"></a>什么是懒汉式？</h3><p>懒汉式就是当你真正需要使用时才创建对象。</p>
<p>于是，关于懒汉式的问题也就随之产生了～～～</p>
<p>我们先看一下有问题的代码：</p>
<p><strong>代码示例：</strong></p>
<pre><code>public class LazyInitialization&#123;
    private static Resource resource;
    public static Resource getResource()&#123;
        if (resource == null)
            resource = new Resource();//不安全！
        return resource;
    &#125;
&#125;</code></pre>
<p>我们都知道上面的这个代码在单线程中运行是没有问题的，但是在平时的开发中常常会使用多线程，此时这个方法就会出现问题，假设有两个线程 A、B，当 A 线程满足判断还未来得及执行到 resource = new Resource() 时，线程执行资格被 B 拿走，此时线程 B 进入 getResource(), 而此时它也满足 resource 的值为 null, 于是导致最后产生两个实例。</p>
<p>针对上面的问题，于是有了相应的解决方案，即线程安全的延迟初始化，可以解决懒汉式出现的上述问题：</p>
<p><strong>代码示例：</strong></p>
<pre><code>public class LazyInitialization&#123;
    private static Resource resource;
    public synchronized static Resource getResource()&#123;
        if (resource == null)
            resource = new Resource();
        return resource;
    &#125;
&#125;</code></pre>
<p>上面代码通过使用 synchronized 关键字将 getResource 变成同步函数来保证方法的原子性，从而保证了线程安全而防止最后多个线程产生多个实例的现象。</p>
<p>我们都知道，在上述例子当中，每次在调用 getResource() 时都需要进行同步，而且在大多数时这种同步是没有必要的，并且大量无用的同步会对性能造成极大的影响。为什么呢？因为在第一次调用 getResource() 方法时就已经创建了 resource 实例了，之后 resource 就不再为空，然而之后再调用 getResource 时都需要进行同步，从而对性能造成了很大的影响。基于这些问题，一个新的方法也就产生了，这也是我们需要着重讨论的一个方法——双重检查加锁 (Double Check Locking) DCL。</p>
<h2 id="双重检查加锁-DCL-Double-Check-Locking"><a href="#双重检查加锁-DCL-Double-Check-Locking" class="headerlink" title="双重检查加锁 DCL (Double Check Locking)"></a>双重检查加锁 DCL (Double Check Locking)</h2><p>首先我们看看 DCL 的代码：</p>
<p><strong>示例代码：</strong></p>
<pre><code>public class DoubleCheckedLocking&#123;
    private static Resource resource;
    public static Resource getResource()&#123;
        if (resource == null) &#123;
            synchronized (DoubleCheckedLocking.class) &#123;
                if (resource == null)
                    resource = new Resource();
            &#125;
        &#125;
        return resource;
    &#125;
&#125;</code></pre>
<p>你可能会疑惑，这样做不是挺好么，这样就可以解决刚刚说的那些问题了么，当 resource 被实例化后再调用 getResource() 方法不就不会再进行同步，这样不就节约了资源，提升了性能么？</p>
<p>说的对，DCL 确实存在着这些优点，但是与此同时，这个方法也会带来相应的问题，因为这个方法是含有缺陷的。再次之前，先了解一下JVM内存模型。</p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>JVM模型如下图：<br><img src="./2019-05-21_java%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FDCL%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E5%8D%95%E4%BE%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/1.png"></p>
<p>Thread Stack 是线程私有的区域。他是java方法执行时的字典：它里面记录了局部变量表、 操作数栈、 动态链接、 方法出口等信息。</p>
<p>在《java虚拟机规范》一书中对这部分的描述如下：</p>
<p>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。</p>
<p>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。</p>
<p>栈帧的存储空间分配在 Java 虚拟机栈（ §2.5.5）之中，每一个栈帧都有自己的局部变量表（ Local Variables， §2.6.1）、操作数栈（ OperandStack， §2.6.2）和指向当前方法所属的类的运行时常量池（ §2.5.5）的引用。</p>
<p>Java 中某个线程在访问堆中的线程共享变量时，为了加快访问速度，提升效率，会把该变量临时拷贝一份到自己的 Thread Stack 中，并保持和堆中数据的同步。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>首先我们看到，DCL 方法包含了层判断语句，第一层判断语句用于判断 resource 对象是否为空，也就是是否被实例化，如果为空时就进入同步代码块进一步判断，问题就出在了 resource 的实例化语句 <code>resource = new Resource() </code> 上，因为这个语句实际上不是原子性的。这句话可以大致分解为如下步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 给 Resource 的实例分配内存</span><br><span class="line">2. 初始化 Resource 构造器</span><br><span class="line">3. 将 resource 实例指向分配的内存空间，此时 resource 实例就不再为空</span><br></pre></td></tr></table></figure>

<p>我们都希望这条语句的执行顺序是上述的 1——&gt;2——&gt;3，但是，由于 Java 编译器允许处理器乱序执行，以及 JDK1.5 之前 JMM（Java Memory Medel，即 Java 内存模型）中 Cache、寄存器到主内存回写顺序的规定，上面的第二点和第三点的顺序是无法保证的，也就是说，执行顺序可能是 1——&gt;2——&gt;3 也可能是 1——&gt;3——&gt;2。</p>
<p>如果有两个线程 A 和 B，如果 A 线程执行完 1 后先执行 3 然后执行 2，并且在 3 执行完毕、2 未执行之前，被切换到线程 B 上，这时候 resource 因为已经在线程 A 内执行过了第三点（jvm将未完成 Resource 构造器的值拷贝回堆中），resource 已经是非空了，所以线程 B 直接拿走 resource，然后使用，然后顺理成章地报错，而且这种难以跟踪难以重现的错误很可能会隐藏很久。</p>
<p>好了，关于 DCL 的问题阐述完了，那么这个方法既然有问题，那么该如何修改呢？</p>
<h2 id="Happen-Before-原则"><a href="#Happen-Before-原则" class="headerlink" title="Happen-Before 原则"></a>Happen-Before 原则</h2><p>通过遵守 Happen-Before 原则，解决并发顺序问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 同一个线程中，书写在前面的操作happen-before书写在后面的操作。这条规则是说，在单线程中操作间happen-before关系完全是由源代码的顺序决定的，这里的前提“在同一个线程中”是很重要的，这条规则也称为单线程规则 。这个规则多少说得有些简单了，考虑到控制结构和循环结构，书写在后面的操作可能happen-before书写在前面的操作，不过我想读者应该明白我的意思。</span><br><span class="line"></span><br><span class="line">2. 对锁的unlock操作happen-before后续的对同一个锁的lock操作。这里的“后续”指的是时间上的先后关系，unlock操作发生在退出同步块之后，lock操作发生在进入同步块之前。这是条最关键性的规则，线程安全性主要依赖于这条规则。但是仅仅是这条规则仍然不起任何作用，它必须和下面这条规则联合起来使用才显得意义重大。这里关键条件是必须对“同一个锁”的lock和unlock。</span><br><span class="line">如果操作A happen-before操作B，操作B happen-before操作C，那么操作A happen-before操作C。这条规则也称为传递规。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="通过-volatile-防止指令重排序"><a href="#通过-volatile-防止指令重排序" class="headerlink" title="通过 volatile 防止指令重排序"></a>通过 volatile 防止指令重排序</h2><p>在 JMM 的后续版本（Java 5.0 及以上）中，如果把 resource 声明为 volatile 类型，因为 volatile 可以防止指令的重排序（对 volatile 字段的写操作 happen-before 后续的对同一个字段的读操作），那么这样就可以启用 DCL，并且这种方式对性能的影响很小，因为 volatile 变量读取操作的性能通常只是略高于非 volatile 变量读取操作的性能。改进后的 DCL 方法如下代码所示</p>
<p><strong>代码示例：</strong></p>
<pre><code>public class DoubleCheckedLocking&#123;
    private static volatile Resource resource;
    public static Resource getResource&#123;
        if (resource == null) &#123;
            synchronized (DoubleCheckedLocking.class) &#123;
                if (resource == null)
                    resource = new Resource();
            &#125;
        &#125;
        return resource;
    &#125;
&#125;</code></pre>
<p>但是，DCL 的这种方法已经被广泛地遗弃了，因为促使该模式出现的驱动力（无竞争同步的执行速度很慢，以及 JVM 启动时很慢）已经不复存在，因为它不是一种高效的优化措施。延迟初始化占位类模式能带来同样的优势，并且更容易理解，延迟初始化占位类模式代码如下：</p>
<p><strong>代码示例：</strong></p>
<pre><code>public class ResourceFactory&#123;
    private static class ResourceHolder &#123;
        public static Resource resource = new Resource();
    &#125;
    public static Resource getResource()&#123;
        return ResourceHolder.resource;
    &#125;
&#125;</code></pre>
<p>关于单例和 DCL 问题就分析到这里了，在实际开发当中由于经常要考虑到代码的效率和安全性，一般使用饿汉式和延长初始化占位类模式，而延迟占位类模式更是优势明显并且容易使用和理解，是良好的单例设计模式的实现方法。</p>
<p>参考资料：</p>
<p>《java 并发编程实战》</p>
<p>关于 volatile 的问题可以参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/wxwzy738/article/details/43238089">http://blog.csdn.net/wxwzy738/article/details/43238089</a></p>
<p>关于 DCL 的其他问题可以参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/ns_code/article/details/17359719">http://blog.csdn.net/ns_code/article/details/17359719</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiyei2009/article/details/71813069">https://blog.csdn.net/qiyei2009/article/details/71813069</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013393958/article/details/70941579">https://blog.csdn.net/u013393958/article/details/70941579</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/spring/2020-05-20_SpringBoot%E6%8E%92%E5%9D%91.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/spring/2020-05-20_SpringBoot%E6%8E%92%E5%9D%91.html" class="post-title-link" itemprop="url">Spring Boot 排坑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-20T00:00:00+00:00">2020-05-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1"><a href="#1" class="headerlink" title="1"></a><strong>1</strong></h3><p><img src="./2020-05-20_SpringBoot%E6%8E%92%E5%9D%91/1.png"> </p>
<p>2.0.3 有内存暂用 不释放的问题，小版本升级到2.0.5就可以解决；</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a><strong>2</strong></h3><p>SpringBoot 2.2.x 版本有CPU增高的bug；<br>2.2.1-2.2.5 版本是会造成频繁的拿锁与解锁 ；<br>2.2.6 版本 cpu会持续增高<br>建议选择： 2.1 版本；</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a><strong>3</strong></h3><p>SpringBoot 自动依赖 mysql-connector-java 5.1.47 (有坑)，改成强制依赖 5.1.46解决；相关问题：<br><a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=92089">https://bugs.mysql.com/bug.php?id=92089</a><br><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/issues/14638">https://github.com/spring-projects/spring-boot/issues/14638</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/spring/2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/spring/2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98.html" class="post-title-link" itemprop="url">请给Sprint Boot多一些内存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-20T00:00:00+00:00">2020-05-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SprintBoot总体来说，搭建还是比较容易的，特别是SpringCloud全家桶，简称亲民微服务，但在发展趋势中，容器化技术已经成熟，面对巨耗内存的SprintBoot，小公司表示用不起。如今，很多刚诞生的JAVA微服务框架大多主打“轻量级”，主要还是因为SprintBoot太重。</p>
<h2 id="JAVA系微服务框架No1-Spring-Cloud"><a href="#JAVA系微服务框架No1-Spring-Cloud" class="headerlink" title="JAVA系微服务框架No1-Spring Cloud"></a>JAVA系微服务框架No1-Spring Cloud</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>有Spring大靠山在，更新、稳定性、成熟度的问题根本不需要考虑。在JAVA系混的技术人员大约都听说过Spring的大名吧，所以不缺程序员……，而且这入手的难度十分低，完全可以省去一个架构师。<br>但是，你必然在服务器上付出：</p>
<ul>
<li>至少一台“服务发现 ”的服务器；</li>
<li>可能有一个统一的网关Gateway;</li>
<li>可能需要一个用于“分布式配置管理”的配置中心；</li>
<li>可能进行“服务追踪”，知道我的请求从哪里来，到哪里去；</li>
<li>可能需要“集群监控”；<br>项目上线后发现，我们需要好多服务器，每次在集群中增加服务器时，都感觉心疼；</li>
</ul>
<h4 id="压测30秒"><a href="#压测30秒" class="headerlink" title="压测30秒"></a>压测30秒</h4><h5 id="压测前的内存占用"><a href="#压测前的内存占用" class="headerlink" title="压测前的内存占用"></a>压测前的内存占用</h5><p><img src="2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98/1.png"><br>如图，内存占用304M。</p>
<h5 id="压测时的内存占用"><a href="#压测时的内存占用" class="headerlink" title="压测时的内存占用"></a>压测时的内存占用</h5><p><img src="2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98/2.png"><br>如图，内存占用1520M（1.5G），CPU上升到321%</p>
<h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p><img src="2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98/3.png"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一个SprintBoot的简单应用，最少1G内存，一个业务点比较少的微服务编译后的JAR会大约50M；而SprintCloud引入的组件会相对多一些，消耗的资源也会相对更多一些。</p>
<p>启动时间大约10秒左右: <code>Started Application in 10.153 seconds (JVM running for 10.915)</code></p>
<h2 id="JAVA系响应式编程的工具包Vert-x"><a href="#JAVA系响应式编程的工具包Vert-x" class="headerlink" title="JAVA系响应式编程的工具包Vert.x"></a>JAVA系响应式编程的工具包Vert.x</h2><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>背靠Eclipse的<a target="_blank" rel="noopener" href="https://vertx.io/">Eclipse Vert.x</a>是一个用于在JVM上构建响应式应用程序的工具包。定位上与SprintBoot不冲突，甚至可以将Vert.x结合SprintBoot使用。众多Vert.x模块提供了大量微服务的组件，在很多人眼里是一种微服务架构的选择。</p>
<p>华为微服务框架<a target="_blank" rel="noopener" href="http://servicecomb.apache.org/cn/">Apache ServiceComb</a>就是以Vert.x为底层框架实现的，在”基准测试网站TechEmpower”中，Vert.x的表现也十分亮眼。</p>
<h4 id="压测30秒-1"><a href="#压测30秒-1" class="headerlink" title="压测30秒"></a>压测30秒</h4><h5 id="压测前的内存占用-1"><a href="#压测前的内存占用-1" class="headerlink" title="压测前的内存占用"></a>压测前的内存占用</h5><p><img src="2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98/4.png"><br>如图，内存占用65M。</p>
<h5 id="压测时的内存占用-1"><a href="#压测时的内存占用-1" class="headerlink" title="压测时的内存占用"></a>压测时的内存占用</h5><p><img src="2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98/5.png"><br>如图，内存占139M，CPU占2.1%，给人的感觉似乎并没有进行压测。</p>
<h5 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h5><p><img src="2020-05-20_%E8%AF%B7%E7%BB%99SprintBoot%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%86%85%E5%AD%98/6.png"></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>Vert.x单个服务打包完成后大约7M左右的JAR，不依赖Tomcat、Jetty之类的容器，直接在JVM上跑。</p>
<p>Vert.x消耗的资源很低，感觉一个1核2G的服务器已经能够部署许多个Vert.x服务。除去编码方面的问题，真心符合小项目和小模块。git市场上已经出现了基于Vert.x实现的开源网关- <a target="_blank" rel="noopener" href="https://duhua.gitee.io/vx-api-gateway-doc/">VX-API-Gateway帮助文档</a><br>对多语言支持，很适合小型项目快速上线。</p>
<p>启动时间不到1秒：<code>Started Vert.x in 0.274 seconds (JVM running for 0.274)</code></p>
<h2 id="JAVA系其他微服务框架"><a href="#JAVA系其他微服务框架" class="headerlink" title="JAVA系其他微服务框架"></a>JAVA系其他微服务框架</h2><h3 id="SparkJava"><a href="#SparkJava" class="headerlink" title="SparkJava"></a>SparkJava</h3><ul>
<li>jar比较小，大约10M</li>
<li>占内存小，大约30~60MB；</li>
<li>性能还可以，与SprintBoot相仿；</li>
</ul>
<h3 id="Micronaut"><a href="#Micronaut" class="headerlink" title="Micronaut"></a>Micronaut</h3><ul>
<li>Grails团队新宠；</li>
<li>可以用 Java、Groovy 和 Kotlin 编写的基于微服务的应用程序；</li>
<li>相比SprintBoot已经比较全面；</li>
<li>性能较优，编码方式与SprintBoot比较类似；</li>
<li>启动时间和内存消耗方面比其他框架更高效；</li>
<li>多语言；</li>
<li>依赖注入；</li>
<li>内置多种云本地功能；</li>
<li>很新，刚发布1.0.0</li>
</ul>
<h3 id="Javalin"><a href="#Javalin" class="headerlink" title="Javalin"></a>Javalin</h3><ul>
<li>上手极为容易；</li>
<li>灵活，可以兼容同步和异步两种编程思路；</li>
<li>JAR小，4～5M；</li>
<li>多语言；</li>
<li>有KOA的影子；</li>
<li>只有大约2000行源代码，源代码足够简单，可以理解和修复；</li>
<li>符合当今趋势；</li>
<li>多语言；</li>
<li>嵌入式服务器Jetty；</li>
</ul>
<h3 id="Quarkus"><a href="#Quarkus" class="headerlink" title="Quarkus"></a>Quarkus</h3><ul>
<li>启动快；</li>
<li>JAR小，大约10M；</li>
<li>文档很少；</li>
</ul>
<p>原文：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c89f266f265da2d8763b5f9">https://juejin.im/post/5c89f266f265da2d8763b5f9</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/spring/2020-11-20_SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/spring/2020-11-20_SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">Spring IOC 容器源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-20T00:00:00+00:00">2020-05-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Core/" itemprop="url" rel="index"><span itemprop="name">Spring Core</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p>
<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>
<p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>
<p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p>
<pre><code>public static void main(String[] args) &#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);
&#125;</code></pre>
<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<blockquote>
<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
</blockquote>
<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p>
<p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p>
<p><img src="./2020-11-20_SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1"></p>
<blockquote>
<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p>
<p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>
</blockquote>
<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类。</p>
<p>FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>
<p>AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>
<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>
<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>
<p>首先，定义一个接口：</p>
<pre><code>public interface MessageService &#123;
    String getMessage();
&#125;</code></pre>
<p>定义接口实现类：</p>
<pre><code>public class MessageServiceImpl implements MessageService &#123;

    public String getMessage() &#123;
        return&quot;hello world&quot;;
    &#125;
&#125;</code></pre>
<p>接下来，我们在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&gt;

    &lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;/&gt;
&lt;/beans&gt;</code></pre>
<p>这样，我们就可以跑起来了：</p>
<pre><code>public class App &#123;
    public static void main(String[] args) &#123;
        // 用我们的配置文件来启动一个 ApplicationContext
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);

        System.out.println(&quot;context 启动成功&quot;);

        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式
        MessageService messageService = context.getBean(MessageService.class);
        // 这句将输出: hello world
        System.out.println(messageService.getMessage());
    &#125;
&#125;</code></pre>
<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>
<h2 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>
<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p>
<p><img src="./2020-11-20_SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="1"></p>
<p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>
<ol>
<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>
<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>
<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>
<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>
<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li>
</ol>
<p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p>
<h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>
<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>
<pre><code>public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;
  private Resource[] configResources;

  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法
  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;
    super(parent);
  &#125;
  ...
  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
      throws BeansException &#123;

    super(parent);
    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)
    setConfigLocations(configLocations);
    if (refresh) &#123;
      refresh(); // 核心方法
    &#125;
  &#125;
    ...
&#125;</code></pre>
<p>接下来，就是 refresh()，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>
<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>
<pre><code>@Override
public void refresh() throws BeansException, IllegalStateException &#123;
   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛
   synchronized (this.startupShutdownMonitor) &#123;

      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符
      prepareRefresh();

      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，
      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，
      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean
      // 这块待会会展开说
      prepareBeanFactory(beanFactory);

      try &#123;
         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，
         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】

         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化
         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事
         postProcessBeanFactory(beanFactory);
         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法
         invokeBeanFactoryPostProcessors(beanFactory);

         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别
         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization
         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化
         registerBeanPostProcessors(beanFactory);

         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了
         initMessageSource();

         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了
         initApplicationEventMulticaster();

         // 从方法名就可以知道，典型的模板方法(钩子方法)，
         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）
         onRefresh();

         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过
         registerListeners();

         // 重点，重点，重点
         // 初始化所有的 singleton beans
         //（lazy-init 的除外）
         finishBeanFactoryInitialization(beanFactory);

         // 最后，广播事件，ApplicationContext 初始化完成
         finishRefresh();
      &#125;

      catch (BeansException ex) &#123;
         if (logger.isWarnEnabled()) &#123;
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         &#125;

         // Destroy already created singletons to avoid dangling resources.
         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源
         destroyBeans();

         // Reset &#39;active&#39; flag.
         cancelRefresh(ex);

         // 把异常往外抛
         throw ex;
      &#125;

      finally &#123;
         // Reset common introspection caches in Spring&#39;s core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      &#125;
   &#125;
&#125;</code></pre>
<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>
<h3 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p>
<pre><code>protected void prepareRefresh() &#123;
   // 记录启动时间，
   // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);

   if (logger.isInfoEnabled()) &#123;
      logger.info(&quot;Refreshing &quot; + this);
   &#125;

   // Initialize any placeholder property sources in the context environment
   initPropertySources();

   // 校验 xml 配置文件
   getEnvironment().validateRequiredProperties();

   this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();
&#125;</code></pre>
<h3 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>
<p>注意，这个方法是全文最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>
<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>
<p>// AbstractApplicationContext.java</p>
<pre><code>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;
   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等
   refreshBeanFactory();

   // 返回刚刚创建的 BeanFactory
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (logger.isDebugEnabled()) &#123;
      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
   &#125;
   return beanFactory;
&#125;</code></pre>
<p>// AbstractRefreshableApplicationContext.java 120</p>
<pre><code>@Override
protected final void refreshBeanFactory() throws BeansException &#123;
   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory
   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前
   // ApplicationContext 是否有 BeanFactory
   if (hasBeanFactory()) &#123;
      destroyBeans();
      closeBeanFactory();
   &#125;
   try &#123;
      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。
      DefaultListableBeanFactory beanFactory = createBeanFactory();
      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到
      beanFactory.setSerializationId(getId());

      // 下面这两个方法很重要，别跟丢了，具体细节之后说
      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用
      customizeBeanFactory(beanFactory);

      // 加载 Bean 到 BeanFactory 中
      loadBeanDefinitions(beanFactory);
      synchronized (this.beanFactoryMonitor) &#123;
         this.beanFactory = beanFactory;
      &#125;
   &#125;
   catch (IOException ex) &#123;
      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
   &#125;
&#125;</code></pre>
<blockquote>
<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
</blockquote>
<p>我们说说为什么选择实例化 DefaultListableBeanFactory ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p>
<p><img src="./2020-11-20_SpringIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" alt="1"></p>
<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>
<blockquote>
<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p>
<p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p>
</blockquote>
<p>在继续往下之前，我们需要先了解 BeanDefinition。我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</p>
<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>
<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以认为是 BeanDefinition 的实例。</p>
<blockquote>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
</blockquote>
<p>BeanDefinition 接口定义</p>
<p>我们来看下 BeanDefinition 的接口定义：</p>
<pre><code>public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;

   // 我们可以看到，默认只提供 sington 和 prototype 两种，
   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，
   // 不过，它们属于基于 web 的扩展。
   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;
   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;

   // 比较不重要，直接跳过吧
   int ROLE_APPLICATION = 0;
   int ROLE_SUPPORT = 1;
   int ROLE_INFRASTRUCTURE = 2;

   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍
   // 一句话就是：继承父 Bean 的配置信息而已
   void setParentName(String parentName);

   // 获取父 Bean
   String getParentName();

   // 设置 Bean 的类名称，将来是要通过反射来生成实例的
   void setBeanClassName(String beanClassName);

   // 获取 Bean 的类名称
   String getBeanClassName();


   // 设置 bean 的 scope
   void setScope(String scope);

   String getScope();

   // 设置是否懒加载
   void setLazyInit(boolean lazyInit);

   boolean isLazyInit();

   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，
   // 是 depends-on=&quot;&quot; 属性设置的值。
   void setDependsOn(String... dependsOn);

   // 返回该 Bean 的所有依赖
   String[] getDependsOn();

   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，
   // 如果根据名称注入，即使这边设置了 false，也是可以的
   void setAutowireCandidate(boolean autowireCandidate);

   // 该 Bean 是否可以注入到其他 Bean 中
   boolean isAutowireCandidate();

   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean
   void setPrimary(boolean primary);

   // 是否是 primary 的
   boolean isPrimary();

   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录
   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的
   void setFactoryBeanName(String factoryBeanName);
   // 获取工厂名称
   String getFactoryBeanName();
   // 指定工厂类中的 工厂方法名称
   void setFactoryMethodName(String factoryMethodName);
   // 获取工厂类中的 工厂方法名称
   String getFactoryMethodName();

   // 构造器参数
   ConstructorArgumentValues getConstructorArgumentValues();

   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到
   MutablePropertyValues getPropertyValues();

   // 是否 singleton
   boolean isSingleton();

   // 是否 prototype
   boolean isPrototype();

   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，
   // 常用于作为 父bean 用于继承，其实也很少用......
   boolean isAbstract();

   int getRole();
   String getDescription();
   String getResourceDescription();
   BeanDefinition getOriginatingBeanDefinition();
&#125;</code></pre>
<blockquote>
<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p>
<p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>
</blockquote>
<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>
<pre><code>customizeBeanFactory(beanFactory);
loadBeanDefinitions(beanFactory);</code></pre>
<p>虽然只有两个方法，但路还很长啊。。。</p>
<p>customizeBeanFactory</p>
<p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>
<pre><code>protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;
   if (this.allowBeanDefinitionOverriding != null) &#123;
      // 是否允许 Bean 定义覆盖
      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
   &#125;
   if (this.allowCircularReferences != null) &#123;
      // 是否允许 Bean 间的循环依赖
      beanFactory.setAllowCircularReferences(this.allowCircularReferences);
   &#125;
&#125;</code></pre>
<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>
<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>
<p>之后的源码中还会出现这两个属性，读者有个印象就可以了。</p>
<p>加载 Bean: loadBeanDefinitions</p>
<p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>
<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>
<p>// AbstractXmlApplicationContext.java 80</p>
<pre><code>/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/
@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;
   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader
   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

   // Configure the bean definition reader with this context&#39;s
   // resource loading environment.
   beanDefinitionReader.setEnvironment(this.getEnvironment());
   beanDefinitionReader.setResourceLoader(this);
   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，
   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧
   initBeanDefinitionReader(beanDefinitionReader);
   // 重点来了，继续往下
   loadBeanDefinitions(beanDefinitionReader);
&#125;</code></pre>
<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>
<p>// AbstractXmlApplicationContext.java 120</p>
<pre><code>protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;
   Resource[] configResources = getConfigResources();
   if (configResources != null) &#123;
      // 往下看
      reader.loadBeanDefinitions(configResources);
   &#125;
   String[] configLocations = getConfigLocations();
   if (configLocations != null) &#123;
      // 2
      reader.loadBeanDefinitions(configLocations);
   &#125;
&#125;

// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里
@Override
public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;
   Assert.notNull(resources, &quot;Resource array must not be null&quot;);
   int counter = 0;
   // 注意这里是个 for 循环，也就是每个文件是一个 resource
   for (Resource resource : resources) &#123;
      // 继续往下看
      counter += loadBeanDefinitions(resource);
   &#125;
   // 最后返回 counter，表示总共加载了多少的 BeanDefinition
   return counter;
&#125;

// XmlBeanDefinitionReader 303
@Override
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;
   return loadBeanDefinitions(new EncodedResource(resource));
&#125;

// XmlBeanDefinitionReader 314
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;
   Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
   if (logger.isInfoEnabled()) &#123;
      logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
   &#125;
   // 用一个 ThreadLocal 来存放配置文件资源
   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
   if (currentResources == null) &#123;
      currentResources = new HashSet&lt;EncodedResource&gt;(4);
      this.resourcesCurrentlyBeingLoaded.set(currentResources);
   &#125;
   if (!currentResources.add(encodedResource)) &#123;
      throw new BeanDefinitionStoreException(
            &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
   &#125;
   try &#123;
      InputStream inputStream = encodedResource.getResource().getInputStream();
      try &#123;
         InputSource inputSource = new InputSource(inputStream);
         if (encodedResource.getEncoding() != null) &#123;
            inputSource.setEncoding(encodedResource.getEncoding());
         &#125;
         // 核心部分是这里，往下面看
         returndoLoadBeanDefinitions(inputSource, encodedResource.getResource());
      &#125;
      finally &#123;
         inputStream.close();
      &#125;
   &#125;
   catch (IOException ex) &#123;
      throw new BeanDefinitionStoreException(
            &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
   &#125;
   finally &#123;
      currentResources.remove(encodedResource);
      if (currentResources.isEmpty()) &#123;
         this.resourcesCurrentlyBeingLoaded.remove();
      &#125;
   &#125;
&#125;

// 还在这个文件中，第 388 行
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
      throws BeanDefinitionStoreException &#123;
   try &#123;
      // 这里就不看了，将 xml 文件转换为 Document 对象
      Document doc = doLoadDocument(inputSource, resource);
      // 继续
      return registerBeanDefinitions(doc, resource);
   &#125;
   catch (...
&#125;
// 还在这个文件中，第 505 行
// 返回值：返回从当前配置文件加载了多少数量的 Bean
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;
   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
   int countBefore = getRegistry().getBeanDefinitionCount();
   // 这里
   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
   return getRegistry().getBeanDefinitionCount() - countBefore;
&#125;
// DefaultBeanDefinitionDocumentReader 90
@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;
   this.readerContext = readerContext;
   logger.debug(&quot;Loading bean definitions&quot;);
   Element root = doc.getDocumentElement();
   // 从 xml 根节点开始解析文件
   doRegisterBeanDefinitions(root);
&#125;</code></pre>
<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>
<p>doRegisterBeanDefinitions：</p>
<pre><code>// DefaultBeanDefinitionDocumentReader 116
protected void doRegisterBeanDefinitions(Element root) &#123;
   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，
   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，
   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了
   BeanDefinitionParserDelegate parent = this.delegate;
   this.delegate = createDelegate(getReaderContext(), root, parent);

   if (this.delegate.isDefaultNamespace(root)) &#123;
      // 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，
      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析
      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区
      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
      if (StringUtils.hasText(profileSpec)) &#123;
         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;
            if (logger.isInfoEnabled()) &#123;
               logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
                     &quot;] not matching: &quot; + getReaderContext().getResource());
            &#125;
            return;
         &#125;
      &#125;
   &#125;

   preProcessXml(root); // 钩子
   // 往下看
   parseBeanDefinitions(root, this.delegate);
   postProcessXml(root); // 钩子

   this.delegate = parent;
&#125;</code></pre>
<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>
<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>
<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>
<pre><code>// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，
// 其他的属于 custom 的
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;
   if (delegate.isDefaultNamespace(root)) &#123;
      NodeList nl = root.getChildNodes();
      for (int i = 0; i &lt; nl.getLength(); i++) &#123;
         Node node = nl.item(i);
         if (node instanceof Element) &#123;
            Element ele = (Element) node;
            if (delegate.isDefaultNamespace(ele)) &#123;
               // 解析 default namespace 下面的几个元素
               parseDefaultElement(ele, delegate);
            &#125;
            else &#123;
               // 解析其他 namespace 的元素
               delegate.parseCustomElement(ele);
            &#125;
         &#125;
      &#125;
   &#125;
   else &#123;
      delegate.parseCustomElement(root);
   &#125;
&#125;</code></pre>
<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>
<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p>
<blockquote>
<p>这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：</p>
<pre><code>http://www.springframework.org/schema/beans</code></pre>
<p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。</p>
<pre><code>&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd&quot;
       default-autowire=&quot;byName&quot;&gt;</code></pre>
<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p>
<p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p>
<p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>
<pre><code>&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
      xsi:schemaLocation=&quot;
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/mvc   
           http://www.springframework.org/schema/mvc/spring-mvc.xsd  
       &quot;
      default-autowire=&quot;byName&quot;&gt;</code></pre>
</blockquote>
<p>回过神来，看看处理 default 标签的方法：</p>
<pre><code>private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;
   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;
      // 处理 &lt;import /&gt; 标签
      importBeanDefinitionResource(ele);
   &#125;
   elseif (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;
      // 处理 &lt;alias /&gt; 标签定义
      // &lt;alias name=&quot;fromName&quot;alias=&quot;toName&quot;/&gt;
      processAliasRegistration(ele);
   &#125;
   elseif (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;
      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧
      processBeanDefinition(ele, delegate);
   &#125;
   elseif (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;
      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归
      doRegisterBeanDefinitions(ele);
   &#125;
&#125;</code></pre>
<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p>
<p>processBeanDefinition 解析 bean 标签</p>
<p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>
<p>// DefaultBeanDefinitionDocumentReader 298</p>
<pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;
   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看
   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);

   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的

   if (bdHolder != null) &#123;
      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      try &#123;
         // Register the final decorated instance.
         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      &#125;
      catch (BeanDefinitionStoreException ex) &#123;
         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +
               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);
      &#125;
      // Send registration event.
      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
   &#125;
&#125;</code></pre>
<p>继续往下看怎么解析之前，我们先看下 <code>&lt;bean /&gt;</code> 标签中可以定义哪些属性：<br>Property<br>class类的全限定名name可指定 id、name(用逗号、分号、空格分隔)scope作用域constructor arguments指定构造参数properties设置属性的值autowiring modeno(默认值)、byName、byType、 constructorlazy-initialization mode是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)initialization methodbean 属性设置完成后，会调用这个方法destruction methodbean 销毁后的回调方法<br>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>
<p>简单地说就是像下面这样子：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; name=&quot;name1, name2, name3&quot; class=&quot;com.javadoop.ExampleBean&quot;
      scope=&quot;singleton&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot;&gt;

    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;

    &lt;!-- property 的几种情况 --&gt;
    &lt;property name=&quot;beanOne&quot;&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;</code></pre>
<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>
<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>
<p>// BeanDefinitionParserDelegate 428</p>
<pre><code>public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;
    return parseBeanDefinitionElement(ele, null);
&#125;

public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;
   String id = ele.getAttribute(ID_ATTRIBUTE);
   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();

   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，
   // 当然，如果你不定义 name 属性的话，就是空的了
   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了
   if (StringUtils.hasLength(nameAttr)) &#123;
      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
      aliases.addAll(Arrays.asList(nameArr));
   &#125;

   String beanName = id;
   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName
   if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;
      beanName = aliases.remove(0);
      if (logger.isDebugEnabled()) &#123;
         logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +
               &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);
      &#125;
   &#125;

   if (containingBean == null) &#123;
      checkNameUniqueness(beanName, aliases, ele);
   &#125;

   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,
   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。
   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);

   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。
   if (beanDefinition != null) &#123;
      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生
      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要
      if (!StringUtils.hasText(beanName)) &#123;
         try &#123;
            if (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的
               beanName = BeanDefinitionReaderUtils.generateBeanName(
                     beanDefinition, this.readerContext.getRegistry(), true);
            &#125;
            else &#123;
               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：
               //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0
               //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl

               beanName = this.readerContext.generateBeanName(beanDefinition);

               String beanClassName = beanDefinition.getBeanClassName();
               if (beanClassName != null &amp;&amp;
                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;
                  // 把 beanClassName 设置为 Bean 的别名
                  aliases.add(beanClassName);
               &#125;
            &#125;
            if (logger.isDebugEnabled()) &#123;
               logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +
                     &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
            &#125;
         &#125;
         catch (Exception ex) &#123;
            error(ex.getMessage(), ele);
            return null;
         &#125;
      &#125;
      String[] aliasesArray = StringUtils.toStringArray(aliases);
      // 返回 BeanDefinitionHolder
      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
   &#125;

   return null;
&#125;</code></pre>
<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>
<pre><code>public AbstractBeanDefinition parseBeanDefinitionElement(
      Element ele, String beanName, BeanDefinition containingBean) &#123;

   this.parseState.push(new BeanEntry(beanName));

   String className = null;
   if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;
      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
   &#125;

   try &#123;
      String parent = null;
      if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;
         parent = ele.getAttribute(PARENT_ATTRIBUTE);
      &#125;
      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了
      AbstractBeanDefinition bd = createBeanDefinition(className, parent);

      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中
      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

      /**
       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，
       * 解析出来以后的信息都放到 bd 的属性中
       */

      // 解析 &lt;meta /&gt;
      parseMetaElements(ele, bd);
      // 解析 &lt;lookup-method /&gt;
      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
      // 解析 &lt;replaced-method /&gt;
      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
    // 解析 &lt;constructor-arg /&gt;
      parseConstructorArgElements(ele, bd);
      // 解析 &lt;property /&gt;
      parsePropertyElements(ele, bd);
      // 解析 &lt;qualifier /&gt;
      parseQualifierElements(ele, bd);

      bd.setResource(this.readerContext.getResource());
      bd.setSource(extractSource(ele));

      return bd;
   &#125;
   catch (ClassNotFoundException ex) &#123;
      error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);
   &#125;
   catch (NoClassDefFoundError err) &#123;
      error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);
   &#125;
   catch (Throwable ex) &#123;
      error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);
   &#125;
   finally &#123;
      this.parseState.pop();
   &#125;

   return null;
&#125;</code></pre>
<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>
<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>
<pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;
   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆
   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
   if (bdHolder != null) &#123;
      // 如果有自定义属性的话，进行相应的解析，先忽略
      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      try &#123;
         // 我们把这步叫做 注册Bean 吧
         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      &#125;
      catch (BeanDefinitionStoreException ex) &#123;
         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +
               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);
      &#125;
      // 注册完成后，发送事件，本文不展开说这个
      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
   &#125;
&#125;</code></pre>
<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>
<pre><code>public class BeanDefinitionHolder implements BeanMetadataElement &#123;

  private final BeanDefinition beanDefinition;

  private final String beanName;

  private final String[] aliases;
...</code></pre>
<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>
<p>下面，我们开始说说注册 Bean 吧。</p>
<p>注册 Bean</p>
<p>// BeanDefinitionReaderUtils 143</p>
<pre><code>public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException &#123;

   String beanName = definitionHolder.getBeanName();
   // 注册这个 Bean
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) &#123;
      for (String alias : aliases) &#123;
         // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，
         // 获取的时候，会先将 alias 转换为 beanName，然后再查找
         registry.registerAlias(beanName, alias);
      &#125;
   &#125;
&#125;</code></pre>
<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>
<p>// DefaultListableBeanFactory 793</p>
<pre><code>@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException &#123;

   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

   if (beanDefinition instanceof AbstractBeanDefinition) &#123;
      try &#123;
         ((AbstractBeanDefinition) beanDefinition).validate();
      &#125;
      catch (BeanDefinitionValidationException ex) &#123;
         throw new BeanDefinitionStoreException(...);
      &#125;
   &#125;

   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding
   BeanDefinition oldBeanDefinition;

   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中
   oldBeanDefinition = this.beanDefinitionMap.get(beanName);

   // 处理重复名称的 Bean 定义的情况
   if (oldBeanDefinition != null) &#123;
      if (!isAllowBeanDefinitionOverriding()) &#123;
         // 如果不允许覆盖的话，抛异常
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...
      &#125;
      elseif (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;
         // log...用框架定义的 Bean 覆盖用户自定义的 Bean 
      &#125;
      elseif (!beanDefinition.equals(oldBeanDefinition)) &#123;
         // log...用新的 Bean 覆盖旧的 Bean
      &#125;
      else &#123;
         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean
      &#125;
      // 覆盖
      this.beanDefinitionMap.put(beanName, beanDefinition);
   &#125;
   else &#123;
      // 判断是否已经有其他的 Bean 开始初始化了.
      // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，
      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans
      if (hasBeanCreationStarted()) &#123;
         // Cannot modify startup-time collection elements anymore (for stable iteration)
         synchronized (this.beanDefinitionMap) &#123;
            this.beanDefinitionMap.put(beanName, beanDefinition);
            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);
            updatedDefinitions.addAll(this.beanDefinitionNames);
            updatedDefinitions.add(beanName);
            this.beanDefinitionNames = updatedDefinitions;
            if (this.manualSingletonNames.contains(beanName)) &#123;
               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);
               updatedSingletons.remove(beanName);
               this.manualSingletonNames = updatedSingletons;
            &#125;
         &#125;
      &#125;
      else &#123;
         // 最正常的应该是进到这个分支。

         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition
         this.beanDefinitionMap.put(beanName, beanDefinition);
         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字
         this.beanDefinitionNames.add(beanName);
         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，
         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的
         // 手动指的是通过调用以下方法注册的 bean ：
         //     registerSingleton(String beanName, Object singletonObject)
         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，
         // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的
         this.manualSingletonNames.remove(beanName);
      &#125;
      // 这个不重要，在预初始化的时候会用到，不必管它。
      this.frozenBeanDefinitionNames = null;
   &#125;

   if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;
      resetBeanDefinition(beanName);
   &#125;
&#125;</code></pre>
<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<blockquote>
<p>到这里是一个分水岭，前面的内容都还算比较简单，大家要清楚地知道前面都做了哪些事情。</p>
</blockquote>
<h3 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>
<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>
<pre><code>@Override
public void refresh() throws BeansException, IllegalStateException &#123;
   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛
   synchronized (this.startupShutdownMonitor) &#123;

      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符
      prepareRefresh();

      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，
      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，
      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean
      // 这块待会会展开说
      prepareBeanFactory(beanFactory);

      try &#123;
         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，
         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】

         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化
         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事
         postProcessBeanFactory(beanFactory);
         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法
         invokeBeanFactoryPostProcessors(beanFactory);          



         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别
         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization
         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机
         registerBeanPostProcessors(beanFactory);

         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了
         initMessageSource();

         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了
         initApplicationEventMulticaster();

         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说
         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）
         onRefresh();

         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过
         registerListeners();

         // 重点，重点，重点
         // 初始化所有的 singleton beans
         //（lazy-init 的除外）
         finishBeanFactoryInitialization(beanFactory);

         // 最后，广播事件，ApplicationContext 初始化完成，不展开
         finishRefresh();
      &#125;

      catch (BeansException ex) &#123;
         if (logger.isWarnEnabled()) &#123;
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         &#125;

         // Destroy already created singletons to avoid dangling resources.
         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源
         destroyBeans();

         // Reset &#39;active&#39; flag.
         cancelRefresh(ex);

         // 把异常往外抛
         throw ex;
      &#125;

      finally &#123;
         // Reset common introspection caches in Spring&#39;s core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      &#125;
   &#125;
&#125;</code></pre>
<h3 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p>
<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>
<pre><code>/**
 * Configure the factory&#39;s standard context characteristics,
 * such as the context&#39;s ClassLoader and post-processors.
 * @param beanFactory the BeanFactory to configure
 */
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;
   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，
   // 这里设置为加载当前 ApplicationContext 类的类加载器
   beanFactory.setBeanClassLoader(getClassLoader());

   // 设置 BeanExpressionResolver
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

   // 添加一个 BeanPostProcessor，这个 processor 比较简单：
   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，
   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware
   // 注意：它不仅仅回调 ApplicationContextAware，
   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，
   // Spring 会通过其他方式来处理这些依赖。
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

   /**
    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，
    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行
    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource
    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext
    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean
    */
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);

   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，
   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它
   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，
   //    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader fortype matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   &#125;

   /**
    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，
    * 我们也可以选择覆盖
    */

   // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   &#125;
   // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   &#125;
   // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   &#125;
&#125;</code></pre>
<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>
<h3 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h3><p>我们的重点当然是 finishBeanFactoryInitialization(beanFactory); 这个巨头了，这里会负责初始化所有的 singleton beans。</p>
<p>注意，后面的描述中，我都会使用初始化或预初始化来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>
<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 ‘environment’、‘systemProperties’ 等。</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>// AbstractApplicationContext.java 834</p>
<pre><code>// 初始化剩余的 singleton beans
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;

   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了
   // 什么，看代码这里没有初始化 Bean 啊！
   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   &#125;

   // Register a default embedded value resolver if no bean post-processor
   // (such as a PropertyPlaceholderConfigurer bean) registered any before:
   // at this point, primarily for resolution in annotation attribute values.
   if (!beanFactory.hasEmbeddedValueResolver()) &#123;
      beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123;
         @Override
         public String resolveStringValue(String strVal) &#123;
            return getEnvironment().resolvePlaceholders(strVal);
         &#125;
      &#125;);
   &#125;

   // 先初始化 LoadTimeWeaverAware 类型的 Bean
   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) &#123;
      getBean(weaverAwareName);
   &#125;

   // Stop using the temporary ClassLoader fortype matching.
   beanFactory.setTempClassLoader(null);

   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，
   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。
   beanFactory.freezeConfiguration();

   // 开始初始化
   beanFactory.preInstantiateSingletons();
&#125;</code></pre>
<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>
<p>preInstantiateSingletons</p>
<p>// DefaultListableBeanFactory 728</p>
<pre><code>@Override
public void preInstantiateSingletons() throws BeansException &#123;
   if (this.logger.isDebugEnabled()) &#123;
      this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
   &#125;
   // this.beanDefinitionNames 保存了所有的 beanNames
   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);

   // 触发所有的非懒加载的 singleton beans 的初始化操作
   for (String beanName : beanNames) &#123;

      // 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，
      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);

      // 非抽象、非懒加载的 singletons。如果配置了 &#39;abstract = true&#39;，那是不需要初始化的
      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;
         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)
         if (isFactoryBean(beanName)) &#123;
            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急
            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);
            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过
            boolean isEagerInit;
            if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;
               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;
                  @Override
                  public Boolean run() &#123;
                     return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();
                  &#125;
               &#125;, getAccessControlContext());
            &#125;
            else &#123;
               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
            &#125;
            if (isEagerInit) &#123;

               getBean(beanName);
            &#125;
         &#125;
         else &#123;
            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了
            getBean(beanName);
         &#125;
      &#125;
   &#125;


   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化
   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略
   for (String beanName : beanNames) &#123;
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) &#123;
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) &#123;
            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;
               @Override
               public Object run() &#123;
                  smartSingleton.afterSingletonsInstantiated();
                  return null;
               &#125;
            &#125;, getAccessControlContext());
         &#125;
         else &#123;
            smartSingleton.afterSingletonsInstantiated();
         &#125;
      &#125;
   &#125;
&#125;</code></pre>
<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>
<p>getBean</p>
<p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>
<p>// AbstractBeanFactory 196</p>
<pre><code>@Override
public Object getBean(String name) throws BeansException &#123;
   returndoGetBean(name, null, null, false);
&#125;

// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，
// 已经初始化过了就从容器中直接返回，否则就先初始化再返回
@SuppressWarnings(&quot;unchecked&quot;)
protected &lt;T&gt; T doGetBean(
      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)
      throws BeansException &#123;
   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，
   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的
   final String beanName = transformedBeanName(name);

   // 注意跟着这个，这个是返回值
   Object bean; 

   // 检查下是不是已经创建过了
   Object sharedInstance = getSingleton(beanName);

   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，
   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean
   if (sharedInstance != null &amp;&amp; args == null) &#123;
      if (logger.isDebugEnabled()) &#123;
         if (isSingletonCurrentlyInCreation(beanName)) &#123;
            logger.debug(&quot;...&quot;);
         &#125;
         else &#123;
            logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
         &#125;
      &#125;
      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，
      // 如果是 FactoryBean 的话，返回它创建的那个实例对象
      // (FactoryBean 知识，读者若不清楚请移步附录)
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   &#125;

   else &#123;
      if (isPrototypeCurrentlyInCreation(beanName)) &#123;
         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，
         // 往往是因为陷入了循环引用
         throw new BeanCurrentlyInCreationException(beanName);
      &#125;

      // 检查一下这个 BeanDefinition 在容器中是否存在
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;
         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有
         String nameToLookup = originalBeanName(name);
         if (args != null) &#123;
            // 返回父容器的查询结果
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         &#125;
         else &#123;
            // No args -&gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         &#125;
      &#125;

      if (!typeCheckOnly) &#123;
         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。
         markBeanAsCreated(beanName);
      &#125;

      /*
       * 稍稍总结一下：
       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；
       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。
       */
      try &#123;
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);

         // 先初始化依赖的所有 Bean，这个很好理解。
         // 注意，这里的依赖指的是 depends-on 中定义的依赖
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) &#123;
            for (String dep : dependsOn) &#123;
               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了
               if (isDependent(beanName, dep)) &#123;
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);
               &#125;
               // 注册一下依赖关系
               registerDependentBean(dep, beanName);
               // 先初始化被依赖项
               getBean(dep);
            &#125;
         &#125;

         // 如果是 singleton scope 的，创建 singleton 的实例
         if (mbd.isSingleton()) &#123;
            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;
               @Override
               public Object getObject() throws BeansException &#123;
                  try &#123;
                     // 执行创建 Bean，详情后面再说
                     return createBean(beanName, mbd, args);
                  &#125;
                  catch (BeansException ex) &#123;
                     destroySingleton(beanName);
                     throw ex;
                  &#125;
               &#125;
            &#125;);
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         &#125;

         // 如果是 prototype scope 的，创建 prototype 的实例
         elseif (mbd.isPrototype()) &#123;
            // It&#39;s a prototype -&gt; create a new instance.
            Object prototypeInstance = null;
            try &#123;
               beforePrototypeCreation(beanName);
               // 执行创建 Bean
               prototypeInstance = createBean(beanName, mbd, args);
            &#125;
            finally &#123;
               afterPrototypeCreation(beanName);
            &#125;
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         &#125;

         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理
         else &#123;
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) &#123;
               throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);
            &#125;
            try &#123;
               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;
                  @Override
                  public Object getObject() throws BeansException &#123;
                     beforePrototypeCreation(beanName);
                     try &#123;
                        // 执行创建 Bean
                        return createBean(beanName, mbd, args);
                     &#125;
                     finally &#123;
                        afterPrototypeCreation(beanName);
                     &#125;
                  &#125;
               &#125;);
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            &#125;
            catch (IllegalStateException ex) &#123;
               throw new BeanCreationException(beanName,
                     &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +
                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                     ex);
            &#125;
         &#125;
      &#125;
      catch (BeansException ex) &#123;
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      &#125;
   &#125;

   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了
   if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;
      try &#123;
         return getTypeConverter().convertIfNecessary(bean, requiredType);
      &#125;
      catch (TypeMismatchException ex) &#123;
         if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);
         &#125;
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      &#125;
   &#125;
   return (T) bean;
&#125;</code></pre>
<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>
<pre><code>protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</code></pre>
<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>
<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>
<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>
<pre><code>public class MessageServiceImpl implements MessageService &#123;
    @Autowired
    private UserService userService;

    public String getMessage() &#123;
        return userService.getMessage();
    &#125;
&#125;




&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre>
<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>
<p>好了，读者要知道这么回事就可以了，继续向前。</p>
<p>// AbstractAutowireCapableBeanFactory 447</p>
<pre><code>/**
 * Central method of this class: creates a bean instance,
 * populates the bean instance, applies post-processors, etc.
 * @see #doCreateBean
 */
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;
   if (logger.isDebugEnabled()) &#123;
      logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);
   &#125;
   RootBeanDefinition mbdToUse = mbd;

   // 确保 BeanDefinition 中的 Class 被加载
   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   &#125;

   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; 
   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。
   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看
   try &#123;
      mbdToUse.prepareMethodOverrides();
   &#125;
   catch (BeanDefinitionValidationException ex) &#123;
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &quot;Validation of method overrides failed&quot;, ex);
   &#125;

   try &#123;
      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，
      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) &#123;
         return bean; 
      &#125;
   &#125;
   catch (Throwable ex) &#123;
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
   &#125;
   // 重头戏，创建 bean
   Object beanInstance = doCreateBean(beanName, mbdToUse, args);
   if (logger.isDebugEnabled()) &#123;
      logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);
   &#125;
   return beanInstance;
&#125;</code></pre>
<p>创建 Bean</p>
<p>我们继续往里看 doCreateBean 这个方法：</p>
<pre><code>/**
 * Actually create the specified bean. Pre-creation processing has already happened
 * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks.
 * &lt;p&gt;Differentiates between default bean instantiation, use of a
 * factory method, and autowiring a constructor.
 * @param beanName the name of the bean
 * @param mbd the merged bean definition for the bean
 * @param args explicit arguments to use for constructor or factory method invocation
 * @return a new instance of the bean
 * @throws BeanCreationException if the bean could not be created
 * @see #instantiateBean
 * @see #instantiateUsingFactoryMethod
 * @see #autowireConstructor
 */
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
      throws BeanCreationException &#123;

   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) &#123;
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   &#125;
   if (instanceWrapper == null) &#123;
      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   &#125;
   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;
   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
   // 类型
   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
   mbd.resolvedTargetType = beanType;

   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor
   synchronized (mbd.postProcessingLock) &#123;
      if (!mbd.postProcessed) &#123;
         try &#123;
            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         &#125;
         catch (Throwable ex) &#123;
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Post-processing of merged bean definition failed&quot;, ex);
         &#125;
         mbd.postProcessed = true;
      &#125;
   &#125;

   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) &#123;
      if (logger.isDebugEnabled()) &#123;
         logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +
               &quot;&#39; to allow for resolving potential circular references&quot;);
      &#125;
      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;
         @Override
         public Object getObject() throws BeansException &#123;
            return getEarlyBeanReference(beanName, mbd, bean);
         &#125;
      &#125;);
   &#125;

   // Initialize the bean instance.
   Object exposedObject = bean;
   try &#123;
      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值
      populateBean(beanName, mbd, instanceWrapper);
      if (exposedObject != null) &#123;
         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？
         // 这里就是处理 bean 初始化完成后的各种回调
         exposedObject = initializeBean(beanName, exposedObject, mbd);
      &#125;
   &#125;
   catch (Throwable ex) &#123;
      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;
         throw (BeanCreationException) ex;
      &#125;
      else &#123;
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
      &#125;
   &#125;

   if (earlySingletonExposure) &#123;
      // 
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) &#123;
         if (exposedObject == bean) &#123;
            exposedObject = earlySingletonReference;
         &#125;
         elseif (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) &#123;
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;
                  actualDependentBeans.add(dependentBean);
               &#125;
            &#125;
            if (!actualDependentBeans.isEmpty()) &#123;
               throw new BeanCurrentlyInCreationException(beanName,
                     &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                     &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);
            &#125;
         &#125;
      &#125;
   &#125;

   // Register bean as disposable.
   try &#123;
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   &#125;
   catch (BeanDefinitionValidationException ex) &#123;
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
   &#125;

   return exposedObject;
&#125;</code></pre>
<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>
<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。</p>
<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>
<p>创建 Bean 实例</p>
<p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>
<pre><code>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;
   // 确保已经加载了此 class
   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

   // 校验一下这个类的访问权限
   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());
   &#125;

   if (mbd.getFactoryMethodName() != null)  &#123;
      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   &#125;

   // 如果不是第一次创建，比如第二次创建 prototype bean。
   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化
   boolean resolved = false;
   boolean autowireNecessary = false;
   if (args == null) &#123;
      synchronized (mbd.constructorArgumentLock) &#123;
         if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;
            resolved = true;
            autowireNecessary = mbd.constructorArgumentsResolved;
         &#125;
      &#125;
   &#125;
   if (resolved) &#123;
      if (autowireNecessary) &#123;
         // 构造函数依赖注入
         return autowireConstructor(beanName, mbd, null, null);
      &#125;
      else &#123;
         // 无参构造函数
         return instantiateBean(beanName, mbd);
      &#125;
   &#125;

   // 判断是否采用有参构造函数
   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null ||
         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;
      // 构造函数依赖注入
      return autowireConstructor(beanName, mbd, ctors, args);
   &#125;

   // 调用无参构造函数
   return instantiateBean(beanName, mbd);
&#125;</code></pre>
<p>挑个简单的无参构造函数构造实例来看看：</p>
<pre><code>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;
   try &#123;
      Object beanInstance;
      final BeanFactory parent = this;
      if (System.getSecurityManager() != null) &#123;
         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;
            @Override
            public Object run() &#123;

               return getInstantiationStrategy().instantiate(mbd, beanName, parent);
            &#125;
         &#125;, getAccessControlContext());
      &#125;
      else &#123;
         // 实例化
         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
      &#125;
      // 包装一下，返回
      BeanWrapper bw = new BeanWrapperImpl(beanInstance);
      initBeanWrapper(bw);
      return bw;
   &#125;
   catch (Throwable ex) &#123;
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);
   &#125;
&#125;</code></pre>
<p>我们可以看到，关键的地方在于：</p>
<pre><code>beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</code></pre>
<p>这里会进行实际的实例化过程，我们进去看看:</p>
<p>// SimpleInstantiationStrategy 59</p>
<pre><code>@Override
public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;

   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,
   // 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍
   if (bd.getMethodOverrides().isEmpty()) &#123;
      Constructor&lt;?&gt; constructorToUse;
      synchronized (bd.constructorArgumentLock) &#123;
         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse == null) &#123;
            final Class&lt;?&gt; clazz = bd.getBeanClass();
            if (clazz.isInterface()) &#123;
               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
            &#125;
            try &#123;
               if (System.getSecurityManager() != null) &#123;
                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;
                     @Override
                     public Constructor&lt;?&gt; run() throws Exception &#123;
                        return clazz.getDeclaredConstructor((Class[]) null);
                     &#125;
                  &#125;);
               &#125;
               else &#123;
                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);
               &#125;
               bd.resolvedConstructorOrFactoryMethod = constructorToUse;
            &#125;
            catch (Throwable ex) &#123;
               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
            &#125;
         &#125;
      &#125;
      // 利用构造方法进行实例化
      return BeanUtils.instantiateClass(constructorToUse);
   &#125;
   else &#123;
      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。
      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持
      return instantiateWithMethodInjection(bd, beanName, owner);
   &#125;
&#125;</code></pre>
<p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p>
<p>bean 属性注入</p>
<p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p>
<p>// AbstractAutowireCapableBeanFactory 1203</p>
<pre><code>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;
   // bean 实例的所有属性都在这里了
   PropertyValues pvs = mbd.getPropertyValues();

   if (bw == null) &#123;
      if (!pvs.isEmpty()) &#123;
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
      &#125;
      else &#123;
         // Skip property population phase for null instance.
         return;
      &#125;
   &#125;

   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，
   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，
   // 我也没找到有实际的使用，所以我们暂且忽略这块吧
   boolean continueWithPropertyPopulation = true;
   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;
      for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;
         if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;
               continueWithPropertyPopulation = false;
               break;
            &#125;
         &#125;
      &#125;
   &#125;

   if (!continueWithPropertyPopulation) &#123;
      return;
   &#125;

   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;
         autowireByName(beanName, mbd, bw, newPvs);
      &#125;

      // 通过类型装配。复杂一些
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;
         autowireByType(beanName, mbd, bw, newPvs);
      &#125;

      pvs = newPvs;
   &#125;

   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

   if (hasInstAwareBpps || needsDepCheck) &#123;
      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      if (hasInstAwareBpps) &#123;
         for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;
            if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;
               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor
               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究
               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvs == null) &#123;
                  return;
               &#125;
            &#125;
         &#125;
      &#125;
      if (needsDepCheck) &#123;
         checkDependencies(beanName, mbd, filteredPds, pvs);
      &#125;
   &#125;
   // 设置 bean 实例的属性值
   applyPropertyValues(beanName, mbd, bw, pvs);
&#125;</code></pre>
<p>initializeBean</p>
<p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>
<pre><code>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;
   if (System.getSecurityManager() != null) &#123;
      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;
         @Override
         public Object run() &#123;
            invokeAwareMethods(beanName, bean);
            return null;
         &#125;
      &#125;, getAccessControlContext());
   &#125;
   else &#123;
      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调
      invokeAwareMethods(beanName, bean);
   &#125;

   Object wrappedBean = bean;
   if (mbd == null || !mbd.isSynthetic()) &#123;
      // BeanPostProcessor 的 postProcessBeforeInitialization 回调
      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   &#125;

   try &#123;
      // 处理 bean 中定义的 init-method，
      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法
      invokeInitMethods(beanName, wrappedBean, mbd);
   &#125;
   catch (Throwable ex) &#123;
      throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, &quot;Invocation of init method failed&quot;, ex);
   &#125;

   if (mbd == null || !mbd.isSynthetic()) &#123;
      // BeanPostProcessor 的 postProcessAfterInitialization 回调
      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   &#125;
   return wrappedBean;
&#125;</code></pre>
<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="id-和-name"><a href="#id-和-name" class="headerlink" title="id 和 name"></a>id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>
<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>
<pre><code>beanFactory.getBean(&quot;beanName or alias&quot;);</code></pre>
<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>
<pre><code>&lt;bean id=&quot;messageService&quot; name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>
<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>
<pre><code>&lt;bean name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre>
<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>
<pre><code>&lt;bean class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>
<p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p>
<p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p>
<pre><code>&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</code></pre>
<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>
<h3 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>
<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>
<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>
<p>添加这两个属性的作者 Juergen Hoeller 在这个 <a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SPR-4374">jira</a> 的讨论中说明了怎么配置这两个属性。</p>
<pre><code>public class NoBeanOverridingContextLoader extends ContextLoader &#123;

  @Override
  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123;
    super.customizeContext(servletContext, applicationContext);
    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;
    arac.setAllowBeanDefinitionOverriding(false);
  &#125;
&#125;




public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123;

  @Override
  protected ContextLoader createContextLoader() &#123;
    return new NoBeanOverridingContextLoader();
  &#125;

&#125;




&lt;listener&gt;
    &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt;  
&lt;/listener&gt;</code></pre>
<p>如果以上方式不能满足你的需求，请参考这个链接：<a target="_blank" rel="noopener" href="http://blog.csdn.net/zgmzyr/article/details/39380477">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p>
<h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>
<pre><code>&lt;beans profile=&quot;development&quot;
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
    &lt;/jdbc:embedded-database&gt;
&lt;/beans&gt;




&lt;beans profile=&quot;production&quot;
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
&lt;/beans&gt;</code></pre>
<p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p>
<p>当然，我们也可以在一个配置文件中使用：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;beans profile=&quot;development&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;</code></pre>
<p>理解起来也很简单吧。</p>
<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>
<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>
<p>最简单的方式莫过于在程序启动的时候指定：</p>
<pre><code>-Dspring.profiles.active=&quot;profile1,profile2&quot;</code></pre>
<blockquote>
<p>profile 可以激活多个</p>
</blockquote>
<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>
<pre><code>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh(); // 重启</code></pre>
<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>
<pre><code>java -Dspring.profiles.active=prod -jar JavaDoop.jar</code></pre>
<p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p>
<h3 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>
<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>
<p>静态工厂：</p>
<pre><code>&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;




public class ClientService &#123;
    private static ClientService clientService = new ClientService();
    private ClientService() &#123;&#125;

    // 静态方法
    public static ClientService createInstance() &#123;
        return clientService;
    &#125;
&#125;</code></pre>
<p>实例工厂：</p>
<pre><code>&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

&lt;bean id=&quot;accountService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createAccountServiceInstance&quot;/&gt;




public class DefaultServiceLocator &#123;

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() &#123;
        return clientService;
    &#125;

    public AccountService createAccountServiceInstance() &#123;
        return accountService;
    &#125;
&#125;</code></pre>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>
<pre><code>public interface FactoryBean&lt;T&gt; &#123;
    T getObject() throws Exception;
    Class&lt;T&gt; getObjectType();
    boolean isSingleton();
&#125;




public class Person &#123; 
    private Car car ;
    private void setCar(Car car)&#123; this.car = car;  &#125;  
&#125;</code></pre>
<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>
<pre><code>public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123;
    private String make; 
    private int year ;

    public void setMake(String m)&#123; this.make =m ; &#125;

    public void setYear(int y)&#123; this.year = y; &#125;

    public Car getObject()&#123; 
      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种
      CarBuilder cb = CarBuilder.car();

      if(year!=0) cb.setYear(this.year);
      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); 
      return cb.factory(); 
    &#125;

    public Class&lt;Car&gt; getObjectType() &#123; return Car.class ; &#125; 

    public boolean isSingleton() &#123; returnfalse; &#125;
&#125;</code></pre>
<p>我们看看装配的时候是怎么配置的：</p>
<pre><code>&lt;bean class = &quot;com.javadoop.MyCarFactoryBean&quot; id = &quot;car&quot;&gt;
  &lt;property name = &quot;make&quot; value =&quot;Honda&quot;/&gt;
  &lt;property name = &quot;year&quot; value =&quot;1984&quot;/&gt;
&lt;/bean&gt;
&lt;bean class = &quot;com.javadoop.Person&quot; id = &quot;josh&quot;&gt;
  &lt;property name = &quot;car&quot; ref = &quot;car&quot;/&gt;
&lt;/bean&gt;</code></pre>
<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>
<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？</p>
<pre><code>@Configuration 
public class CarConfiguration &#123; 

    @Bean 
    public MyCarFactoryBean carFactoryBean()&#123; 
      MyCarFactoryBean cfb = new MyCarFactoryBean();
      cfb.setMake(&quot;Honda&quot;);
      cfb.setYear(1984);
      return cfb;
    &#125;

    @Bean
    public Person aPerson()&#123; 
    Person person = new Person();
      // 注意这里的不同
    person.setCar(carFactoryBean().getObject());
    return person; 
    &#125; 
&#125;</code></pre>
<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>
<h3 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h3><p>有以下四种方案：</p>
<pre><code>&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;




public class AnotherExampleBean implements InitializingBean &#123;

    public void afterPropertiesSet() &#123;
        // do some initialization work
    &#125;
&#125;




@Bean(initMethod = &quot;init&quot;)
public Foo foo() &#123;
    return new Foo();
&#125;




@PostConstruct
public void init() &#123;

&#125;</code></pre>
<h3 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h3><pre><code>&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;




public class AnotherExampleBean implements DisposableBean &#123;

    public void destroy() &#123;
        // do some destruction work (like releasing pooled connections)
    &#125;
&#125;




@Bean(destroyMethod = &quot;cleanup&quot;)
public Bar bar() &#123;
    return new Bar();
&#125;




@PreDestroy
public void cleanup() &#123;

&#125;</code></pre>
<h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p>
<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>
<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>
<pre><code>&lt;bean id=&quot;conversionService&quot;
  class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
  &lt;property name=&quot;converters&quot;&gt;
    &lt;list&gt;
      &lt;bean class=&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>
<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>
<p>来看一个很简单的例子，这样比什么都管用。</p>
<pre><code>public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;

    @Override
    public Date convert(String source) &#123;
        try &#123;
            return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;);
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;</code></pre>
<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>
<h3 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p>
<pre><code>RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</code></pre>
<p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>
<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>
<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>
<p>看如下一个例子:</p>
<pre><code>&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot; class=&quot;org.springframework.beans.TestBean&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithDifferentClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;

    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
&lt;/bean&gt;</code></pre>
<p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>
<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>
<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>
<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>
<pre><code>&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;</code></pre>
<h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>
<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>
<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>
<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>
<p>lookup-method</p>
<p>我们来看一下 Spring Reference 中提供的一个例子：</p>
<pre><code>package fiona.apple;

// no more Spring imports!

public abstract class CommandManager &#123;

    public Object process(Object commandState) &#123;
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    &#125;

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
&#125;</code></pre>
<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>
<pre><code>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;</code></pre>
<p>Spring 采用 CGLIB 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>
<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>
<pre><code>public abstract class CommandManager &#123;

    public Object process(Object commandState) &#123;
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    &#125;

    @Lookup(&quot;myCommand&quot;)
    protected abstract Command createCommand();
&#125;</code></pre>
<blockquote>
<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p>
</blockquote>
<p>甚至，我们可以像下面这样：</p>
<pre><code>public abstract class CommandManager &#123;

    public Object process(Object commandState) &#123;
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    &#125;

    @Lookup
    protected abstract MyCommand createCommand();
&#125;</code></pre>
<blockquote>
<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>
</blockquote>
<p>replaced-method</p>
<p>记住它的功能，就是替换掉 bean 中的一些方法。</p>
<pre><code>public class MyValueCalculator &#123;

    public String computeValue(String input) &#123;
        // some real code...
    &#125;

    // some other methods...
&#125;</code></pre>
<p>方法覆写，注意要实现 MethodReplacer 接口：</p>
<pre><code>public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123;

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    &#125;
&#125;</code></pre>
<p>配置也很简单：</p>
<pre><code>&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;</code></pre>
<blockquote>
<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>
</blockquote>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>
<pre><code>public interface BeanPostProcessor &#123;

   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;

   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;

&#125;</code></pre>
<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>
<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>
<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>
<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>
<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>
<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>
<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按理说，总结应该写在附录前面，我就不讲究了。</p>
<p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p>
<p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p>
<p>（全文完）</p>
<p>转载自： <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903694039793672">https://juejin.cn/post/6844903694039793672</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2020-05-02_java_juc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/advance/2020-05-02_java_juc.html" class="post-title-link" itemprop="url">JUC 概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-02T00:00:00+00:00">2020-05-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。</p>
<h1 id="一、volatile关键字与内存可见性"><a href="#一、volatile关键字与内存可见性" class="headerlink" title="一、volatile关键字与内存可见性"></a>一、volatile关键字与内存可见性</h1><p><strong>1、内存可见性：</strong></p>
<p>先来看看下面的一段代码：</p>
<pre><code>public class TestVolatile &#123;
    public static void main(String[] args)&#123; //这个线程是用来读取flag的值的
        ThreadDemo threadDemo = new ThreadDemo();
        Thread thread = new Thread(threadDemo);
        thread.start();
        while (true)&#123;
            if (threadDemo.isFlag())&#123;
                System.out.println(&quot;主线程读取到的flag = &quot; + threadDemo.isFlag());
                break;
            &#125;
        &#125;
    &#125;
&#125;

@Data
class ThreadDemo implements Runnable&#123; //这个线程是用来修改flag的值的
    public  boolean flag = false;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        flag = true;
        System.out.println(&quot;ThreadDemo线程修改后的flag = &quot; + isFlag());
    &#125;
&#125;</code></pre>
<p>这段代码很简单，就是一个ThreadDemo类继承Runnable创建一个线程。它有一个成员变量flag为false，然后重写run方法，在run方法里面将flag改为true，同时还有一条输出语句。然后就是main方法主线程去读取flag。如果flag为true，就会break掉while循环，否则就是死循环。按道理，下面那个线程将flag改为true了，主线程读取到的应该也是true，循环应该会结束。看看运行结果：</p>
<p>从图中可以看到，该程序并没有结束，也就是死循环。说明主线程读取到的flag还是false，可是另一个线程明明将flag改为true了，而且打印出来了，这是什么原因呢？这就是内存可见性问题。</p>
<ul>
<li>内存可见性问题：当多个线程操作共享数据时，彼此不可见。</li>
</ul>
<p>看下图理解上述代码：</p>
<p>要解决这个问题，可以加锁。如下：</p>
<pre><code>while (true)&#123;
        synchronized (threadDemo)&#123;
            if (threadDemo.isFlag())&#123;
                System.out.println(&quot;主线程读取到的flag = &quot; + threadDemo.isFlag());
                break;
            &#125;
        &#125;
 &#125;</code></pre>
<p>加了锁，就可以让while循环每次都从主存中去读取数据，这样就能读取到true了。但是一加锁，每次只能有一个线程访问，当一个线程持有锁时，其他的就会阻塞，效率就非常低了。不想加锁，又要解决内存可见性问题，那么就可以使用volatile关键字。</p>
<p><strong>2、volatile关键字：</strong></p>
<ul>
<li>用法：</li>
</ul>
<p>volatile关键字：当多个线程操作共享数据时，可以保证内存中的数据可见。用这个关键字修饰共享数据，就会及时的把线程缓存中的数据刷新到主存中去，也可以理解为，就是直接操作主存中的数据。所以在不使用锁的情况下，可以使用volatile。如下：</p>
<pre><code>public  volatile boolean flag = false;</code></pre>
<p>这样就可以解决内存可见性问题了。</p>
<ul>
<li>volatile和synchronized的区别：     </li>
</ul>
<p>volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。     </p>
<p>volatile不具备原子性。</p>
<h1 id="二、原子性"><a href="#二、原子性" class="headerlink" title="二、原子性"></a>二、原子性</h1><p><strong>1、理解原子性：</strong></p>
<p>上面说到volatile不具备原子性，那么原子性到底是什么呢？先看如下代码：</p>
<pre><code>public class TestIcon &#123;
    public static void main(String[] args)&#123;
        AtomicDemo atomicDemo = new AtomicDemo();
        for (int x = 0;x &lt; 10; x++)&#123;
            new Thread(atomicDemo).start();
        &#125;
    &#125;
&#125;

class AtomicDemo implements Runnable&#123;
    private int i = 0;
    public int getI()&#123;
        return i++;
    &#125;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(getI());
    &#125;
&#125;</code></pre>
<p>这段代码就是在run方法里面让i++，然后启动十个线程去访问。看看结果：</p>
<p>可以发现，出现了重复数据。明显产生了多线程安全问题，或者说原子性问题。所谓原子性就是操作不可再细分，而i++操作分为读改写三步，如下：</p>
<pre><code>int temp = i;
i = i+1;
i = temp;</code></pre>
<p>所以i++明显不是原子操作。上面10个线程进行i++时，内存图解如下：</p>
<p>看到这里，好像和上面的内存可见性问题一样。是不是加个volatile关键字就可以了呢？其实不是的，因为加了volatile，只是相当于所有线程都是在主存中操作数据而已，但是不具备互斥性。比如两个线程同时读取主存中的0，然后又同时自增，同时写入主存，结果还是会出现重复数据。</p>
<p><strong>2、原子变量：</strong></p>
<p>JDK 1.5之后，Java提供了原子变量，在java.util.concurrent.atomic包下。原子变量具备如下特点：</p>
<ul>
<li>有volatile保证内存可见性。</li>
<li>用CAS算法保证原子性。</li>
</ul>
<p><strong>3、CAS算法：</strong></p>
<p>CAS算法是计算机硬件对并发操作共享数据的支持，CAS包含3个操作数：</p>
<ul>
<li>内存值V</li>
<li>预估值A</li>
<li>更新值B</li>
</ul>
<p>当且仅当V==B时，才会把B的值赋给V，即V = B，否则不做任何操作。就上面的i++问题，CAS算法是这样处理的：首先V是主存中的值0，然后预估值A也是0，因为此时还没有任何操作，这时V=B，所以进行自增，同时把主存中的值变为1。如果第二个线程读取到主存中的还是0也没关系，因为此时预估值已经变成1，V不等于B，所以不进行任何操作。</p>
<p><strong>4、使用原子变量改进i++问题：</strong></p>
<p>原子变量用法和包装类差不多，如下：</p>
<pre><code> //private int i = 0;
 AtomicInteger i = new AtomicInteger();
 public int getI()&#123;
     return i.getAndIncrement();
 &#125;</code></pre>
<p>只改这两处即可。</p>
<h1 id="三、锁分段机制"><a href="#三、锁分段机制" class="headerlink" title="三、锁分段机制"></a>三、锁分段机制</h1><p>JDK 1.5之后，在java.util.concurrent包中提供了多种并发容器类来改进同步容器类的性能。其中最主要的就是ConcurrentHashMap。</p>
<p><strong>1、ConcurrentHashMap：</strong></p>
<p>ConcurrentHashMap就是一个线程安全的hash表。我们知道HashMap是线程不安全的，Hash Table加了锁，是线程安全的，因此它效率低。HashTable加锁就是将整个hash表锁起来，当有多个线程访问时，同一时间只能有一个线程访问，并行变成串行，因此效率低。所以JDK1.5后提供了ConcurrentHashMap，它采用了锁分段机制。     </p>
<p>如上图所示，ConcurrentHashMap默认分成了16个segment，每个Segment都对应一个Hash表，且都有独立的锁。所以这样就可以每个线程访问一个Segment，就可以并行访问了，从而提高了效率。这就是锁分段。<strong>但是，</strong>java 8 又更新了，不再采用锁分段机制，也采用CAS算法了。</p>
<p><strong>2、用法:</strong></p>
<p>java.util.concurrent包还提供了设计用于多线程上下文中的 Collection 实现： ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给 定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap， ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远 大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。下面看看部分用法：</p>
<pre><code>public class TestConcurrent &#123;
    public static void main(String[] args)&#123;
        ThreadDemo2 threadDemo2 = new ThreadDemo2();
           for (int i=0;i&lt;10;i++)&#123;
               new Thread(threadDemo2).start();
           &#125;
    &#125;
&#125;
//10个线程同时访问
class ThreadDemo2 implements Runnable&#123;
    private static List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());//普通做法
    static &#123;
        list.add(&quot;aaa&quot;);
        list.add(&quot;bbb&quot;);
        list.add(&quot;ccc&quot;);
    &#125;
    @Override
    public void run() &#123;
        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext())&#123;
            System.out.println(iterator.next());//读
            list.add(&quot;ddd&quot;);//写
        &#125;
    &#125;
&#125;</code></pre>
<p>10个线程并发访问这个集合，读取集合数据的同时再往集合中添加数据。运行这段代码会报错，并发修改异常。</p>
<p>将创建集合方式改成：</p>
<pre><code>private static CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></pre>
<p>这样就不会有并发修改异常了。因为这个是写入并复制，每次生成新的，所以如果添加操作比较多的话，开销非常大，适合迭代操作比较多的时候使用。</p>
<h1 id="四、闭锁"><a href="#四、闭锁" class="headerlink" title="四、闭锁"></a>四、闭锁</h1><p>java.util.concurrent包中提供了多种并发容器类来改进同步容器的性能。ContDownLatch是一个同步辅助类，在完成某些运算时，只有其他所有线程的运算全部完成，当前运算才继续执行，这就叫闭锁。看下面代码：</p>
<pre><code>public class TestCountDownLatch &#123;
    public static void main(String[] args)&#123;
        LatchDemo ld = new LatchDemo();
        long start = System.currentTimeMillis();
        for (int i = 0;i&lt;10;i++)&#123;
            new Thread(ld).start();
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时间为：&quot;+(end - start)+&quot;秒&quot;);
    &#125;
&#125;

class LatchDemo implements Runnable&#123;
    private CountDownLatch latch;
    public LatchDemo()&#123;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0;i&lt;5000;i++)&#123;
            if (i % 2 == 0)&#123;//50000以内的偶数
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>这段代码就是10个线程同时去输出5000以内的偶数，然后在主线程那里计算执行时间。其实这是计算不了那10个线程的执行时间的，因为主线程与这10个线程也是同时执行的，可能那10个线程才执行到一半，主线程就已经输出“耗费时间为x秒”这句话了。所有要想计算这10个线程执行的时间，就得让主线程先等待，等10个分线程都执行完了才能执行主线程。这就要用到闭锁。看如何使用：</p>
<pre><code>public class TestCountDownLatch &#123;
    public static void main(String[] args) &#123;
        final CountDownLatch latch = new CountDownLatch(10);//有多少个线程这个参数就是几
        LatchDemo ld = new LatchDemo(latch);
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(ld).start();
        &#125;
        try &#123;
            latch.await();//这10个线程执行完之前先等待
        &#125; catch (InterruptedException e) &#123;
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时间为：&quot; + (end - start));
    &#125;
&#125;

class LatchDemo implements Runnable &#123;
    private CountDownLatch latch;
    public LatchDemo(CountDownLatch latch) &#123;
        this.latch = latch;
    &#125;
    @Override
    public void run() &#123;
        synchronized (this) &#123;
            try &#123;
                for (int i = 0; i &lt; 50000; i++) &#123;
                    if (i % 2 == 0) &#123;//50000以内的偶数
                        System.out.println(i);
                    &#125;
                &#125;
            &#125; finally &#123;
                latch.countDown();//每执行完一个就递减一个
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>如上代码，主要就是用<code>latch.countDown()</code>和<code>latch.await()</code>实现闭锁，详细请看上面注释即可。</p>
<h1 id="五、创建线程的方式-—-实现Callable接口"><a href="#五、创建线程的方式-—-实现Callable接口" class="headerlink" title="五、创建线程的方式 — 实现Callable接口"></a>五、创建线程的方式 — 实现Callable接口</h1><p>直接看代码：</p>
<pre><code>public class TestCallable &#123;
    public static void main(String[] args)&#123;
        CallableDemo callableDemo = new CallableDemo();
        //执行callable方式，需要FutureTask实现类的支持，用来接收运算结果
        FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(callableDemo);
        new Thread(result).start();
        //接收线程运算结果
        try &#123;
            Integer sum = result.get();//当上面的线程执行完后，才会打印结果。跟闭锁一样。所有futureTask也可以用于闭锁
            System.out.println(sum);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

class CallableDemo implements Callable&lt;Integer&gt;&#123;
    @Override
    public Integer call() throws Exception &#123;
       int sum = 0;
       for (int i = 0;i&lt;=100;i++)&#123;
           sum += i;
       &#125;
       return sum;
    &#125;
&#125;</code></pre>
<p>现在Callable接口和实现Runable接口的区别就是，Callable带泛型，其call方法有返回值。使用的时候，需要用FutureTask来接收返回值。而且它也要等到线程执行完调用get方法才会执行，也可以用于闭锁操作。</p>
<h1 id="六、Lock同步锁"><a href="#六、Lock同步锁" class="headerlink" title="六、Lock同步锁"></a>六、Lock同步锁</h1><p>在JDK1.5之前，解决多线程安全问题有两种方式(sychronized隐式锁)：</p>
<ul>
<li>同步代码块</li>
<li>同步方法</li>
</ul>
<p>在JDK1.5之后，出现了更加灵活的方式(Lock显式锁)：</p>
<ul>
<li>同步锁</li>
</ul>
<p>Lock需要通过lock()方法上锁，通过unlock()方法释放锁。为了保证锁能释放，所有unlock方法一般放在finally中去执行。</p>
<p>再来看一下卖票案例：</p>
<pre><code>public class TestLock &#123;
    public static void main(String[] args) &#123;
        Ticket td = new Ticket();
        new Thread(td, &quot;窗口1&quot;).start();
        new Thread(td, &quot;窗口2&quot;).start();
        new Thread(td, &quot;窗口3&quot;).start();
    &#125;
&#125;

class Ticket implements Runnable &#123;
    private int ticket = 100;
    @Override
    public void run() &#123;
        while (true) &#123;
            if (ticket &gt; 0) &#123;
                try &#123;
                    Thread.sleep(200);
                &#125; catch (Exception e) &#123;
                &#125;
                System.out.println(Thread.currentThread().getName() + &quot;完成售票，余票为：&quot; + (--ticket));
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>多个线程同时操作共享数据ticket，所以会出现线程安全问题。会出现同一张票卖了好几次或者票数为负数的情况。以前用同步代码块和同步方法解决，现在看看用同步锁怎么解决。</p>
<pre><code>class Ticket implements Runnable &#123;
    private Lock lock = new ReentrantLock();//创建lock锁
    private int ticket = 100;
    @Override
    public void run() &#123;
        while (true) &#123;
            lock.lock();//上锁
            try &#123;
                if (ticket &gt; 0) &#123;
                    try &#123;
                        Thread.sleep(200);
                    &#125; catch (Exception e) &#123;
                    &#125;
                    System.out.println(Thread.currentThread().getName() + &quot;完成售票，余票为：&quot; + (--ticket));
                &#125;
            &#125;finally &#123;
                lock.unlock();//释放锁
            &#125;

        &#125;
    &#125;
&#125;</code></pre>
<p>直接创建lock对象，然后用lock()方法上锁，最后用unlock()方法释放锁即可。</p>
<h1 id="七、等待唤醒机制"><a href="#七、等待唤醒机制" class="headerlink" title="七、等待唤醒机制"></a>七、等待唤醒机制</h1><p><strong>1、虚假唤醒问题：</strong></p>
<p>生产消费模式是等待唤醒机制的一个经典案例，看下面的代码：</p>
<pre><code>public class TestProductorAndconsumer &#123;
    public static void main(String[] args)&#123;
           Clerk clerk = new Clerk();
           Productor productor = new Productor(clerk);
           Consumer consumer = new Consumer(clerk);
           new Thread(productor,&quot;生产者A&quot;).start();
           new Thread(consumer,&quot;消费者B&quot;).start();
    &#125;
&#125;
//店员
class Clerk&#123;
    private int product = 0;//共享数据
    public synchronized void get()&#123; //进货
        if(product &gt;= 10)&#123;
            System.out.println(&quot;产品已满&quot;);
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (++product));
        &#125;
    &#125;
    public synchronized void sell()&#123;//卖货
        if (product &lt;= 0)&#123;
            System.out.println(&quot;缺货&quot;);
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (--product));
        &#125;
    &#125;
&#125;
//生产者
class Productor implements Runnable&#123;
    private Clerk clerk;
    public Productor(Clerk clerk)&#123;
        this.clerk = clerk;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0;i&lt;20;i++)&#123;
            clerk.get();
        &#125;
    &#125;
&#125;
//消费者
class Consumer implements Runnable&#123;
    private Clerk clerk;
    public Consumer(Clerk clerk)&#123;
        this.clerk = clerk;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0;i&lt;20;i++)&#123;
            clerk.sell();
        &#125;
    &#125;
&#125;</code></pre>
<p>这就是生产消费模式的案例，这里没有使用等待唤醒机制，运行结果就是即使是缺货状态，它也会不断的去消费，也会一直打印“缺货”，即使是产品已满状态，也会不断地进货。用等待唤醒机制改进：</p>
<pre><code>//店员
class Clerk&#123;
    private int product = 0;//共享数据
    public synchronized void get()&#123; //进货
        if(product &gt;= 10)&#123;
            System.out.println(&quot;产品已满&quot;);
            try &#123;
                this.wait();//满了就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (++product));
            this.notifyAll();//没满就可以进货
        &#125;
    &#125;
    public synchronized void sell()&#123;//卖货
        if (product &lt;= 0)&#123;
            System.out.println(&quot;缺货&quot;);
            try &#123;
                this.wait();//缺货就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;else &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+ (--product));
            this.notifyAll();//不缺货就可以卖
        &#125;
    &#125;
&#125;</code></pre>
<p>这样就不会出现上述问题了。没有的时候就生产，生产满了就通知消费，消费完了再通知生产。但是这样还是有点问题，将上述代码做如下改动：</p>
<pre><code>if(product &gt;= 1)&#123; //把原来的10改成1
            System.out.println(&quot;产品已满&quot;);
         ......
public void run() &#123;
        try &#123;
            Thread.sleep(200);//睡0.2秒
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        for (int i = 0;i&lt;20;i++)&#123;
            clerk.sell();
        &#125;
&#125;</code></pre>
<p>就做这两处修改，再次运行，发现虽然结果没问题，但是程序却一直没停下来。出现这种情况是因为有一个线程在等待，而另一个线程没有执行机会了，唤醒不了这个等待的线程了，所以程序就无法结束。解决办法就是把get和sell方法里面的else去掉，不要用else包起来。但是，即使这样，如果再多加两个线程，就会出现负数了。</p>
<pre><code>new Thread(productor, &quot;生产者C&quot;).start();
new Thread(consumer, &quot;消费者D&quot;).start();</code></pre>
<p>运行结果：</p>
<p>一个消费者线程抢到执行权，发现product是0，就等待，这个时候，另一个消费者又抢到了执行权，product是0，还是等待，此时两个消费者线程在同一处等待。然后当生产者生产了一个product后，就会唤醒两个消费者，发现product是1，同时消费，结果就出现了0和-1。这就是<strong>虚假唤醒</strong>。解决办法就是把if判断改成while。如下：</p>
<pre><code> public synchronized void get() &#123; //进货
        while (product &gt;= 1) &#123;
            System.out.println(&quot;产品已满&quot;);
            try &#123;
                this.wait();//满了就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (++product));
            this.notifyAll();//没满就可以进货
    &#125;
    public synchronized void sell() &#123;//卖货
        while (product &lt;= 0) &#123;//为了避免虚假唤醒问题，wait方法应该总是在循环中使用
            System.out.println(&quot;缺货&quot;);
            try &#123;
                this.wait();//缺货就等待
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (--product));
            this.notifyAll();//不缺货就可以卖
    &#125;</code></pre>
<p>只需要把if改成while，每次都再去判断一下，就可以了。</p>
<p><strong>2、用Lock锁实现等待唤醒：</strong></p>
<pre><code>class Clerk &#123;
    private int product = 0;//共享数据
    private Lock lock = new ReentrantLock();//创建锁对象
    private Condition condition = lock.newCondition();//获取condition实例
    public  void get() &#123; //进货
        lock.lock();//上锁
        try &#123;
            while (product &gt;= 1) &#123;
                System.out.println(&quot;产品已满&quot;);
                try &#123;
                    condition.await();//满了就等待
                &#125; catch (InterruptedException e) &#123;
                &#125;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (++product));
            condition.signalAll();//没满就可以进货
        &#125;finally &#123;
            lock.unlock();//释放锁
        &#125;
    &#125;

    public  void sell() &#123;//卖货
        lock.lock();//上锁
        try &#123;
            while (product &lt;= 0) &#123;
                System.out.println(&quot;缺货&quot;);
                try &#123;
                    condition.await();//缺货就等待
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (--product));
            condition.signalAll();//不缺货就可以卖
        &#125;finally &#123;
            lock.unlock();//释放锁
        &#125;
    &#125;
&#125;</code></pre>
<p>使用lock同步锁，就不需要sychronized关键字了，需要创建lock对象和condition实例。condition的await()方法、signal()方法和signalAll()方法分别与wait()方法、notify()方法和notifyAll()方法对应。</p>
<p><strong>3、线程按序交替：</strong></p>
<p>首先来看一道题：</p>
<pre><code>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，
每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。
如：ABCABCABC…… 依次递归</code></pre>
<p>分析：</p>
<pre><code>线程本来是抢占式进行的，要按序交替，所以必须实现线程通信，
那就要用到等待唤醒。可以使用同步方法，也可以用同步锁。</code></pre>
<p>编码实现：</p>
<pre><code>public class TestLoopPrint &#123;
    public static void main(String[] args) &#123;
        AlternationDemo ad = new AlternationDemo();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    ad.loopA();
                &#125;
            &#125;
        &#125;, &quot;A&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    ad.loopB();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    ad.loopC();
                &#125;
            &#125;
        &#125;, &quot;C&quot;).start();
    &#125;
&#125;

class AlternationDemo &#123;
    private int number = 1;//当前正在执行的线程的标记
    private Lock lock = new ReentrantLock();
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Condition condition3 = lock.newCondition();

    public void loopA() &#123;
        lock.lock();
        try &#123;
            if (number != 1) &#123; //判断
                condition1.await();
            &#125;
            System.out.println(Thread.currentThread().getName());//打印
            number = 2;
            condition2.signal();
        &#125; catch (Exception e) &#123;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public void loopB() &#123;
        lock.lock();
        try &#123;
            if (number != 2) &#123; //判断
                condition2.await();
            &#125;
            System.out.println(Thread.currentThread().getName());//打印
            number = 3;
            condition3.signal();
        &#125; catch (Exception e) &#123;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public void loopC() &#123;
        lock.lock();
        try &#123;
            if (number != 3) &#123; //判断
                condition3.await();
            &#125;
            System.out.println(Thread.currentThread().getName());//打印
            number = 1;
            condition1.signal();
        &#125; catch (Exception e) &#123;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>以上编码就满足需求。创建三个线程，分别调用loopA、loopB和loopC方法，这三个线程使用condition进行通信。</p>
<h1 id="八、ReadWriterLock读写锁"><a href="#八、ReadWriterLock读写锁" class="headerlink" title="八、ReadWriterLock读写锁"></a>八、ReadWriterLock读写锁</h1><p>我们在读数据的时候，可以多个线程同时读，不会出现问题，但是写数据的时候，如果多个线程同时写数据，那么到底是写入哪个线程的数据呢？所以，如果有两个线程，写写/读写需要互斥，读读不需要互斥。这个时候可以用读写锁。看例子：</p>
<pre><code>public class TestReadWriterLock &#123;
    public static void main(String[] args)&#123;
           ReadWriterLockDemo rw = new ReadWriterLockDemo();
           new Thread(new Runnable() &#123;//一个线程写
               @Override
               public void run() &#123;
                   rw.set((int)Math.random()*101);
               &#125;
           &#125;,&quot;write:&quot;).start();
           for (int i = 0;i&lt;100;i++)&#123;//100个线程读
               Runnable runnable = () -&gt; rw.get();
               Thread thread = new Thread(runnable);
               thread.start();
           &#125;
    &#125;
&#125;

class ReadWriterLockDemo&#123;
    private int number = 0;
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    //读(可以多个线程同时操作)
    public void get()&#123;
        readWriteLock.readLock().lock();//上锁
        try &#123;
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+number);
        &#125;finally &#123;
            readWriteLock.readLock().unlock();//释放锁
        &#125;
    &#125;
    //写(一次只能有一个线程操作)
    public void set(int number)&#123;
        readWriteLock.writeLock().lock();
        try &#123;
            System.out.println(Thread.currentThread().getName());
            this.number = number;
        &#125;finally &#123;
            readWriteLock.writeLock().unlock();
        &#125;
    &#125;
&#125;</code></pre>
<p>这个就是读写锁的用法。上面的代码实现了一个线程写，一百个线程同时读的操作。</p>
<h1 id="九、线程池"><a href="#九、线程池" class="headerlink" title="九、线程池"></a>九、线程池</h1><p>我们使用线程时，需要new一个，用完了又要销毁，这样频繁的创建销毁也很耗资源，所以就提供了线程池。道理和连接池差不多，连接池是为了避免频繁的创建和释放连接，所以在连接池中就有一定数量的连接，要用时从连接池拿出，用完归还给连接池。线程池也一样。线程池中有一个线程队列，里面保存着所有等待状态的线程。下面来看一下用法：</p>
<pre><code>public class TestThreadPool &#123;
    public static void main(String[] args) &#123;
        ThreadPoolDemo tp = new ThreadPoolDemo();
        //1.创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(5);
        //2.为线程池中的线程分配任务
        pool.submit(tp);
        //3.关闭线程池
        pool.shutdown();
    &#125;
&#125;

class ThreadPoolDemo implements Runnable &#123;
    private int i = 0;
    @Override
    public void run() &#123;
        while (i &lt; 100) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (i++));
        &#125;
    &#125;
&#125;</code></pre>
<p>线程池用法很简单，分为三步。首先用工具类Executors创建线程池，然后给线程池分配任务，最后关闭线程池就行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上为本文全部内容，涉及到了JUC的大部分内容。 本人也是初次接触，如有错误，希望大佬指点一二！</p>
<p>原文：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f19835e05c0">https://www.jianshu.com/p/1f19835e05c0</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2020-04-25_java_optimize.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/advance/2020-04-25_java_optimize.html" class="post-title-link" itemprop="url">接口性能优化思路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+00:00">2020-04-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="1-数据库查询是否有问题，是不是慢查？索引？数据量？"><a href="#1-数据库查询是否有问题，是不是慢查？索引？数据量？" class="headerlink" title="1. 数据库查询是否有问题，是不是慢查？索引？数据量？"></a>1. 数据库查询是否有问题，是不是慢查？索引？数据量？</h4><h4 id="2-中间件：缓存，命中率？"><a href="#2-中间件：缓存，命中率？" class="headerlink" title="2. 中间件：缓存，命中率？"></a>2. 中间件：缓存，命中率？</h4><h4 id="3-代码：过长，多层循环？"><a href="#3-代码：过长，多层循环？" class="headerlink" title="3. 代码：过长，多层循环？"></a>3. 代码：过长，多层循环？</h4><h4 id="4-多线程并发"><a href="#4-多线程并发" class="headerlink" title="4. 多线程并发"></a>4. 多线程并发</h4><ul>
<li><p>开多少线程</p>
</li>
<li><p>如何控制线程数量</p>
</li>
<li><p>线程安全问题</p>
</li>
<li><p>Executors 慎用，内部无界队列；</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/%E5%85%B6%E4%BB%96/2020-01-29_%E5%BC%B9%E7%90%B4%E5%90%A7%E9%9D%9E%E4%BC%9A%E5%91%98%E6%89%92%E8%B0%B1%E6%8A%80%E5%B7%A7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E5%85%B6%E4%BB%96/2020-01-29_%E5%BC%B9%E7%90%B4%E5%90%A7%E9%9D%9E%E4%BC%9A%E5%91%98%E6%89%92%E8%B0%B1%E6%8A%80%E5%B7%A7.html" class="post-title-link" itemprop="url">使用 Tampermonkey 在【弹琴吧】非会员扒谱技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-29T00:00:00+00:00">2020-01-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96-Tampermonkey/" itemprop="url" rel="index"><span itemprop="name">其他/Tampermonkey</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分享一个最近发现的技巧，我在一个吉他谱网站找谱子，发现要会员权限，需要付费。</p>
<p>这样：</p>
<p><img src="./2020-01-29_%E5%BC%B9%E7%90%B4%E5%90%A7%E9%9D%9E%E4%BC%9A%E5%91%98%E6%89%92%E8%B0%B1%E6%8A%80%E5%B7%A7/1.png"></p>
<p>通过网页源码查看曲谱地址：</p>
<p><img src="./2020-01-29_%E5%BC%B9%E7%90%B4%E5%90%A7%E9%9D%9E%E4%BC%9A%E5%91%98%E6%89%92%E8%B0%B1%E6%8A%80%E5%B7%A7/2.png"></p>
<p>因为非会员，只加载了一张图片，但是观察发现图片资源有后缀 “1_1.png”，所以猜测后面的是“1_2.png”，“1_3.png”，等等。所以自己组装URL测试了一下：</p>
<p><a target="_blank" rel="noopener" href="http://oss.tan8.com/jtpnew/13/55513/44ec76f75eaf80d632e21abb91a6041cimage_1_1.png">http://oss.tan8.com/jtpnew/13/55513/44ec76f75eaf80d632e21abb91a6041cimage_1_1.png</a></p>
<p><a target="_blank" rel="noopener" href="http://oss.tan8.com/jtpnew/13/55513/44ec76f75eaf80d632e21abb91a6041cimage_1_2.png">http://oss.tan8.com/jtpnew/13/55513/44ec76f75eaf80d632e21abb91a6041cimage_1_2.png</a></p>
<p>……</p>
<p>结果是正确的。</p>
<p>于是产生了如下js代码来处理页面：</p>
<pre><code>// ==UserScript==
// @name         弹琴吧-扒谱
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       You
// @match        http://www.77music.com/jitapu-*.html
// @match        http://www.tan8.com/jitapu-*.html
// @require      http://code.jquery.com/jquery-1.11.0.min.js
// @grant        GM_xmlhttpRequest
// @grant        GM_download
// @grant        none
// ==/UserScript==

(function() &#123;
    &#39;use strict&#39;;
    var url = $(&quot;#img1&quot;).find(&quot;img&quot;).attr(&quot;src&quot;);
    if(url)&#123;
        //分析url，目标格式：http://oss.tan8.com/jtpnew/13/55513/44ec76f75eaf80d632e21abb91a6041cimage_1_1.png
        var index = &quot;image_&quot;;
        var codeStart = url.indexOf(index) + index.length;
        var codeEnd = url.indexOf(&quot;.png&quot;);
        var urlA = url.substring(0,codeStart);
        var urlB = url.substring(codeEnd);
        var code = url.substring(codeStart, codeEnd);//拿到“1_1”
        var aa = code.split(&quot;_&quot;);
        var bb = aa[1];//拿到 “1_1” 后半部分自增序列起始值
        var html = &quot;&quot;;
        for(var i = 0; i &lt; 20; i++)&#123;
            var t = urlA + aa[0] + &quot;_&quot; + (parseInt(bb) + i) + urlB;//组装url
            html += (&quot;&lt;img src=&#39;&quot;+t+&quot;&#39; style=&#39;float:left;display: block;width: auto;height: auto;margin-top: 70px;&#39; /&gt;&quot;);
        &#125;
        $(&quot;#headerMenu&quot;).after(html);
    &#125;
    $(&quot;#audio_mask&quot;).remove();
    $($(&quot;.vspace&quot;)[0]).html(&#39;&lt;audio controls=&quot;&quot;  style=&quot;width: 30%;height: 100%;&quot; src=&quot;&#39;+$(&quot;.audio_box2&quot;).find(&quot;audio&quot;).attr(&#39;src&#39;)+&#39;&quot;&gt;&lt;/audio&gt;&#39;); 
&#125;)();</code></pre>
<p>效果：</p>
<p><img src="./2020-01-29_%E5%BC%B9%E7%90%B4%E5%90%A7%E9%9D%9E%E4%BC%9A%E5%91%98%E6%89%92%E8%B0%B1%E6%8A%80%E5%B7%A7/3.png"></p>
<p>把谱子图片重新布局了一下，加载到页面上。</p>
<hr>
<h4 id="总结：由于大多数网站（大部分中小互联网公司）对媒体资源的访问不会做权限限制，所以这个思路可以应用大多数限制了权限但-url-是有规则的场景。"><a href="#总结：由于大多数网站（大部分中小互联网公司）对媒体资源的访问不会做权限限制，所以这个思路可以应用大多数限制了权限但-url-是有规则的场景。" class="headerlink" title="总结：由于大多数网站（大部分中小互联网公司）对媒体资源的访问不会做权限限制，所以这个思路可以应用大多数限制了权限但 url 是有规则的场景。"></a>总结：由于大多数网站（大部分中小互联网公司）对媒体资源的访问不会做权限限制，所以这个思路可以应用大多数限制了权限但 url 是有规则的场景。</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/spring/2019-12-28_%E3%80%90%E8%AF%91%E3%80%91Spring%20Boot%20%E4%BB%8E%20classpath%20%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/spring/2019-12-28_%E3%80%90%E8%AF%91%E3%80%91Spring%20Boot%20%E4%BB%8E%20classpath%20%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6.html" class="post-title-link" itemprop="url">【译】Spring Boot 从 classpath 加载文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:00+00:00">2019-12-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在创建Spring Boot web应用程序时，有时需要从 <code>classpath</code> 加载文件，例如，数据仅作为文件可用的时候。在我的例子中，我使用 <code>MAXMIND GeoLite2</code> 数据库进行地理位置检索。因此，我需要加载文件并创建一个 <code>DatabaseReader</code> 对象，该对象存储在服务器内存中。<br>下面您将找到在WAR和JAR中加载文件的解决方案。</p>
<h2 id="The-ResourceLoader"><a href="#The-ResourceLoader" class="headerlink" title="The ResourceLoader"></a>The ResourceLoader</h2><p>Java本身提供了线程 classLoader 可以用来尝试加载文件，但 Spring 框架提供了更加优雅的方式，比如 ： <a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html">ResourceLoader</a>。</p>
<p>你只需要在需要的地方注入 ResourceLoader ，然后调用 getResource(“some path”)  方法即可。</p>
<h2 id="从-resource-目录或-classpath-中加载文件-的例子-WAR"><a href="#从-resource-目录或-classpath-中加载文件-的例子-WAR" class="headerlink" title="从 resource 目录或 classpath 中加载文件 的例子 (WAR)"></a>从 resource 目录或 classpath 中加载文件 的例子 (WAR)</h2><pre><code>@Service(&quot;geolocationservice&quot;)
public class GeoLocationServiceImpl implements GeoLocationService &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(GeoLocationServiceImpl.class);

    private static DatabaseReader reader = null;

    private ResourceLoader resourceLoader;

    @Autowired
    public GeoLocationServiceImpl(ResourceLoader resourceLoader) &#123;
        this.resourceLoader = resourceLoader;
    &#125;

    @PostConstruct
    public void init() &#123;
        try &#123;
            LOGGER.info(&quot;GeoLocationServiceImpl: Trying to load GeoLite2-Country database...&quot;);

            Resource resource = resourceLoader.getResource(&quot;classpath:GeoLite2-Country.mmdb&quot;);
            File dbAsFile = resource.getFile();

            // Initialize the reader
            reader = new DatabaseReader
                        .Builder(dbAsFile)
                        .fileMode(Reader.FileMode.MEMORY)
                        .build();

            LOGGER.info(&quot;GeoLocationServiceImpl: Database was loaded successfully.&quot;);

        &#125; catch (IOException | NullPointerException e) &#123;
            LOGGER.error(&quot;Database reader cound not be initialized. &quot;, e);
        &#125;
    &#125;

    @PreDestroy
    public void preDestroy() &#123;
        if (reader != null) &#123;
            try &#123;
                reader.close();
            &#125; catch (IOException e) &#123;
                LOGGER.error(&quot;Failed to close the reader.&quot;);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="从-Spring-Boot-JAR-中加载文件的例子"><a href="#从-Spring-Boot-JAR-中加载文件的例子" class="headerlink" title="从 Spring Boot JAR 中加载文件的例子"></a>从 Spring Boot JAR 中加载文件的例子</h2><pre><code>@Service(&quot;geolocationservice&quot;)
public class GeoLocationServiceImpl implements GeoLocationService &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(GeoLocationServiceImpl.class);

    private static DatabaseReader reader = null;
    private ResourceLoader resourceLoader;

    @Inject
    public GeoLocationServiceImpl(ResourceLoader resourceLoader) &#123;
        this.resourceLoader = resourceLoader;
    &#125;

    @PostConstruct
    public void init() &#123;
        try &#123;
            LOGGER.info(&quot;GeoLocationServiceImpl: Trying to load GeoLite2-Country database...&quot;);

            Resource resource = resourceLoader.getResource(&quot;classpath:GeoLite2-Country.mmdb&quot;);
            InputStream dbAsStream = resource.getInputStream(); // &lt;-- this is the difference

            // Initialize the reader
            reader = new DatabaseReader
                        .Builder(dbAsStream)
                        .fileMode(Reader.FileMode.MEMORY)
                        .build();

            LOGGER.info(&quot;GeoLocationServiceImpl: Database was loaded successfully.&quot;);

        &#125; catch (IOException | NullPointerException e) &#123;
            LOGGER.error(&quot;Database reader cound not be initialized. &quot;, e);
        &#125;
    &#125;

    @PreDestroy
    public void preDestroy() &#123;
        if (reader != null) &#123;
            try &#123;
                reader.close();
            &#125; catch (IOException e) &#123;
                LOGGER.error(&quot;Failed to close the reader.&quot;);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>英文原文：<a target="_blank" rel="noopener" href="https://smarterco.de/java-load-file-from-classpath-in-spring-boot/?from=timeline">https://smarterco.de/java-load-file-from-classpath-in-spring-boot/?from=timeline</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/algorithm/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/algorithm/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90.html" class="post-title-link" itemprop="url">八皇后算法解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-26 11:29:24" itemprop="dateCreated datePublished" datetime="2019-11-26T11:29:24+00:00">2019-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天研究力扣的一道题死活写不出来对应的算法，没办法自己算法基础太差。于是看了下答案，发现使用什么回溯算法，菜鸟表示平时开发期间写的最复杂的程序就是写了两层for循环，已经很牛逼了有木有？这个回溯算法什么鬼？于是乎百度了下，算是了解了回溯算法是什么玩意儿。这里分析一波八皇后算法来加深一下理解。</p>
<p>八皇后算法描述如下：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法！ </p>
<p><img src="./%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/1.png"> </p>
<p>下面来分析一波，假设此时我们想要在黑色方块位置放置一个皇后： </p>
<p><img src="./%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/2.png"></p>
<p>如果一列一列的放置皇后的话，图中黑色位置能放置一个皇后的合法性条件为： </p>
<p>1、绿色线条经过的方格没有皇后 （不处于同一斜线） </p>
<p>2、红色线条经过的方格没有皇后 （不处于同一行） </p>
<p>3、紫色线条经过的方格没有皇后 （不处于同一斜线）<br>也就是说如果以黑色方块位置为参照原点：（0,0）坐标点，紫色和绿色两个线条分别是斜率为1和-1的两个函数，如下图： </p>
<p>紫色线所代表的函数是：y = -x; </p>
<p>绿色先所代表的函数是：y=x; </p>
<p>（横坐标是列，纵坐标为行，注意行从上到下递增） </p>
<p><img src="./%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/3.png"></p>
<p>凡是位于这两条函数线上的位置（点）以及横坐标（说明位于同一行）都不能有皇后。<br>所以假设某一列皇后的位置用行来记录，比如queen[column] = row,意思是第column列的皇后的位置在第row行。 </p>
<p>同行的逻辑很好判断，那么我们想要在黑色方块位置放置一个皇后，怎么判断前面几列是否在绿色线条和紫色线条上已经有了皇后呢？思路也很简单： </p>
<p>假设黑色方块的位置为n列，nRow行，假设位于m列的所在的行是否有皇后位于紫色线或者绿色上，那么就符合下面条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设此时即将在n列放置一个皇后,n&gt;m</span><br><span class="line"></span><br><span class="line">]&#x2F;&#x2F;获取m列上皇后所在的行</span><br><span class="line">int mRow &#x3D; queen[m]</span><br><span class="line">int nRow &#x3D; queen[n]；</span><br><span class="line">&#x2F;&#x2F;行的差值</span><br><span class="line">int rowDiff &#x3D; nRow - mRow;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列的差值</span><br><span class="line">int columnDiff &#x3D; n-m;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中 rowDiff的绝对值等于columnDiff的绝对值的话，说明点位于y=x或者y=-x的函数线上： </p>
<p><img src="./%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/4.png"></p>
<p>就说明此时黑色方块的位置是不能放置皇后的，因为在紫色或者绿色线上已经有了皇后。<br>那么用代码来（currentColumn,curreentRow）是否可以放置皇后的方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">     &#x2F;**</span><br><span class="line">     * 判断当（currentRow,currentColumn)是否可以放置皇后</span><br><span class="line">     * @param currentColumn </span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isLegal(int currentRow,int currentColumn) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历前面几列</span><br><span class="line">        for(int preColumn&#x3D;0;preColumn&lt;currentColumn;preColumn++) &#123;</span><br><span class="line">                int row &#x3D; queen[preColumn];</span><br><span class="line">                &#x2F;&#x2F;说明在子preColumn的低currentRow已经有了皇后</span><br><span class="line">                if(row&#x3D;&#x3D;currentRow) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;行与行的差值</span><br><span class="line">            int rowDiff&#x3D; Math.abs(row -currentRow);</span><br><span class="line">          </span><br><span class="line">            &#x2F;&#x2F;列于列的差值</span><br><span class="line">            int columnDiff &#x3D;  Math.abs(currentColumn-preColumn);</span><br><span class="line">            &#x2F;&#x2F;说明斜线上有皇后</span><br><span class="line">            if(rowDiff&#x3D;&#x3D;columnDiff )&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F;end for</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;说明（currentRow,currentColumn)可以摆放。</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为博主是按照一列一列的方式来进行放置的，所以整体思路就是：在当前列逐步尝试每一行是否可以放置皇后，如果有一个可以放置皇后，就继续查看下一列的每一行是否可以放置皇后。所以代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int queen[] &#x3D; new int[8];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">private void eightQueen(int currentColumn) &#123;</span><br><span class="line">            &#x2F;&#x2F;这个for循环的目的是尝试讲皇后放在当前列的每一行</span><br><span class="line">            for(int row&#x3D;0;row&lt;8;row++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断当前列的row行是否能放置皇后</span><br><span class="line">                    if(isLegal(row,currentColumn)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;放置皇后</span><br><span class="line">                            queen[currentColumn] &#x3D; row;</span><br><span class="line">                            if(currentColumn!&#x3D;7) &#123;</span><br><span class="line">                                    &#x2F;&#x2F;摆放下一列的皇后</span><br><span class="line">                                    eightQueen(currentColumn+1);</span><br><span class="line">                            </span><br><span class="line">                            &#125;else &#123;</span><br><span class="line">                                    &#x2F;&#x2F;递归结束，此时row要++了</span><br><span class="line">                                    count++;</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;&#x2F;&#x2F;end for</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是当currentColumn==7的时候，说明此时已经完成了一种摆放方法，然后for循环继续执行，去尝试其他摆放方法。 </p>
<p>测试一波，一共有92种摆放方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">     Queen queen &#x3D; new Queen();</span><br><span class="line">     queen.eightQueen(0);</span><br><span class="line">     System.out.println(&quot;总共有 &quot; +queen.count+ &quot; 摆放方法&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以结合八皇后的实现来看看到底什么是回溯算法，看<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495?fr=aladdin">百度百科解释</a> (rel=undefined)：回溯算法实际上一个类似枚举的搜索尝试过程，主要是&lt;font color#ff00ff&gt;在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法</p>
<p>比如八皇后算法来说，我们根据约束条件判断某一列的某一行是否可以放置皇后，如果不可以就继续判断&lt;font color #ff00ff&gt;当前列的下一行是否可以放置皇后.如果可以放置皇后，就继续探寻下一列中可以放置皇后的那个位置。完成一次摆放后。再重新挨个尝试下一个可能的摆放方法。</p>
<p>下面用一个<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">力扣的题</a> (rel=undefined)再次巩固下回溯算法的应用。该题描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br><span class="line">说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </span><br><span class="line">示例 1:输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2:输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>做该题的重要条件是无重复的数组，那么问题就很好解了。 </p>
<p>首先对数组从大到小排序。这是解题的关键。 </p>
<p>然后为了减少不必要的遍历，我们要对原来的数组进行截取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> &#x2F;&#x2F;重要的要大小排列</span><br><span class="line">Arrays.sort(candidates);</span><br><span class="line">&#x2F;&#x2F;说明原数组中就没有满足target的数</span><br><span class="line">if (candidates[0] &gt; target) &#123;</span><br><span class="line">       return res;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; newCandidates&#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">int len &#x3D; candidates.length;</span><br><span class="line">&#x2F;&#x2F; 取小于target的数 组成一个临时数组</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        int num &#x3D; candidates[i];</span><br><span class="line">        if (num &gt; target) &#123;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">       newCandidates.add(num);</span><br><span class="line"> &#125; &#x2F;&#x2F; end for</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>通过上面的步骤我们拿到了一个从小到大排列的无重复数组newCandidates，数组中的元素都&lt;=target. </p>
<p>因为数组从小到大排列，所以我们有如下几种情况，以candidates = [2,3,5], target = 8为例： </p>
<p>符合条件的子数组满足条件如下 </p>
<p>1、target循环减去一个数，如果能一直减到到差值等于0，那么这个数组成的数组就是一个解,比如[2,2,2,2]; </p>
<p>2、target减去一个数，然后形成了一个新的newTarget=target-num[i],让这个newTarget减去下一个数num[i+1],然后执行步骤1，则又是一个解，比如[2,3,3];（其实步骤1是步骤2的一个特例） </p>
<p>3、target减去一个数，然后形成了一个新的newTarget=target-num[i],让这个newTarget减去下一个数num[i+1]，如果能一直减到到差值等于0说明又是一个解.，比如[3,5]; </p>
<p>如此得到了一个规律，只要是相减之后得到差值=0,就说明就得到一个解。 </p>
<p>得到一个新的解之后继续循环数组中的下一个数字，继续执行1,2,3步骤即可。 </p>
<p>所以完成的解法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         &#x2F;&#x2F;重要的要大小排列</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">         </span><br><span class="line">                List&lt;Integer&gt; temp &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">                if (candidates[0] &gt; target) &#123;</span><br><span class="line">                        return res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        int len &#x3D; candidates.length;</span><br><span class="line">         </span><br><span class="line">                &#x2F;&#x2F; 取小于target的数 足证一个临时数组</span><br><span class="line">                for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">                        int num &#x3D; candidates[i];</span><br><span class="line">                        if (num &gt; target) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        temp.add(num);</span><br><span class="line">                &#125; &#x2F;&#x2F; end for</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F;</span><br><span class="line">        find(res, new ArrayList&lt;&gt;(), temp, target, 0);</span><br><span class="line">         </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void find(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, List&lt;Integer&gt; candidates, int target, int start)&#123;</span><br><span class="line">        &#x2F;&#x2F;target&#x3D;&#x3D;0.找到一个新的解</span><br><span class="line">        if (target &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(tmp));</span><br><span class="line">        &#125;else if(target&gt;0)&#123;</span><br><span class="line">          for (int i &#x3D; start; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">             int num &#x3D; candidates.get(i);</span><br><span class="line">             if(num&lt;&#x3D;target)&#123;               </span><br><span class="line">                  tmp.add(num);</span><br><span class="line">                  &#x2F;&#x2F;查找新的target</span><br><span class="line">                  int newTarget &#x3D; target-num;</span><br><span class="line">                  find(res, tmp, candidates, newTarget, i);</span><br><span class="line">                  tmp.remove(tmp.size() - 1);</span><br><span class="line">             &#125;</span><br><span class="line">           </span><br><span class="line">           &#125;&#x2F;&#x2F;end for</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chunqiuwei/article/details/90113087#commentBox">https://blog.csdn.net/chunqiuwei/article/details/90113087#commentBox</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
