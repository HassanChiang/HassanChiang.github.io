<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="分享之">
<meta property="og:url" content="https://blog.fenxiangz.com/page/6/index.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="Share everything">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="JAVA,Linux,技术分享,网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.fenxiangz.com/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/dateabase/mysql/2018-12-17_MySQL%E7%9A%84InnoDB%E7%9A%84%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/dateabase/mysql/2018-12-17_MySQL%E7%9A%84InnoDB%E7%9A%84%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.html" class="post-title-link" itemprop="url">MySQL的InnoDB的幻读问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-17T00:00:00+00:00">2018-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html">MySQL InnoDB事务的隔离级别</a>有四级，默认是“可重复读”（REPEATABLE READ）。</p>
<ul>
<li>  未提交读（READ UNCOMMITTED）。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。</li>
<li>  提交读（READ COMMITTED）。本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。</li>
<li>  可重复读（REPEATABLE READ）。在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象（稍后解释）。</li>
<li>  串行化（SERIALIZABLE）。读操作会隐式获取共享锁，可以保证不同事务间的互斥。</li>
</ul>
<p>四个级别逐渐增强，每个级别解决一个问题。</p>
<ul>
<li>  脏读，最容易理解。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。</li>
<li>  不重复读。解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。</li>
<li>  幻读。解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。</li>
</ul>
<p>借鉴并改造了一个搞笑的比喻：</p>
<ul>
<li>  脏读。假如，中午去食堂打饭吃，看到一个座位被同学小Q占上了，就认为这个座位被占去了，就转身去找其他的座位。不料，这个同学小Q起身走了。事实：该同学小Q只是临时坐了一小下，并未“提交”。</li>
<li>  不重复读。假如，中午去食堂打饭吃，看到一个座位是空的，便屁颠屁颠的去打饭，回来后却发现这个座位却被同学小Q占去了。</li>
<li>  幻读。假如，中午去食堂打饭吃，看到一个座位是空的，便屁颠屁颠的去打饭，回来后，发现这些座位都还是空的（重复读），窃喜。走到跟前刚准备坐下时，却惊现一个恐龙妹，严重影响食欲。仿佛之前看到的空座位是“幻影”一样。</li>
</ul>
<hr>
<p>一些文章写到InnoDB的可重复读避免了“幻读”（phantom read），这个说法并不准确。</p>
<p>做个试验：(以下所有试验要注意存储引擎和隔离级别)</p>
<blockquote>
<p>mysql&gt; show create table t_bitfly\G;<br>CREATE TABLE <code>t_bitfly</code> (<br><code>id</code> bigint(20) NOT NULL default ‘0’,<br><code>value</code> varchar(32) default NULL,<br>PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=gbk</p>
<p>mysql&gt; select @@global.tx_isolation, @@tx_isolation;<br>+———————–+—————–+<br>| @@global.tx_isolation | @@tx_isolation  |<br>+———————–+—————–+<br>| REPEATABLE-READ       | REPEATABLE-READ |<br>+———————–+—————–+</p>
</blockquote>
<p>试验一：</p>
<blockquote>
<p>t Session A                                   Session B<br>|<br>| START TRANSACTION;            START TRANSACTION;<br>|<br>| SELECT * FROM t_bitfly;<br>| empty set<br>|                                                             INSERT INTO t_bitfly<br>|                                                             VALUES (1, ‘a’);<br>|<br>| SELECT * FROM t_bitfly;<br>| empty set<br>|                                                             COMMIT;<br>|<br>| SELECT * FROM t_bitfly;<br>| empty set<br>|<br>| INSERT INTO t_bitfly VALUES (1, ‘a’);<br>| ERROR 1062 (23000):<br>| Duplicate entry ‘1’ for key 1<br>v (shit, 刚刚明明告诉我没有这条记录的)</p>
</blockquote>
<p>如此就出现了幻读，以为表里没有数据，其实数据已经存在了，傻乎乎的提交后，才发现数据冲突了。</p>
<p>试验二：</p>
<blockquote>
<p>t Session A                                      Session B<br>|<br>| START TRANSACTION;              START TRANSACTION;<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>|                                                            INSERT INTO t_bitfly<br>|                                                            VALUES (2, ‘b’);<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>|                                                            COMMIT;<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>|<br>| UPDATE t_bitfly SET value=’z’;<br>| Rows matched: 2  Changed: 2  Warnings: 0<br>| (怎么多出来一行)<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | z     |<br>| |    2 | z     |<br>| +——+——-+<br>|<br>v</p>
</blockquote>
<p>本事务中第一次读取出一行，做了一次更新后，另一个事务里提交的数据就出现了。也可以看做是一种幻读。</p>
<hr>
<p>那么，InnoDB指出的可以避免幻读是怎么回事呢？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html">http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html</a></p>
<p>By default, InnoDB operates in REPEATABLE READ transaction isolation level and with the innodb_locks_unsafe_for_binlog system variable disabled. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see Section 13.6.8.5, “Avoiding the Phantom Problem Using Next-Key Locking”).</p>
</blockquote>
<p>准备的理解是，当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。</p>
<p>关键点在于，是InnoDB默认对一个普通的查询也会加next-key locks，还是说需要应用自己来加锁呢？如果单看这一句，可能会以为InnoDB对普通的查询也加了锁，如果是，那和序列化（SERIALIZABLE）的区别又在哪里呢？</p>
<p>MySQL manual里还有一段：</p>
<blockquote>
<p>13.2.8.5. Avoiding the Phantom Problem Using Next-Key Locking (<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/innodb-next-key-locking.html">http://dev.mysql.com/doc/refman/5.0/en/innodb-next-key-locking.html</a>)</p>
<p>To prevent phantoms, <code>InnoDB</code> uses an algorithm called <em>next-key locking</em> that combines index-row locking with gap locking.</p>
<p>You can use next-key locking to implement a uniqueness check in your application: If you read your data in share mode and do not see a duplicate for a row you are going to insert, then you can safely insert your row and know that the next-key lock set on the successor of your row during the read prevents anyone meanwhile inserting a duplicate for your row. Thus, the next-key locking enables you to “<span style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px;">lock</span>” the nonexistence of something in your table.</p>
</blockquote>
<p>我的理解是说，InnoDB提供了next-key locks，但需要应用程序自己去加锁。manual里提供一个例子：</p>
<blockquote>
<p>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</p>
</blockquote>
<p>这样，InnoDB会给id大于100的行（假如child表里有一行id为102），以及100-102，102+的gap都加上锁。</p>
<p>可以使用show innodb status来查看是否给表加上了锁。</p>
<p>再看一个实验，要注意，表t_bitfly里的id为主键字段。实验三：</p>
<blockquote>
<p>t Session A                                       Session B<br>|<br>| START TRANSACTION;                START TRANSACTION;<br>|<br>| SELECT * FROM t_bitfly<br>| WHERE id&lt;=1<br>| FOR UPDATE;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>|                                                           INSERT INTO t_bitfly<br>|                                                           VALUES (2, ‘b’);<br>|                                                           Query OK, 1 row affected<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>|                                                           INSERT INTO t_bitfly<br>|                                                           VALUES (0, ‘0’);<br>|                                                           (waiting for lock …<br>|                                                           then timeout)<br>|                                                           ERROR 1205 (HY000):<br>|                                                           Lock wait timeout exceeded;<br>|                                                           try restarting transaction<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>|                                                           COMMIT;<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id   | value |<br>| +——+——-+<br>| |    1 | a     |<br>| +——+——-+<br>v</p>
</blockquote>
<p>可以看到，用id&lt;=1加的锁，只锁住了id&lt;=1的范围，可以成功添加id为2的记录，添加id为0的记录时就会等待锁的释放。</p>
<p>MySQL manual里对可重复读里的锁的详细解释：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html#isolevel_repeatable-read">http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html#isolevel_repeatable-read</a></p>
<p>For locking reads (<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/select.html" title="12.2.8. SELECT Syntax"><code>SELECT</code></a> with <code>FOR UPDATE</code> or <code>LOCK IN SHARE MODE</code>),<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/update.html" title="12.2.11. UPDATE Syntax"><code>UPDATE</code></a>, and <a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/delete.html" title="12.2.2. DELETE Syntax"><code>DELETE</code></a> statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, <code>InnoDB</code> locks only the index record found, not the gap before it. For other search conditions, <code>InnoDB</code> locks the index range scanned, using gap locks or next-key (gap plus index-record) locks to block insertions by other sessions into the gaps covered by the range.</p>
</blockquote>
<hr>
<p>一致性读和提交读，先看实验，实验四：</p>
<blockquote>
<p>t Session A                                                          Session B<br>|<br>| START TRANSACTION;                             START TRANSACTION;<br>|<br>| SELECT * FROM t_bitfly;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| |  1 | a     |<br>| +—-+——-+<br>|                                                                        INSERT INTO t_bitfly<br>|                                                                                VALUES (2, ‘b’);<br>|                                                                        COMMIT;<br>|<br>| SELECT * FROM t_bitfly;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| |  1 | a     |<br>| +—-+——-+<br>|<br>| SELECT * FROM t_bitfly LOCK IN SHARE MODE;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| |  1 | a     |<br>| |  2 | b     |<br>| +—-+——-+<br>|<br>| SELECT * FROM t_bitfly FOR UPDATE;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| |  1 | a     |<br>| |  2 | b     |<br>| +—-+——-+<br>|<br>| SELECT * FROM t_bitfly;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| |  1 | a     |<br>| +—-+——-+<br>v</p>
</blockquote>
<p>如果使用普通的读，会得到一致性的结果，如果使用了加锁的读，就会读到“最新的”“提交”读的结果。</p>
<p>本身，可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。</p>
<p>可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html">http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html</a></p>
<p>If you want to see the “freshest” state of the database, you should use either the READ COMMITTED isolation level or a locking read:<br>SELECT * FROM t_bitfly LOCK IN SHARE MODE;</p>
</blockquote>
<hr>
<p>结论：MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。</p>
<p>==================== 结尾 ====================</p>
<p>作者: bitfly. 转载请注明来源或包含本信息. 谢谢<br>链接: <a target="_blank" rel="noopener" href="http://blog.bitfly.cn/post/mysql-innodb-phantom-read/">http://blog.bitfly.cn/post/mysql-innodb-phantom-read/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/dateabase/mysql/2018-12-16_MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/dateabase/mysql/2018-12-16_MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95.html" class="post-title-link" itemprop="url">Mysql 分库分表简要记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-16 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-16T00:00:00+00:00">2018-12-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="维度："><a href="#维度：" class="headerlink" title="维度："></a>维度：</h3><h4 id="用户：id取模"><a href="#用户：id取模" class="headerlink" title="用户：id取模"></a>用户：id取模</h4><h4 id="时间：按年、按月、按周、按日"><a href="#时间：按年、按月、按周、按日" class="headerlink" title="时间：按年、按月、按周、按日"></a>时间：按年、按月、按周、按日</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2018-12-15_URL%E5%92%8CURI%E7%9A%84%E5%8C%BA%E5%88%AB.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2018-12-15_URL%E5%92%8CURI%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="post-title-link" itemprop="url">URL 和 URI 的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-15T00:00:00+00:00">2018-12-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C-%E6%9C%AF%E8%AF%AD/" itemprop="url" rel="index"><span itemprop="name">网络/术语</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="./2018-12-15_URL%E5%92%8CURI%E7%9A%84%E5%8C%BA%E5%88%AB/1.png"> </p>
<h3 id="URI-URL-URN"><a href="#URI-URL-URN" class="headerlink" title="URI, URL, URN"></a>URI, URL, URN</h3><p>从上面的那幅图可以看出来，一共有三个不同的概念URI，URL，URN。这讨论这样的问题时，最好的方法就是回到原点啊，这里我们在<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc3986">RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</a>里面收集了点资料：</p>
<p>“A Uniform Resource Identifier (URI) 是一个紧凑的字符串用来标示抽象或物理资源。”<br>“A URI 可以进一步被分为定位符、名字或两者都是。术语“Uniform Resource Locator” (URL) 是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制(如其网络“位置”)。”</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/network/2018-12-15_URL%E5%92%8CURI%E7%9A%84%E5%8C%BA%E5%88%AB.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/dateabase/mysql/2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/dateabase/mysql/2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81.html" class="post-title-link" itemprop="url">Mysql 优化概要</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-15T00:00:00+00:00">2018-12-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="索引优化配置"><a href="#索引优化配置" class="headerlink" title="索引优化配置"></a>索引优化配置</h3><p>记录没有使用索引的查询日志配置：</p>
<pre><code>mysql&gt; show variables like &#39;%log_que%&#39;;
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| log_queries_not_using_indexes | OFF   |
+-------------------------------+-------+
1 row in set (0.01 sec)

mysql&gt; set global log_queries_not_using_indexes=ON;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show variables like &#39;%log_que%&#39;;
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| log_queries_not_using_indexes | ON    |
+-------------------------------+-------+
1 row in set (0.01 sec)</code></pre>
<p>开启慢查日志配置：</p>
<pre><code>mysql&gt; show variables like &#39;%slow_query%&#39;;
+---------------------+--------------------------------+
| Variable_name       | Value                          |
+---------------------+--------------------------------+
| slow_query_log      | OFF                            |
| slow_query_log_file | /var/lib/mysql/mysql-slow.log |
+---------------------+--------------------------------+
2 rows in set (0.01 sec)

mysql&gt; set global slow_query_log=ON;
Query OK, 0 rows affected (0.04 sec)

mysql&gt; show variables like &#39;%slow_query%&#39;;
+---------------------+--------------------------------+
| Variable_name       | Value                          |
+---------------------+--------------------------------+
| slow_query_log      | ON                             |
| slow_query_log_file | /var/lib/mysql/mysql-slow.log |
+---------------------+--------------------------------+
2 rows in set (0.01 sec)</code></pre>
<p>多久算慢查询？设置慢查询时间配置：</p>
<p>全局：</p>
<pre><code>mysql&gt;  SHOW GLOBAL VARIABLES LIKE &quot;long_query_time&quot;;
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 11.000000 |
+-----------------+-----------+
1 row in set (0.01 sec)

mysql&gt;  set global long_query_time=1;
Query OK, 0 rows affected (0.00 sec)

mysql&gt;  SHOW GLOBAL VARIABLES LIKE &quot;long_query_time&quot;;
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 1.000000 |
+-----------------+----------+
1 row in set (0.00 sec)</code></pre>
<p>会话：</p>
<pre><code>mysql&gt; SHOW SESSION VARIABLES LIKE &quot;long_query_time&quot;;
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 2.000000 |
+-----------------+----------+
1 row in set (0.01 sec)

mysql&gt; SET @@SESSION.long_query_time = 1;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SHOW SESSION VARIABLES LIKE &quot;long_query_time&quot;;
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 1.000000 |
+-----------------+----------+
1 row in set (0.00 sec)</code></pre>
<p>慢查日志分析工具：mysqldumpslow、pt-query-digest</p>
<p>通过慢查询日志发现有问题的SQL：</p>
<ol>
<li>查询次数多且每次查询占用时间长的SQL；<br> （pt-query-digest 分析的前几个查询）</li>
<li>IO大的SQL；<br> （pt-query-digest 分析中的 Rows examine项）</li>
<li>未命中索引的SQL。<br> （pt-query-digest 分析中的 Rows examine 和 Rows Send 的对比， 扫描大于发送行，说明索引命中率低）</li>
</ol>
<h3 id="执行计划分析"><a href="#执行计划分析" class="headerlink" title="执行计划分析"></a>执行计划分析</h3><p>EXPLAIN 用来查看MySQL执行一个SQL语句的执行计划。语法：</p>
<pre><code>&#123;EXPLAIN | DESCRIBE | DESC&#125;
    tbl_name [col_name | wild]
&#123;EXPLAIN | DESCRIBE | DESC&#125;
    [explain_type]
    &#123;explainable_stmt | FOR CONNECTION connection_id&#125;
explain_type: &#123;
    EXTENDED
  | PARTITIONS
  | FORMAT = format_name
&#125;
format_name: &#123;
    TRADITIONAL
  | JSON
&#125;
explainable_stmt: &#123;
    SELECT statement
  | DELETE statement
  | INSERT statement
  | REPLACE statement
  | UPDATE statement
&#125;</code></pre>
<p><a href="http://blog.fenxiangz.com/mysql/mysql-explain/">http://blog.fenxiangz.com/mysql/mysql-explain/</a></p>
<hr>
<h3 id="下文转载"><a href="#下文转载" class="headerlink" title="下文转载"></a>下文转载</h3><p>说起MySQL的查询优化，相信大家收藏了一堆奇淫技巧：不能使用<code>SELECT *</code>、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p>
<h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><p>如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/1.webp"><br>-&gt;MySQL逻辑架构，来自：高性能MySQL&lt;-</p>
<p>MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p>
<p>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p>
<p>最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p>
<h3 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h3><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：<strong>很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</strong></p>
<p>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/2.webp"><br>-&gt;MySQL查询过程&lt;-</p>
<h4 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h4><p>MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p>
<p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置<code>max_allowed_packet</code>参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p>
<p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用<code>SELECT *</code>以及加上<code>LIMIT</code>限制的原因之一。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p>
<p>MySQL将缓存存放在一个引用表（不要理解成<code>table</code>，可以认为是类似于<code>HashMap</code>的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p>
<p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果<br>都不会被缓存。比如函数<code>NOW()</code>或者<code>CURRENT_DATE()</code>会因为不同的查询时间，返回不同的查询结果，再比如包含<code>CURRENT_USER</code>或者<code>CONNECION_ID()</code>的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p>
<p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p>
<ol>
<li> 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</li>
<li> 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li>
</ol>
<p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p>
<ol>
<li> 用多个小表代替一个大表，注意不要过度设计</li>
<li> 批量插入代替循环单条插入</li>
<li> 合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li>
<li> 可以通过<code>SQL_CACHE</code>和<code>SQL_NO_CACHE</code>来控制某个查询语句是否需要进行缓存</li>
</ol>
<p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将<code>query_cache_type</code>设置为<code>DEMAND</code>，这时只有加入<code>SQL_CACHE</code>的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p>
<p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p>
<h4 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h4><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<p>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的<code>last_query_cost</code>的值来得到其计算当前查询的成本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_message limit 10;</span><br><span class="line">...省略结果集</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like &#39;last_query_cost&#39;;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 6391.799000 |</span><br><span class="line">+-----------------+-------------+</span><br></pre></td></tr></table></figure>

<p>示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p>
<p>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p>
<p>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p>
<ul>
<li>  重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>  优化<code>MIN()</code>和<code>MAX()</code>函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</li>
<li>  提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li>
<li>  优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</li>
</ul>
<p>随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p>
<h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为<code>handler API</code>。查询过程中的每一张表由一个<code>handler</code>实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个<code>handler</code>实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p>
<h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如改查询影响到的行数以及执行时间等等。</p>
<p>如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。</p>
<p>结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p>
<p>回头总结一下MySQL整个查询执行过程，总的来说分为6个步骤：</p>
<ol>
<li> 客户端向MySQL服务器发送一条查询请求</li>
<li> 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li> 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li>
<li> MySQL根据执行计划，调用存储引擎的API来执行查询</li>
<li> 将结果返回给客户端，同时缓存查询结果</li>
</ol>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p>看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：<strong>不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设</strong>。</p>
<h4 id="Scheme设计与数据类型优化"><a href="#Scheme设计与数据类型优化" class="headerlink" title="Scheme设计与数据类型优化"></a>Scheme设计与数据类型优化</h4><p>选择数据类型只要遵循<strong>小而简单</strong>的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用<code>DATETIME</code>来存储时间，而不是使用字符串。</p>
<p>这里总结几个可能容易理解错误的技巧：</p>
<ol>
<li> 通常来说把可为<code>NULL</code>的列改为<code>NOT NULL</code>不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为<code>NOT NULL</code>。</li>
<li> 对整数类型指定宽度，比如<code>INT(11)</code>，没有任何卵用。<code>INT</code>使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以<code>INT(1)</code>和<code>INT(20)</code>对于存储和计算是相同的。</li>
<li> <code>UNSIGNED</code>表示不允许负值，大致可以使正数的上限提高一倍。比如<code>TINYINT</code>存储范围是-128 ~ 127，而<code>UNSIGNED TINYINT</code>存储的范围却是0 - 255。</li>
<li> 通常来讲，没有太大的必要使用<code>DECIMAL</code>数据类型。即使是在需要存储财务数据时，仍然可以使用<code>BIGINT</code>。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用<code>BIGINT</code>存储。这样可以避免浮点数计算不准确和<code>DECIMAL</code>精确计算代价高的问题。</li>
<li> <code>TIMESTAMP</code>使用4个字节存储空间，<code>DATETIME</code>使用8个字节存储空间。因而，<code>TIMESTAMP</code>只能表示1970 - 2038年，比<code>DATETIME</code>表示的范围小得多，而且<code>TIMESTAMP</code>的值因时区不同而不同。</li>
<li> 大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用<code>ALTER TABLE</code>（如果只只是在列表末尾追加元素，不需要重建表）。</li>
<li> schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。</li>
<li> 大表<code>ALTER TABLE</code>非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇淫技巧可以解决这个问题，有兴趣可自行查阅。</li>
</ol>
<h4 id="创建高性能索引"><a href="#创建高性能索引" class="headerlink" title="创建高性能索引"></a>创建高性能索引</h4><p>索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
<h5 id="索引相关的数据结构和算法"><a href="#索引相关的数据结构和算法" class="headerlink" title="索引相关的数据结构和算法"></a>索引相关的数据结构和算法</h5><p>通常我们所说的索引是指<code>B-Tree</code>索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用<code>B-Tree</code>这个术语，是因为MySQL在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB就是使用的<code>B+Tree</code>。</p>
<p><code>B+Tree</code>中的B是指<code>balance</code>，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<p>在介绍<code>B+Tree</code>前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因为大多数情况下二叉查找树的平均查找速度比顺序查找要快。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/3.webp"><br>-&gt;二叉查找树和平衡二叉树&lt;-</p>
<p>由于二叉查找树可以任意构造，同样的值，可以构造出如图②的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL树）。</p>
<p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于1。显然图②不满足平衡二叉树的定义，而图①是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图①的平衡二叉树，当用户需要插入一个新的值9的节点时，就需要做出如下变动。<br><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/4.webp"><br>-&gt;平衡二叉树旋转&lt;-</p>
<p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而<code>B+Tree</code>就是一种多路搜索树。理解<code>B+Tree</code>时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（<code>Leaf Page</code>），非叶子节点（<code>Index Page</code>）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的<code>B+Tree</code>。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/5.webp"><br>-&gt;简化B+Tree&lt;-</p>
<p>怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果没有链接指针的话，就无法进行区间查找。这也是MySQL使用<code>B+Tree</code>作为索引存储结构的重要原因。</p>
<p>MySQL为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p>
<blockquote>
<p>页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，页的大小通常为4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
</blockquote>
<p>MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次I/O。假设<code>B+Tree</code>的高度为h，一次检索最多需要<code>h-1</code>I/O（根节点常驻内存），复杂度$O(h) = O(\log_{M}N)$。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</p>
<p>最后简单了解下<code>B+Tree</code>节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p>
<p>仍以上面的树为例，我们假设每个节点只能存储4个内节点。首先要插入第一个节点28，如下图所示。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/6.webp"><br>-&gt;leaf page和index page都没有满&lt;-</p>
<p>接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为50，所以根据中间值来拆分叶子节点，如下图所示。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/7.webp"><br>-&gt;Leaf Page拆分&lt;-</p>
<p>最后插入一个节点95，这时候Index Page和Leaf Page都满了，就需要做两次拆分，如下图所示。<br><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/8.webp"><br>-&gt; Leaf Page与Index Page拆分 &lt;-</p>
<p>拆分后最终形成了这样一颗树。<br><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/9.webp"><br>-&gt;最终树&lt;-</p>
<p><code>B+Tree</code>为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要I/O操作，为了尽可能的减少页的拆分操作，<code>B+Tree</code>也提供了类似于平衡二叉树的旋转功能。当Leaf Page已满但其左右兄弟节点没有满的情况下，<code>B+Tree</code>并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入70的时候，并不会去做页拆分，而是左旋操作。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/10.webp"><br>-&gt;左旋操作&lt;-</p>
<p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类型，仍然需要旋转和拆分操作，这里就不再说明。</p>
<h5 id="高性能策略"><a href="#高性能策略" class="headerlink" title="高性能策略"></a>高性能策略</h5><p>通过上文，相信你对<code>B+Tree</code>的数据结构已经有了大致的了解，但MySQL中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People(</span><br><span class="line">    last_name varchar(50) not null,</span><br><span class="line">    first_name varchar(50) not null,</span><br><span class="line">    dob date not null,</span><br><span class="line">    gender enum(&#96;m&#96;,&#96;f&#96;) not null,</span><br><span class="line">    key(last_name,first_name,dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于表中每一行数据，索引中包含了last_name、first_name、dob列的值，下图展示了索引是如何组织数据存储的。</p>
<p><img src="./2018-12-15_MySQL%E4%BC%98%E5%8C%96%E6%A6%82%E8%A6%81/11.webp"><br>-&gt;索引如何组织数据存储，来自：高性能MySQL&lt;-</p>
<p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的“最左原则”。</p>
<h6 id="1、MySQL不会使用索引的情况：非独立的列"><a href="#1、MySQL不会使用索引的情况：非独立的列" class="headerlink" title="1、MySQL不会使用索引的情况：非独立的列"></a>1、MySQL不会使用索引的情况：非独立的列</h6><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from where id + 1 &#x3D; 5</span><br></pre></td></tr></table></figure>

<p>我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。</p>
<h6 id="2、前缀索引"><a href="#2、前缀索引" class="headerlink" title="2、前缀索引"></a>2、前缀索引</h6><p>如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p>
<h6 id="3、多列索引和索引顺序"><a href="#3、多列索引和索引顺序" class="headerlink" title="3、多列索引和索引顺序"></a>3、多列索引和索引顺序</h6><p>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了独立的索引，然后有如下查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select film_id,actor_id from film_actor where actor_id &#x3D; 1 or film_id &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>老版本的MySQL会随机选择一个索引，但新版本做如下的优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select film_id,actor_id from film_actor where actor_id &#x3D; 1  </span><br><span class="line">union all </span><br><span class="line">select film_id,actor_id from film_actor where film_id &#x3D; 1 and actor_id &lt;&gt; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>  当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</li>
<li>  当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</li>
</ul>
<p>因此<code>explain</code>时如果发现有索引合并（Extra字段出现<code>Using union</code>），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p>
<p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p>
<blockquote>
<p><strong>索引选择性</strong>是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。</p>
</blockquote>
<p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM payment where staff_id &#x3D; 2 and customer_id &#x3D; 584</span><br></pre></td></tr></table></figure>

<p>是应该创建<code>(staff_id,customer_id)</code>的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近1就把哪个字段索引前面就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct staff_id)&#x2F;count(*) as staff_id_selectivity,</span><br><span class="line">       count(distinct customer_id)&#x2F;count(*) as customer_id_selectivity,</span><br><span class="line">       count(*) from payment</span><br></pre></td></tr></table></figure>

<p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from trade where user_group_id &#x3D; 1 and trade_amount &gt; 0</span><br></pre></td></tr></table></figure>

<p>MySQL为这个查询选择了索引<code>(user_group_id,trade_amount)</code>，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p>
<p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p>
<h6 id="4、避免多个范围条件"><a href="#4、避免多个范围条件" class="headerlink" title="4、避免多个范围条件"></a>4、避免多个范围条件</h6><p>实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user.* from user where login_time &gt; &#39;2017-04-01&#39; and age between 18 and 30;</span><br></pre></td></tr></table></figure>

<p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p>
<h6 id="5、覆盖索引"><a href="#5、覆盖索引" class="headerlink" title="5、覆盖索引"></a>5、覆盖索引</h6><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p>
<ul>
<li>  索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量</li>
<li>  索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</li>
</ul>
<h6 id="6、使用索引扫描来排序"><a href="#6、使用索引扫描来排序" class="headerlink" title="6、使用索引扫描来排序"></a>6、使用索引扫描来排序</h6><p>MySQL有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果explain的结果中<code>type</code>列的值为<code>index</code>表示使用了索引扫描来做排序。</p>
<p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</p>
<p>在设计索引时，如果一个索引既能够满足排序，有满足查询，是最好的。</p>
<p>只有当索引的列顺序和<code>ORDER BY</code>子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有<code>ORDER BY</code>子句引用的字段全部为第一张表时，才能使用索引做排序。<code>ORDER BY</code>子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其他情况下都需要执行排序操作，而无法利用索引排序。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 最左列为常数，索引：(date,staff_id,customer_id)</span><br><span class="line">select  staff_id,customer_id from demo where date &#x3D; &#39;2015-06-01&#39; order by staff_id,customer_id</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="7、冗余和重复索引"><a href="#7、冗余和重复索引" class="headerlink" title="7、冗余和重复索引"></a>7、冗余和重复索引</h6><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引<code>(A,B)</code>，再创建索引<code>(A)</code>就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引<code>(A,B)</code>，但这个索引不是扩展已有的索引<code>(A)</code>。</p>
<p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p>
<h6 id="8、删除长期未使用的索引"><a href="#8、删除长期未使用的索引" class="headerlink" title="8、删除长期未使用的索引"></a>8、删除长期未使用的索引</h6><p>定期删除一些长时间未使用过的索引是一个非常好的习惯。</p>
<p>关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，**<code>explain</code>后再提测是一种美德**。</p>
<h4 id="特定类型查询优化"><a href="#特定类型查询优化" class="headerlink" title="特定类型查询优化"></a>特定类型查询优化</h4><h5 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h5><p><code>COUNT()</code>可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用<code>COUNT(*)</code>时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用<code>COUNT(*)</code>，意义清晰，且性能更好。</p>
<p>有时候某些业务场景并不需要完全精确的<code>COUNT</code>值，可以用近似值来代替，EXPLAIN出来的行数就是一个不错的近似值，而且执行EXPLAIN并不需要真正地去执行查询，所以成本非常低。通常来说，执行<code>COUNT()</code>都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用redis这样的外部缓存系统。</p>
<h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用<code>JOIN</code>有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p>
<ul>
<li>  确保<code>ON</code>和<code>USING</code>字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li>
<li>  确保任何的<code>GROUP BY</code>和<code>ORDER BY</code>中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。</li>
</ul>
<p>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行<strong>嵌套循环关联</strong>操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p>
<p>太抽象了？以上面的示例来说明，比如有这样的一个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.xx,B.yy </span><br><span class="line">FROM A INNER JOIN B USING(c)</span><br><span class="line">WHERE A.xx IN (5,6)</span><br></pre></td></tr></table></figure>

<p>假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer_iterator &#x3D; SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);</span><br><span class="line">outer_row &#x3D; outer_iterator.next;</span><br><span class="line">while(outer_row) &#123;</span><br><span class="line">    inner_iterator &#x3D; SELECT B.yy FROM B WHERE B.c &#x3D; outer_row.c;</span><br><span class="line">    inner_row &#x3D; inner_iterator.next;</span><br><span class="line">    while(inner_row) &#123;</span><br><span class="line">        output[inner_row.yy,outer_row.xx];</span><br><span class="line">        inner_row &#x3D; inner_iterator.next;</span><br><span class="line">    &#125;</span><br><span class="line">    outer_row &#x3D; outer_iterator.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最外层的查询是根据<code>A.xx</code>列来查询的，<code>A.c</code>上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显<code>B.c</code>上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p>
<h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><p>当需要分页操作时，通常会使用<code>LIMIT</code>加上偏移量的办法实现，同时加上合适的<code>ORDER BY</code>字句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：<code>LIMIT 10000 20</code>这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure>

<p>如果这张表非常大，那么这个查询最好改成下面的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT film.film_id,film.description</span><br><span class="line">FROM film INNER JOIN (</span><br><span class="line">    SELECT film_id FROM film ORDER BY title LIMIT 50,5</span><br><span class="line">) AS tmp USING(film_id);</span><br></pre></td></tr></table></figure>

<p>这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用<code>OFFSET</code>，比如下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM t LIMIT 10000, 10;</span><br><span class="line">改为：</span><br><span class="line">SELECT id FROM t WHERE id &gt; 10000 LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<h5 id="优化UNION"><a href="#优化UNION" class="headerlink" title="优化UNION"></a>优化UNION</h5><p>MySQL处理<code>UNION</code>的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在<code>UNION</code>查询中都没有办法很好的时候。经常需要手动将<code>WHERE</code>、<code>LIMIT</code>、<code>ORDER BY</code>等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p>
<p>除非确实需要服务器去重，否则就一定要使用<code>UNION ALL</code>，如果没有<code>ALL</code>关键字，MySQL会给临时表加上<code>DISTINCT</code>选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p>
<p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p>
<ol>
<li><p> 有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</p>
</li>
<li><p> <code>JOIN</code>本身也挺方便的，直接查询就好了，为什么还需要视图呢？</p>
</li>
</ol>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2013<br>[2] Baron Scbwartz 等著；宁海元 周振兴等译；高性能MySQL（第三版）; 电子工业出版社， 2013<br>[3] <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004690721">由 B-/B+树看 MySQL索引结构</a></p>
<p>原文：<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/d7665192aaaf">http://www.jianshu.com/p/d7665192aaaf</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2018-11-17_Ubuntu%E5%8C%85%E9%94%99%E8%AF%AF%E6%88%96%E4%B8%8D%E4%B8%80%E8%87%B4%E6%97%B6%E7%9A%84%E6%B8%85%E7%90%86%E6%96%B9%E5%BC%8F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2018-11-17_Ubuntu%E5%8C%85%E9%94%99%E8%AF%AF%E6%88%96%E4%B8%8D%E4%B8%80%E8%87%B4%E6%97%B6%E7%9A%84%E6%B8%85%E7%90%86%E6%96%B9%E5%BC%8F.html" class="post-title-link" itemprop="url">Ubuntu 包错误或不一致时的清理方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-17 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-17T00:00:00+00:00">2018-11-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>命令模板：</p>
<pre><code>sudo mv /var/lib/dpkg/info/&lt;packagename&gt;.* /tmp/
sudo dpkg --remove --force-remove-reinstreq &lt;packagename&gt;
sudo apt-get remove &lt;packagename&gt;
sudo apt-get autoremove &amp;&amp; sudo apt-get autoclean</code></pre>
<p>清理Docker示例：</p>
<pre><code>sudo mv /var/lib/dpkg/info/docker.* /tmp/
sudo dpkg --remove --force-remove-reinstreq docker.io
sudo apt-get remove docker docker-ce docker.io containerd.io
sudo apt-get autoremove &amp;&amp; sudo apt-get autoclean</code></pre>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/148715/how-to-fix-package-is-in-a-very-bad-inconsistent-state-error/510887#510887">https://askubuntu.com/questions/148715/how-to-fix-package-is-in-a-very-bad-inconsistent-state-error/510887#510887</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/for-linux/issues/52#issuecomment-333563492">https://github.com/docker/for-linux/issues/52#issuecomment-333563492</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/advance/2018-11-05_java_vertx.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/advance/2018-11-05_java_vertx.html" class="post-title-link" itemprop="url">Vert.x - 从零开始变(micro)大拿</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-05T00:00:00+00:00">2018-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Java 进阶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Clement Escoffier, Julien Viet, 沈勇 译Version 0.6,Dec, 23th, 2017 原文：<a target="_blank" rel="noopener" href="http://escoffier.me/vertx-hol/">http://escoffier.me/vertx-hol/</a></p>
<hr>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>让我们从头开始…​. Vert.x . 什么是Vert.x? 这是一个好问题，也许是一个非常好的起点。 如果你访问了 <a target="_blank" rel="noopener" href="http://vertx.io/">Vert.x 网站</a>, Vert.x 的定义是 “用来在JVM上构建反应式（reactive）应用程序的工具箱”。 这个定义不是十分清楚，是吗？什么是 工具箱 ? 什么是 反应式（reactive)应用程序 ? 在这个实验里，我们将要讲解这些术语，并且用Vert.x建立一个应用程序，以此说明什么是Vert.x。这个应用程序是由一组 微服务(microservices) 组成的。再说这是一个流行趋势。不是吗？ 实际上，Vert.x已经极大的促进了 微服务(microservices) 。</p>
<p>我们要写的应用程序会是这样的：</p>
<ul>
<li><p>  基于 Vert.x (这是你为什么看这篇文章的愿意，对吧?)</p>
</li>
<li><p>  分布式的系统</p>
</li>
<li><p>  将要是反应式(reactive)系统</p>
</li>
<li><p>  可以让我们体会点儿乐趣</p>
</li>
</ul>
<p>这个练习可以让参加这得到一些 Vert.x 初级的，第一手的经验。从第一行代码开始，建立服务，消费服务并且最终吧所有的组件装配起来，秉承一个完整的反应式(reactive)系统。 这可以说明什么是反应式(reactive)系统。什么是反应式编程，怎么怎么基于多个反应式微服务 (reactive microservices) 构建应用程序。 多个反应式微服务，多个，这个很重要。</p>
<p>这个练习需要带上你的电脑。请带上你的Windows, OSX或者Linux电脑。我们需要 Apache Maven (3.3+)。</p>
<p>你将要学到什么：</p>
<ul>
<li><p>  什么是 Vert.x, 怎么使用异步非阻塞的并开发模式</p>
</li>
<li><p>  怎么使用Vert.x开发微服务。我们将使用多种微服务并且应用服务发现(service discovery)</p>
</li>
<li><p>  什么是 <code>verticles</code> 并且如何使用他们。</p>
</li>
<li><p>  怎么使用 Vert.x 事件总线发送，接收消息。</p>
</li>
<li><p>  怎么使用 Vert.x 暴露 HTTP 终结点，当然还有怎么消费它们。</p>
</li>
<li><p>  怎么组合使用异步操作</p>
</li>
<li><p>  怎么在同一个应用中使用多种语言</p>
</li>
<li><p>  怎么在 Vert.x 里操作数据库</p>
</li>
<li><p>  怎么在异步结果 (asymnc results), 未来返回(future)，异常处理器(exception handlers)和断路器(circuit broakers) 中处理故障</p>
</li>
<li><p>  怎么在 Vert.x 里使用 RxJava</p>
</li>
</ul>
<p>还有很多其他的知识，就不一一列举了…​</p>
<h2 id="2-Vert-x"><a href="#2-Vert-x" class="headerlink" title="2. Vert.x"></a>2. Vert.x</h2><p>我们会非常简要的介绍一下 Vert.x。你可能还记得，在上一章节，我们已经说过： Vert.x 是 “在JVM上构建反应式程序(reactive applications)的工具箱”。</p>
<p>这里有三个重点： 工具箱, 反应式 和 “基于JVM”.</p>
<p>首先，Vert.x是一个 工具箱。 这是说Vert.x并不是一个应用服务器，一个容器或者一个框架。 它也并不是一个JavaScript开发库。Vert.x是一个朴素的老的 <code>jar</code> 文件，所以一个Vert.x应用程序实际上是一个使用这个 <code>jar</code> 文件的程序。 Vert.x并不强制一个打包的方式。所有Vert.x 模块(components) 都是朴素 平淡 的 <code>jar</code> 文件。 这将怎样影响你的应用程序呢？让我们想象你在使用一个项目构建工具，比方说Maven或者Gradle, 去建立你的应用程许，一个 Vert.x 应用程序，其实就是吧 <code>vertx-core</code> 加入到依赖项里。 你想使用其他的 Vert.x 组件吗？请把它驾到你的依赖项里。这很简单，毫无负担，不是吗。 启动这个程序就是启动一个简单实现了 <code>public static void main(String[] args)</code> 的类。我们不需要任何特殊的IDE或者插件去安装和开始使用 Vert.x。</p>
<p>因此，使用 Vert.x 的精彩特性，你只需要把它写在你的代码里。但是稍等一下，我们很快就会用起来了。</p>
<p>其次， Vert.x 是 反应式 。它就是要用来建立反应式应用程序，或者更贴切的说法是 系统 。 反应式系统 [1] 在 <a target="_blank" rel="noopener" href="http://reactivemanifesto.org/">反应式宣言</a> 已经有了很好的定义。这虽然不是一个非常长的文档，我们还是把它缩减到一下四个要点：</p>
<ul>
<li><p>  及时相应：一个反应式系统需要在 合理 的时间处理请求 (你可以根据应用场景自己定义 合理 )。</p>
</li>
<li><p>  有弹性： 一个反应式系统必须在出现 故障 (崩溃，超时， <code>500</code> 错误 …​) 的情况下，仍然及时作出相应。系统的是 为了故障而设计的 并且能够合理的处理故障。</p>
</li>
<li><p>  有灵活性: 一个反应式系统必须在不同负载情况下及时相应。因此，它必须能够向上，向下扩展。并且能够在极小资源的情况下处理一定的负载。</p>
</li>
<li><p>  消息驱动: 反应式系统里的各个组件之间，通过 异步消息传递 相互作用。</p>
</li>
</ul>
<p>再次，Vert.x 是一个事件驱动和非阻塞的。事件被投递到一个 永不阻塞的 事件循环 里。为什么呢？不象传统系统，象 “企业级” 系统，Vert.x只使用非常少的线程。 有一些线程是 事件循环, 它们在 <code>处理器（Handlers）</code> 之间派发事件。如果你把某个线程阻塞了，事件将不能继续派发。这个执行模式将影响你如何写代码，不同于 传统mofrl 阻塞代码，你的代码将是异步的 [2] 和非阻塞的 [3]</p>
<p>举一个例子，如果你要得到一个基于URL的资源，你需要这么做：</p>
<pre><code>    URL site = new URL(&quot;http://vertx.io/&quot;);
    BufferedReader in = new BufferedReader(new InputStreamReader(site.openStream()));
    String inputLine;
    while ((inputLine = in.readLine()) != null) &#123;
        System.out.println(inputLine);
    &#125;
    in.close();</code></pre>
<p>但是用 Vert.x 的话，你就需要这么做：</p>
<pre><code>    vertx.createHttpClient().getNow(80, &quot;vertx.io&quot;, &quot;&quot;, response -&gt; &#123;
        response.bodyHandler(System.out::println);
    &#125;);</code></pre>
<p>这两段代码有以下不同：</p>
<ul>
<li><p>  第一个用的是同步调用的并且有可能被阻塞：所有指令都是 顺序 执行的,而且可能把线程阻塞相当长的一段时间(因为网站本身可能会很慢)。</p>
</li>
<li><p>  基于 Vert.x 的程序是异步和非阻塞的：在和HTTP服务器建立连接的过程中，线程(事件循环)本身已经被释放了，所以它可以做其他的工作。当响应返回的时候， 那个相同 的事件循环会调用 回调函数。大多数的 Vert.x 组件都是单线程的(只有一个线程去访问它)，所以不需要任何同步机制。另外，使用 Vert.x ，象 DNS 解析这样的事件都是异步和非阻塞的 (其实Java DNS解析是阻塞的)。</p>
</li>
</ul>
<p>最后，Vert.x 应用是运行在 “JVM之上” ，Java虚拟机版本8以上。 这说明 Vert.x 应用程序可以使用任何可以运行在 JVM 上的语言开发。这包括 Java (当然如此), Groovy, Ceylon, Ruby, JavaScript, Kotlin 和 Scala 。 我们甚至可以把所有这些语言混合成任意组合。Vert.x 程序的多语言的特性可以让我们使用在具体任务中使用适合的语言。</p>
<p>Vert.x 让你实现的分布式应用，可以使用内建的 TCP 和 HTTP 服务器和客户端，也可以让你使用 Vert.x 事件总线，这是一个轻量级的收发消息的机制。 使用事件总线，我们可以发送消息到 <code>地址(address)</code> 。它支持一下三种分布模式： </p>
<ol>
<li><p> 点对点 ： 消息指发送给一个监听这个地址上的 消费者(consumer) 。</p>
</li>
<li><p> 发布/订阅 ： 消息会被所有监听在这个地址上的所有 消费者(consumer) 收到。</p>
</li>
<li><p> 请求/应答 ： 消息回发送给一个 消费者(consumer) , 它 应答 这个消息并且把另外一个 消息 发送回初始的发送者。</p>
</li>
</ol>
<p>哇唔！，这已经有很多信息需要同学们消化了…​ 但是，你可能还要追问：我用 Vert.x 可以建立什么样的应用？ 我们会说， Vert.x 是难以置信的灵活，简单的网络工具，复杂的现代Web应用， HTTP/REST 微服务，高强度的事件处理或者负载高企的后端消息总线应用，Vert.x 都能非常好的适应。 它真的非常快，不会限制你。最后一点，但不是最无赶紧要的一点， Vert.x提供合适的工具去构建反应式系统；及时响应, 灵活的, 有弹性和异步 的系统。</p>
<h2 id="3-揭开微服务-microservice-的神秘面纱"><a href="#3-揭开微服务-microservice-的神秘面纱" class="headerlink" title="3. 揭开微服务(microservice)的神秘面纱"></a>3. 揭开微服务(microservice)的神秘面纱</h2><p>除非你之前两年一直在山洞里生活，你肯能已经听说过 微服务(microservices) 。 那么，什么是 微服务 呢？ 为了回答这个问题，让我们看看老鸟怎么说：</p>
<blockquote>
<p>微服务架构风格是通过一组小服务来构建一个应用程序的方法。每个服务运行在他自己的进程里，它们通过轻量级的机制相互通信，通常是 HTTP 资源 API。 这些服务对应这业务要求，并且每个服务可以独立的使用全自动方式部署。 这里极少需要的中心化管理这些服务。它们很有可能是用不同的编程语言编写，并且有可能使用完全不同的存储技术。</p>
</blockquote>
<p>— Martin Fowler<a target="_blank" rel="noopener" href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></p>
<p>微服务 是一种 架构风格 ，这说明它是一个 元素和关系类型的规范，加上限制条件和如何使用它们的方法 [4]。我相信到此为止，我让你比刚开始更摸不到头脑了。</p>
<p>不用担心。我们从另外的方式来说明。 我们为什么需要 微服务 ？ 三个字 灵活性 [5]。 让我们想象一下，我们有一个挺大的应用。 像任何一个大的应用一样，维护它就像一个噩梦。增加功能需要太长的时间。 很多过时的技术还在线上(什么？Corba已经不时髦了吗？)，任何改变都需要执行一个50个步骤组成的流程，并且需要5个层级的管理组织来确认。 很明显，我们需要几个组在这个应用上工作，它们有不同的需求和日程表。好吧，这个应用就是 怪兽级应用 。 我们怎么才能让开发和维护这个系统更有效呢？ 微服务就是这个问题的一个答案。它就是要减少 上线时间 。</p>
<p>为了做到这一点， 微服务 架构风格建议如下几点：</p>
<ol>
<li><p> 把应用本身分割成一个相互不耦合的组件集合。每个组件都提供事先定义好的 <code>服务</code> (定义好的 是说一个已知的接口或者API)</p>
</li>
<li><p> 允许组件之间可以选择任意通信协议。REST可能经常用到，但是不是必须的。</p>
</li>
<li><p> 允许使用任意的编程语言和技术去实现组件。</p>
</li>
<li><p> 允许任何一个组件独立的开发，发布和部署。</p>
</li>
<li><p> 允许部署方法是给予组件选择的 流水线 自动化的 完成。</p>
</li>
<li><p> 允许整个应用的整体协调机制可以缩减到最小。</p>
</li>
</ol>
<p>在这个实验课，我们不会涉及到第5点，但是你很容易理解 Vert.x 并不会限制你怎么部署你的组件。 你可以应用任何你觉得最适合你的系统环境的方式部署，比方说 ssh, ansible, puppet, docker, cloud, fabric8 甚至是用软盘。</p>
<p>第6点，尽管它很有意思，但同时经常被误解。开发相互独立的几个软件并且神奇地在运行时相互协作，这不是很酷吗？是的，技术上讲，我说的 神奇地 并不是魔术。 为了能够让他们一起工作，我们需要运行时的服务 发现 。服务发现机制可以用各种方式做到。我们能够考虑到的有：对服务地址硬编码(这通常不是一个好主意)，使用 DNS 检索服务，或者其它高科技方法。</p>
<p>有一个服务发现机制存在的情况下，我们系统中的各个组件之间可以在不同位置和环境之间透明的相互交互。我们也可以很容易的在组件之间负载平衡，比方说使用轮叫方式，这也可以在一定程度上提高系统对故障的容忍度(我们可以在一个服务提供者失效的情况下，使用另外一个)。</p>
<p>虽然微服务理论上没有必要是分布式的，但是它经常是分布式的。它具有分布式系统所有的优点和限制：共识算法（FLP），CAP理论，一致性，系统监视，和其他出现故障的可能行。所以，微服务应用需 要从一开始就要涉及如何处理故障。</p>
<p>在我们继续之前，还有几个需要讲的点： 微服务 不 是一个高科技的新概念。70年代，80年代的学术论文已经定义了非常类似的架构风格。当然他们用的是不同的词。 一个需要理解的重点是：微服务不是银弹。除非精心管理，它有可能提高你应用的复杂性，因为这是一个分布式的架构。最后，一个微服务架构不肯能包治百病。</p>
<p>如果微服务可以快速发布，适配好，独立，和可替换的话，我们还会严重担心。每个微服务在建立指出都可以被其他提供相同 服务 / API / 接口 替代。 (本质上，这就是一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a> 应用)。</p>
<p>如果你已经干开发10年了，你可能会问微服务和SOA的不同之处。对很多人来说，大小是一个不同点。但这并不准确，一个服务并不一定非常小，“微服务”这个词有时候也会引起误解。微服务和SOA的目的不同，但是有很多相同点：</p>
<ul>
<li><p>  服务： 一个可以用API，客户端或代理等访问的定义好的功能</p>
</li>
<li><p>  服务提供者：一个组件提供了一个服务</p>
</li>
<li><p>  服务消费者：一个组件在消费一个服务</p>
</li>
<li><p>  服务发现：一个机制用来让消费者找到提供者</p>
</li>
</ul>
<p>这两种概念都是从 面向服务计算 继承下来的。它们都关注解分解和管理独立软件模块。你有可能没有听说过但是可能用过这些技术：COM, Corba, Jini, OSGi, 和 Web Service。它们都是不同的 面向服务计算 的具体实现。</p>
<p>最后，有些人会晤解微服务必须是 RESTful 的。这不是事实。微服务可以依赖不同的交互风格，当然最适合的是： RPC， 事件，消息，流，等等。在这个实验课，我们会使用 RESTful 服务，异步 RPC 和消息源。</p>
<h2 id="4-微交易员应用"><a href="#4-微交易员应用" class="headerlink" title="4. 微交易员应用"></a>4. 微交易员应用</h2><p>现在你了解了 Vert.x和微服务。是时候开始讨论我们需要在实验课实现的程序了。</p>
<p>这是一个假金融程序，它会赚虚拟货币。应用本事是一组微服务构成的:</p>
<ul>
<li><p>  报价生成器(quote generator) - 这是一个不现实的模拟器，它会生成三个虚构公司的股票报价。MicroHard, Divinator, 和 Black Coat 。市场信息会被发不到 Vert.x 事件总线上。</p>
</li>
<li><p>  交易员(traders) - 有几个组件是在接受从报价生成器发布的报价，他们会决定买卖某个特定股票。为了能够作决定，它们依赖 投资组合(portfolio) 服务。</p>
</li>
<li><p>  投资组合(portfolio) - 这个服务管理着投资组合里的所有股票和他们的价值。它暴露了一个 服务代理(service proxy), 也就是一个在 Vert.x 事件总线上的异步RPC服务。每一个成功的操作，它都会发送一个消息到事件总线上。它使用报价生成器来计算当前投资组合的价值。</p>
</li>
<li><p>  审计(audit) - 这是法律要求的。我们需要需要记录所有的操作。审计组件会从时间总线和地址上接收所有投资组合服务的操作。它会把这些信息写到数据库里。它还会提供一个 REST 端点来让其它组件获得最后的几笔操作。</p>
</li>
<li><p>  仪表盘(dashboard) - 这个图形界面会让你看到自己在变得富有。：）</p>
</li>
</ul>
<p>我们可以看一下架构：<br><img src="./2018-11-05_java_vertx/1.png" alt="微交易员系统架构"> </p>
<p>这个应用使用了以下集中类型的服务:</p>
<ul>
<li><p>  HTTP 端点(endpoint) - 像 REST API 这个服务可以通过 HTTP URL 找到。</p>
</li>
<li><p>  服务代理 - 这是暴露在事件总线上的异步服务。它使用了 RPC 交互机制。这种服务可以通过事件总线上的地址找到。</p>
</li>
<li><p>  服务源(Message sources) - 这些组件会像事件总线上发布消息。这种服务可以通过事件总线上的地址找到。</p>
</li>
</ul>
<p>这些组件都在同一个网络环境上运行(在这个实验课里，它们是在同一台机器上的不同进程而已）。</p>
<p>仪表盘会显示所有可用的服务，每个公司的报价，我们交易员最后几笔交易操作，和当前投资组合的状态。它同时还显示不同代理的状态信息。</p>
<p><img src="./2018-11-05_java_vertx/2.png" alt="仪表盘"></p>
<p>虽然已经有一些代码显示了 Vert.x 的功能，我们将要亲自实现这个应用的关键部分。需要我们写的代码都被清除的标明 TODO，就像下面的例子：</p>
<pre><code>//TODO// ----// your code here// ----</code></pre>
<h2 id="5-预先准备"><a href="#5-预先准备" class="headerlink" title="5. 预先准备"></a>5. 预先准备</h2><p>我们要学习新知识，马上就要编程序了…​ 但是，在我们开始之前，我们需要安装一些软件。</p>
<h3 id="5-1-硬件"><a href="#5-1-硬件" class="headerlink" title="5.1. 硬件"></a>5.1. 硬件</h3><ul>
<li><p>  操作系统: Mac OS X (10.8+), Windows 7+, Ubuntu 12+, CentOS 7+, Fedora 22+</p>
</li>
<li><p>  内存: 至少需要 4 GB+, 最好 8 GB</p>
</li>
</ul>
<h3 id="5-2-Java开发工具包"><a href="#5-2-Java开发工具包" class="headerlink" title="5.2. Java开发工具包"></a>5.2. Java开发工具包</h3><p>我们需要安装 JDK 8+。 最新的 JDK 可以从一下链接下载:</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle JDK 8</a></li>
</ul>
<p>你可以使用 Oracle JDK 或者 OpenJDK。</p>
<h3 id="5-3-Maven"><a href="#5-3-Maven" class="headerlink" title="5.3. Maven"></a>5.3. Maven</h3><ul>
<li><p>  你可以从这里下载 <a target="_blank" rel="noopener" href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a> 。</p>
</li>
<li><p>  解压到一个目录下以后，把它驾到你的 <code>PATH</code> 环境变量里。</p>
</li>
</ul>
<h3 id="5-4-IDE"><a href="#5-4-IDE" class="headerlink" title="5.4. IDE"></a>5.4. IDE</h3><p>我们推荐你使用 IDE. 你可以使用 Eclipse, IntelliJ 或者 Netbeans。</p>
<h4 id="5-4-1-没有-IDE"><a href="#5-4-1-没有-IDE" class="headerlink" title="5.4.1. 没有 IDE ?"></a>5.4.1. 没有 IDE ?</h4><p>如果你没有 IDE, 一下步骤可以让你准备好 Eclipse。</p>
<ol>
<li><p> 从这里 <a target="_blank" rel="noopener" href="https://www.eclipse.org/downloads/">下载页面</a> 下载 Eclipse.</p>
</li>
<li><p> 在 Eclipse Package 列表, 选择 Eclipse IDE for Java Developers 。他会把你带到一个有 <code>Download</code> 按钮的页面。</p>
</li>
<li><p> 下载之后解压。</p>
</li>
<li><p> 在目标路径里，你可以找到 <code>Eclipse</code> 执行程序。运行它就好了。</p>
</li>
<li><p> Eclipse 会问你需不需要建立一个工作空间。</p>
</li>
<li><p> 打开 Eclipse 之后点 Workbench 箭头 (在右上角).</p>
</li>
</ol>
<h2 id="6-我们开始"><a href="#6-我们开始" class="headerlink" title="6. 我们开始 !"></a>6. 我们开始 !</h2><h3 id="6-1-获取代码"><a href="#6-1-获取代码" class="headerlink" title="6.1. 获取代码"></a>6.1. 获取代码</h3><pre><code>git clone https://github.com/cescoffier/vertx-microservices-workshop</code></pre>
<p>你可以把代码作为 Maven 导入到 IDE 里。你可以参考 IDE 的文档。</p>
<p>对与 Eclipse:</p>
<ol>
<li><p> 点击 <code>File - Import …​ - Maven - Existing Maven Projects</code></p>
</li>
<li><p> 选择你克隆源代码的位置</p>
</li>
<li><p> 点击 Finish 并且稍等…​</p>
</li>
</ol>
<p>你会看到几个编译错误。这是因为 Eclipse 默认设置没有把 <code>src/main/generated</code> 作为 源代码跟路径(source root) 。 右键点击 <code>portfolio-service/src/main/generated</code> 并且选择 Build Path → Use as Source Folder.</p>
<p>完整的解决方案在 <code>solution</code> 路径下.</p>
<h3 id="6-2-编译打包"><a href="#6-2-编译打包" class="headerlink" title="6.2. 编译打包"></a>6.2. 编译打包</h3><p>整个构建过程是由 Apache Maven 管理的。 编译整个应用，你只需要：</p>
<pre><code>cd vertx-microservices-workshop
mvn clean install</code></pre>
<p>我们之前说过， Vert.x 不依赖 Apache Maven 。 你可以使用任何构建工具 (甚至不需要构建工具) 。</p>
<h3 id="6-3-集群和服务发现基础设施"><a href="#6-3-集群和服务发现基础设施" class="headerlink" title="6.3. 集群和服务发现基础设施"></a>6.3. 集群和服务发现基础设施</h3><p>现在差不多可以开始了。如果你还记得在微服务那一章节，我们需要服务发现机制。非常幸运的是， Vert.x 提供了这种机制。 为了让每个组件发现服务，它需要把服务的 记录(record) 存储在某个可以访问到的地方。</p>
<p>默认配置情况下， Vert.x 服务发现机制会使用分布式映射(map)，它可以被所有的集群成员访问到。 所以当你启动 Vert.x 应用程序并且开启集群模式的时候，它会加入一个集群。 这个集群里的节点都可以：</p>
<ul>
<li><p>  加入和离开这个集群，也就是管理 成员(menber) 路径。(成员 != 服务)</p>
</li>
<li><p>  通过分布式映射，锁，计数器等分享数据</p>
</li>
<li><p>  访问事件总线</p>
</li>
</ul>
<p>在我们的上下文里，我们不需要配置什么。这个实验课材料里已经给出了集群的配置。它是基于单点通讯并使用 <code>127.0.0.1</code> IP 地址。(因此你不能在相邻的计算机上找到这些服务)。这个集群是基于 Hazelcast。如果你感兴趣的话，请查看配置文件 <code>vertx-workshop-common/src/main/resources/cluster.xml</code>。</p>
<h2 id="7-第一个微服务-报价生成器"><a href="#7-第一个微服务-报价生成器" class="headerlink" title="7. 第一个微服务 - 报价生成器"></a>7. 第一个微服务 - 报价生成器</h2><p>免责声明，这个报价生成器纯属虚构，报价全部是随机生成…​</p>
<h3 id="7-1-项目结构"><a href="#7-1-项目结构" class="headerlink" title="7.1. 项目结构"></a>7.1. 项目结构</h3><p>让我们看一下这个项目，所有项目都有类似的结构。</p>
<pre><code>    ├── README.md &lt;--- 组件的描述
    ├── pom.xml &lt;--- Maven 文件
    └── src
        ├── conf
        │   └── config.json &lt;--- 项目配置文件，应用程序在启动时要加载配置项
        └── main
            └── java
                └── io.vertx.workshop.quote
                                ├── GeneratorConfigVerticle.java &lt;--- 竖直体(Vertical)
                                ├── QuoteVerticle.java
                                └── RestQuoteAPIVerticle.java</code></pre>
<p>让我们从 <code>pom.xml</code> 文件开始。文件定义了 Maven 如何编译打包：</p>
<ol>
<li><p> 定义依赖项</p>
</li>
<li><p> 编译java代码和处理资源(如果有的话)</p>
</li>
<li><p> 构建胖jar包 fat-jar</p>
</li>
</ol>
<p>一个胖jar包 fat-jar (也叫 uber jar 或者 shaded jar) 是一个方便打包 Vert.x 应用程序的方法。 它生成一个包含应用程序和所有依赖项的 uber-jar ，当然也有 Vert.x。然后，你只需要 <code>java -jar</code> 命令来启动这个程序，这样省去了 <code>CLASSPATH</code> 的配置。 等一下，我们说过，Vert.x 并不需要特定的打包方式。这确实是对的。 胖jar包只是为了方便，你也可以用普通jar包，OSGi 捆(budles)。</p>
<p>创建出的 fat-jar 使用了一个相同的主类，它 (<code>io.vertx.workshop.common.Launcher</code>) 在 <code>vertx-workshop-common</code> 里已经提供了。 这个 <code>Launcher</code> 类会启动 Vert.x 实例，配置它，并且部署 主竖直体(main-verticle)。 在此说明，这只是为了方便，你可以写你自己的 主(main) 类。</p>
<h3 id="7-2-竖直体-Verticle"><a href="#7-2-竖直体-Verticle" class="headerlink" title="7.2. 竖直体(Verticle)"></a>7.2. 竖直体(Verticle)</h3><p>你也许已经注意到了，代码由三个 <code>竖直体(verticles)</code> 组成。但是它们是什么？竖直体是一种 Vert.x 应用代码的结构。 这不是必须的，但是这确实非常方便。一个竖直体是部署在 Vert.x 实例之上的一段代码。 一个竖直体可以访问它部署到的 <code>vertx</code> 实例。它也可以部署其他竖直体。</p>
<p>让我们打开 <code>GeneratorConfigVerticle</code> 类，并且看一下 <code>start</code> 方法。</p>
<pre><code>@Override
public void start() &#123;
    super.start();
    JsonArray quotes = config().getJsonArray(&quot;companies&quot;);
    for (Object q : quotes) &#123;
        JsonObject company = (JsonObject) q;      // 使用配置参数启动竖直体      
        vertx.deployVerticle(MarketDataVerticle.class.getName(), new DeploymentOptions().setConfig(company));
    &#125;
    vertx.deployVerticle(RestQuoteAPIVerticle.class.getName());
    publishMessageSource(&quot;market-data&quot;, ADDRESS, rec -&gt; &#123;
        if (!rec.succeeded()) &#123;
            rec.cause().printStackTrace();
        &#125;
        System.out.println(&quot;Market-Data service published : &quot; + rec.succeeded());
    &#125;);
    publishHttpEndpoint(&quot;quotes&quot;, &quot;localhost&quot;, config().getInteger(&quot;http.port&quot;, 8080), ar -&gt; &#123;
        if (ar.failed()) &#123;
            ar.cause().printStackTrace();
        &#125; else &#123;
            System.out.println(&quot;Quotes (Rest endpoint) service published : &quot; + ar.succeeded());
        &#125;
    &#125;);
&#125;</code></pre>
<p>竖直体可以通过 <code>config()</code> 方法得到配置参数。这里它的到了需要模拟的公司的详细信息。 配置参数是通过 <code>JsonObject</code> 传递的。 Vert.x 经常使用 JSON，所以你将在这个实现课里看到非常多的 JSON。 对每个配置参数里的公司，这个竖直体都会部署另一个相应的竖直体，传入提取的配置参数。 最后，这个竖直体，部署另外一个竖直体来提供一个简单的 HTTP API。</p>
<p>这个函数的剩余部分和服务发现有关系。我们在微服务章节提到过服务发现。 这个组件生成报价信息，并且发送到事件总线上。为了让其他的组件得知消息发送到什么地方 (消息发送地址），它注册地址。 <code>market-data</code> 就是这个服务的地址， <code>ADDRESS</code> 是事件总线的地址，消息将发送到这个地址上。 最后一个参数是一个 <code>处理器(Handler)</code>， 它会在注册完成之后被触发。 <code>handler</code> 会收到一个 <code>AsyncResult</code> 结构体。</p>
<p>请记住， Vert.x 是在提倡异步，非阻塞开发风格。发布服务会花时间 (实际上，它会建立一个记录，并把这个记录写到后端，然后通知所有人), 我们不能阻塞事件循环，所以这个方法也是异步的。异步方法都会有一个 <code>Handler</code> 作为最后一个参数，它会在操作完成之后被调用。 这个 <code>Handler</code> 收到一个 <code>AsyncResult</code>，表示操作成功与否。你将要在 Vert.x 里看到很多这样的模式：</p>
<pre><code>    // 返回 X 类型的一个对象的异步方法。 
    operation(param1, param2, Handler &lt; AsyncResult &lt; X &gt;&gt; );
    // 收到X 类型的一个对象的处理器。  
    ar -&gt; &#123;
        if (ar.succeeded()) &#123;
            // 用 X 继续做工作。   
            X x = ar.result();      
        &#125; else &#123;
            // 操作失败了。      
            Throwable cause = ar.cause();
        &#125;
    &#125;</code></pre>
<p>如果你还记得程序的架构，报价生成器也会提供一个 HTTP 端点来返回报价的最新值 (你会实现它)。 像上一个服务一样，它需要被发布。为了发布，我们给出了它的详细位置 (服务器地址，端口…​):</p>
<pre><code>    publishHttpEndpoint(&quot;quotes&quot;, &quot;localhost&quot;, config().getInteger(&quot;http.port&quot;, 8080), ar -&gt; &#123;
        if (ar.failed()) &#123;
            ar.cause().printStackTrace();
        &#125; else &#123;
            System.out.println(&quot;Quotes (Rest endpoint) service published : &quot; + ar.succeeded());
        &#125;
    &#125;);</code></pre>
<h3 id="7-3-REST-报价服务端点"><a href="#7-3-REST-报价服务端点" class="headerlink" title="7.3. REST 报价服务端点"></a>7.3. REST 报价服务端点</h3><p>是时候开发这个程序的一些部分了(你手里已经有需要工具了)。请打开 <code>RestQuoteAPIVerticle</code>。这是一个从 <code>AbstractVerticle</code> 扩充的竖直体。 在 <code>start</code> 方法，你需要：</p>
<ol>
<li><p> 注册一个事件总线的消费者来收集最新的报价信息 ( 从`quotes` 映射)。</p>
</li>
<li><p> 接收 HTTP 请求，并且返回报价列表，或者当 <code>name</code> 被指定的情况下返回单个公司的报价。</p>
</li>
</ol>
<p>开工…​.</p>
<h4 id="7-3-1-任务-实现一个接收事件的处理器"><a href="#7-3-1-任务-实现一个接收事件的处理器" class="headerlink" title="7.3.1. 任务 - 实现一个接收事件的处理器"></a>7.3.1. 任务 - 实现一个接收事件的处理器</h4><p>第一个任务是建立一个 <code>处理器(Handler)</code>，这是一个事件到达时被调用的方法。处理器是 Vert.x 非常重要的的部分，所以理解它们很重要。</p>
<p>在这个任务里，任何一个消息送达到 <code>address</code> 指定的事件总线(它接收每一个从报价生成器产生的报价)时，<code>Handler</code> 就会被调用。 他是一个 消息消费者 (message consumer) 。 <code>message</code> 参数就是收到的消息。</p>
<p>实现的逻辑就是收到消息体(通过 <code>body()</code> 方法)。然后获取消息体中报价的 <code>name</code>， 然后在 <code>quotes</code> 映射里添加一个 <code>name → quote</code> 的条目。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><pre><code>JsonObject quote = message.body(); // 1
quotes.put(quote.getString(&quot;name&quot;), quote); // 2</code></pre>
<p>首先，它得到了消息体 (1)。这是一个 JSON 对象。然后把它存储到 <code>quotes</code> 映射里 (2)。</p>
<h4 id="7-3-2-任务-实现一个处理-HTTP-请求的处理器"><a href="#7-3-2-任务-实现一个处理-HTTP-请求的处理器" class="headerlink" title="7.3.2. 任务 - 实现一个处理 HTTP 请求的处理器"></a>7.3.2. 任务 - 实现一个处理 HTTP 请求的处理器</h4><p>现在你已经实现了第一个 <code>Handler</code>，让我们实现第二个。这个处理器不从事件总线获得消息，而是获得 HTTP 请求。 这个服务器绑定在 HTTP 服务器上。它会在每次 HTTP 请求到达这个服务器的时候背调到。它负责写响应。</p>
<p>为了处理 HTTP 请求，我们需要 HTTP 服务器。幸运的是，Vert.x 可以让你用以下方法建立 HTTP 服务：</p>
<pre><code>    vertx.createHttpServer().requestHandler(request -&gt; &#123;...&#125;).listen(port, resultHandler);</code></pre>
<p>请求处理器会做以下步骤来产生响应的内容： Write the content of the request handler to respond to the request:</p>
<ol>
<li><p> 请求需要在消息头里把 <code>content-type</code> 设置成 <code>application/json</code>。</p>
</li>
<li><p> 获取 <code>name</code> 参数，这是一个公司名。</p>
</li>
<li><p> 如果公司名没有设置，通过 json 格式返回所有的报价。</p>
</li>
<li><p> 如果公司名设置了，返回存储的报价信息，或者在不知道公司名的情况下返回 404。</p>
</li>
</ol>
<p>我们可以通过 <code>request.response()</code> 拿到一个请求的响应。</p>
<p>我们通过 <code>response.end(content)</code> 给响应写入内容。</p>
<p>为了生成 JSON 表示的对象，我们使用 <code>Json.encode</code> 方法。</p>
<pre><code>    HttpServerResponse response = request.response().putHeader(&quot;content-type&quot;, &quot;application/json&quot;);
    String company = request.getParam(&quot;name&quot;);
    if (company == null) &#123;
        String content = Json.encodePrettily(quotes);
        response.end(content);
    &#125; else &#123;
        JsonObject quote = quotes.get(company);
        if (quote == null) &#123;
            response.setStatusCode(404).end();
        &#125; else &#123;
            response.end(quote.encodePrettily());
        &#125;
    &#125;</code></pre>
<p>从 <code>request</code> 对象里拿到 <code>response</code></p>
<p>获得 <code>name</code> 参数 (查询参数)</p>
<p>把映射编码成 JSON 格式</p>
<p>用 <code>end(…​)</code> 把响应写入并刷新它</p>
<p>如果名字不能匹配出一个公司，设置状态值 <code>404</code></p>
<p>你有可能疑惑为什么不需要同步。实际上，我们读写映射时，没有使用任何同步机制。 这其实是 Vert.x 的一个主要特性： 所有这些代码会在 同一个 事件循环中运行。所以它永远被 同一个 线程访问。不会有有并发。</p>
<p><code>Map&lt;String, JsonObject&gt;</code> 也可以被简单替换成 <code>JsonObject</code> 他基本上就是 <code>Map&lt;String, Object&gt;</code>。</p>
<h3 id="7-4-是时候启动报价生成器了"><a href="#7-4-是时候启动报价生成器了" class="headerlink" title="7.4. 是时候启动报价生成器了"></a>7.4. 是时候启动报价生成器了</h3><p>现在，我们把这个微服务编译打包成 fat-jar. 在终端:</p>
<pre><code>cd quote-generator
mvn package</code></pre>
<p>然后，打开一个新的终端并且启动它：</p>
<pre><code>java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar</code></pre>
<p>这个命令启动了应用程序。主类创建了一个集群化的 Vert.x 实例，并且从 <code>src/conf/config.json</code> 里读取配置参数。 这个配置提供了 REST 服务需要的 HTTP 端口 (<code>35000</code>)。</p>
<p>我们可以打开浏览器看一下链接 <a target="_blank" rel="noopener" href="http://localhost:35000/">http://localhost:35000</a> 。</p>
<p>返回的内容看起来应该是：</p>
<pre><code>&#123;
  &quot;MacroHard&quot;: &#123;
    &quot;volume&quot;: 100000,
    &quot;shares&quot;: 51351,
    &quot;symbol&quot;: &quot;MCH&quot;,
    &quot;name&quot;: &quot;MacroHard&quot;,
    &quot;ask&quot;: 655.0,
    &quot;bid&quot;: 666.0,
    &quot;open&quot;: 600.0
  &#125;,
  &quot;Black Coat&quot;: &#123;
    &quot;volume&quot;: 90000,
    &quot;shares&quot;: 45889,
    &quot;symbol&quot;: &quot;BCT&quot;,
    &quot;name&quot;: &quot;Black Coat&quot;,
    &quot;ask&quot;: 654.0,
    &quot;bid&quot;: 641.0,
    &quot;open&quot;: 300.0
  &#125;,
  &quot;Divinator&quot;: &#123;
    &quot;volume&quot;: 500000,
    &quot;shares&quot;: 251415,
    &quot;symbol&quot;: &quot;DVN&quot;,
    &quot;name&quot;: &quot;Divinator&quot;,
    &quot;ask&quot;: 877.0,
    &quot;bid&quot;: 868.0,
    &quot;open&quot;: 800.0
  &#125;
&#125;</code></pre>
<p>它给了当前报价的详情。报价将会每3秒更新一次。你可以刷新你的浏览器来得到最新的数据。</p>
<p>我们可以启动仪表盘。在另外一个终端，进入 <code>$project-home/trader-dashboard</code> 路径并且执行下面的命令：</p>
<pre><code>mvn clean package
java -jar target/trader-dashboard-1.0-SNAPSHOT-fat.jar</code></pre>
<p>接着，打开浏览器访问 <a href="http://localhost:8080。你应该能看到：">http://localhost:8080。你应该能看到：</a></p>
<p><img src="./2018-11-05_java_vertx/3.png" alt="Dashboard"></p>
<p>有一些部分还没有内容，在一开始这不意外…​</p>
<h3 id="7-5-你不是金融专家"><a href="#7-5-你不是金融专家" class="headerlink" title="7.5. 你不是金融专家 ?"></a>7.5. 你不是金融专家 ?</h3><p>也许你没有习惯金融和他的专业名字…​ 我也没有，我们讨论的范围金融是非常简化的版本。 为了方便理解，让我们定义哪些非常重要的字段。</p>
<ul>
<li><p>  <code>name</code> : 公司名</p>
</li>
<li><p>  <code>symbol</code> : 公司名缩写</p>
</li>
<li><p>  <code>shares</code> : 股票的数量，我们可以购买它</p>
</li>
<li><p>  <code>open</code> : 股票在开盘时的价格</p>
</li>
<li><p>  <code>ask</code> : 股票在你买的时候的价格，既卖价</p>
</li>
<li><p>  <code>bid</code> : 股票在你卖的时候的价格，既买价</p>
</li>
</ul>
<p>你可以访问 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Financial_quote">Wikipedia</a> 得到更详细的说明。</p>
<h2 id="8-事件总线服务-投资组合服务"><a href="#8-事件总线服务-投资组合服务" class="headerlink" title="8. 事件总线服务 - 投资组合服务"></a>8. 事件总线服务 - 投资组合服务</h2><p>在报价生成器里，我们已经尝试了一些基础的 Vert.x 开发：</p>
<ul>
<li><p>  异步 API 和 <code>AsyncResult</code></p>
</li>
<li><p>  实现处理器 <code>Handler</code></p>
</li>
<li><p>  从事件总线上接收消息</p>
</li>
</ul>
<p>在投资组合组件里，我们将要实现一个 事件总线服务(event bus service)。一个 <code>投资组合(Portfolio)</code> 存储了拥有的股份和可用的现金。</p>
<h3 id="8-1-远程过程调用-RPC-和异步远程过程调用"><a href="#8-1-远程过程调用-RPC-和异步远程过程调用" class="headerlink" title="8.1. 远程过程调用(RPC) 和异步远程过程调用"></a>8.1. 远程过程调用(RPC) 和异步远程过程调用</h3><p>微服务不仅是关于 REST。它可以用不同的交互操作方式暴露出来。 并且 远程过程调用 就是其中的一种。 通过 RPC ，一个组件可以使用本地调用有效的发送一个请求到另外一个组件，请求会被打包到一个消息里并且发送给被调用者。 结果会以类似的方式发送回调用者作为过程调用的结果。</p>
<p><img src="./2018-11-05_java_vertx/4.png" alt="4.png"></p>
<p>这样的互操作的好处是强类型。这比非结构化的消息减少了出问题的可能性。但是，这使调用者和被调用者之间的耦合增强了。调用者要知道怎么调用：</p>
<ol>
<li><p> 怎么调用这个服务</p>
</li>
<li><p> 这个服务运行在哪里？</p>
</li>
</ol>
<p>传统的 RPC 有一个讨厌的缺点： 调用者必须等待，直到接收到应答。一次调用至少需要两个网络消息，这明显是一个阻塞的调用。 另外，这不能很好的处理分布式通信中各个环节都可能出现的故障。</p>
<p>幸运的是，Vert.x 提供了一个不同方式的 RPC ：异步 RPC。 异步 RPC 和同步 RPC 有相同的原则。 但是，它不会 等 响应，它传入一个 <code>Handler&lt;AsymcResult&lt;X&gt;&gt;</code>，以便在结果收到以后调用。</p>
<p><img src="./2018-11-05_java_vertx/5.png" alt="5.png"><br><code>AsyncResult</code> 会通知 <code>Handler</code> 这次调用是成功了还是失败了。当成功返回时，处理器会得到结果。</p>
<p>这种异步 RPC 有几个有点：</p>
<ul>
<li><p>  调用者不会被阻塞</p>
</li>
<li><p>  它可以处理故障</p>
</li>
<li><p>  你可以不用在事件总线收发消息。底层实现上，它帮助你组包和解包。</p>
</li>
</ul>
<h3 id="8-2-异步服务接口"><a href="#8-2-异步服务接口" class="headerlink" title="8.2. 异步服务接口"></a>8.2. 异步服务接口</h3><p>建立一个异步 RPC 的服务，或者事件总线的服务，或者一个服务代理。你首先需要一个 Java 接口来声明异步方法。 请打开 <code>io.vertx.workshop.portfolio.PortfolioService</code> 类看一下。</p>
<p>这个类被标注成：</p>
<ul>
<li><p>  <code>ProxyGen</code> - 开启事件服务代理和服务器的代码生成</p>
</li>
<li><p>  <code>VertxGen</code> - 开启多 Vert.x 语言支持代理的代码生成。</p>
</li>
</ul>
<p>我们看一下第一个方法：</p>
<pre><code>void getPortfolio(Handler&lt;AsyncResult&lt;Portfolio&gt;&gt; resultHandler);</code></pre>
<p>这个方法帮助你获取一个 <code>Portafolio</code> 对象。就像上面解释的那样，这个消息是异步的，所以它需要一个 <code>Handler</code> 参数来接收 <code>AsyncResult&lt;Portfolio&gt;</code>。 其他的方法也都使用这种模式。</p>
<p>你可能已经注意到这个包里有 <code>package-info.java</code> 文件。 这个文件是用来开启服务代理代码生成的。</p>
<h3 id="8-3-数据对象"><a href="#8-3-数据对象" class="headerlink" title="8.3. 数据对象"></a>8.3. 数据对象</h3><p><code>Portfolio</code> 对象是一个数据对象。事件总线代理支持有限的类型，对于不支持的类型，它必须使用 数据对象(data object) (请查看 <a target="_blank" rel="noopener" href="http://vertx.io/docs/vertx-service-proxy/java/">文档</a>知道所有支持的类型)。 数据类型是 Java 类型，它们遵循以下相知：</p>
<ul>
<li><p>  他必须标注成 <code>DataObject</code></p>
</li>
<li><p>  它必须有一个空构建函数，一个拷贝构建函数，和一个基于 <code>JsonObject</code> 的构建函数</p>
</li>
<li><p>  它需要有一个 <code>toJson</code> 方法来构建相应的 <code>JsonObject</code></p>
</li>
<li><p>  字段必须是有 属性(property) (有 getters and setters)</p>
</li>
</ul>
<p>我们可以打开 <code>io.vertx.workshop.portfolio.Portfolio</code> 类，看一下它的内容。正如你看到的，所有的 JSON 处理都是通过自动生成的 <code>converters</code> 完成的。 所以一个数据对象非常接近一个简单的 bean。</p>
<h3 id="8-4-实现服务"><a href="#8-4-实现服务" class="headerlink" title="8.4. 实现服务"></a>8.4. 实现服务</h3><p>完美，我们已经有了一个服务的异步接口。我们需要实现服务本身。这里，我们需要实现三个方法：</p>
<ul>
<li><p>  <code>getPortfolio</code> 如何返回 <code>AsyncResult</code> 对象</p>
</li>
<li><p>  <code>sendActionOnTheEventBus</code> 来发送异步消息到事件总线上</p>
</li>
<li><p>  <code>evaluate</code> 计算当前投资组合的当前价值</p>
</li>
</ul>
<h4 id="8-4-1-任务-创建-AsyncResult-实例"><a href="#8-4-1-任务-创建-AsyncResult-实例" class="headerlink" title="8.4.1. 任务 - 创建 AsyncResult 实例"></a>8.4.1. 任务 - 创建 AsyncResult 实例</h4><p>正如我们已经看到的，我们的异步服务有 <code>Handler&lt;AsyncResult&lt;Portfolio&gt;&gt;</code> 参数。 所以当我们实现这个服务的时候， 我们需要使用 <code>AsyncResult</code> 类调用 <code>Handler</code>。 要想知道这是怎么工作的，让我们实现 <code>getPortfolio</code> 方法吧：</p>
<p>在 <code>io.vertx.workshop.portfolio.impl.PortfolioServiceImpl</code>，填充 <code>getPortfolio</code> 方法. 它应该调用 <code>resultHandler</code> 的 <code>handle</code> 方法，传入一个 成功 (sucessful) 异步结果。这个对象可以通过 Vert.x <code>Future</code> 方法获得。</p>
<pre><code>resultHandler.handle(Future.succeededFuture(portfolio));</code></pre>
<p>哇唔…​ 只需要一行代码而已？让我们解析以下：</p>
<ul>
<li><p>  <code>resultHandler.handle</code> : 这是在调用 <code>Handler</code>. <code>Handler&lt;X&gt;</code> 只有一个方法 (<code>handle(X)</code>).</p>
</li>
<li><p>  <code>Future.succeededFuture</code> : 这是构建一个表明成功的 <code>AsyncResult</code> 实例，传递的值是一个返回结果 (<code>portfolio</code>)</p>
</li>
</ul>
<p>等一下，<code>AsyncResult</code> 和 <code>Future`有什么关系？ 一个 `Future</code> 表示一个行动的结果，可能成功，可能失败，还没有确定。 如果 <code>Future</code> 只是为了用来表明成功或者失败的状态，结果可能是 <code>null</code>。 <code>Future</code> 对象背后的操作可能成功或者失败。 <code>AsyncResult</code> 是一个表示一个操作成功和失败的结构。所以， <code>Future</code> 是一种 <code>AsyncResult</code>。 在 Vert.x里， <code>AsyncResult</code> 实例是通过 <code>Future</code> 类型构建的。</p>
<p><code>AsyncResult</code> 描述了:</p>
<ul>
<li><p>  成功返回，它会封装一个结果</p>
</li>
<li><p>  一个故障，它会封装一个 <code>Throwable</code> 实例</p>
</li>
</ul>
<p>你知道吗？术语 <code>Future</code> 早在1977就有了, <code>Promise</code> 是在 1976…​ 都不是新鲜事了。</p>
<p>那么，这些怎么和异步 RPC 工作的呢？让我们看一下时序图：</p>
<p><img src="./2018-11-05_java_vertx/6.png" alt="6.png"> </p>
<h4 id="8-4-2-任务-在事件总线上发送事件"><a href="#8-4-2-任务-在事件总线上发送事件" class="headerlink" title="8.4.2. 任务 - 在事件总线上发送事件"></a>8.4.2. 任务 - 在事件总线上发送事件</h4><p>在上一章，我们注册了一个接收事件总线服务的消费者。现在是时候知道如何发送消息了。我们通过 <code>vert.x.eventBus()</code> 访问事件总线。 通过这个对象，我们可以：</p>
<ul>
<li><p>  <code>send</code> : 发送点对点消息</p>
</li>
<li><p>  <code>publish</code> : 把一个消息广播给所有注册在这个地址的消费者</p>
</li>
<li><p>  <code>send</code> 并传入 <code>Handler&lt;AsyncResult&lt;Message&gt;&gt;&gt;</code> 参数: 发送一个点对点消息，并且期望有一个返回。</p>
</li>
</ul>
<p>在最后一点，请注意 <code>AsyncResult&lt;Message&gt;</code>。这是一个异步结果，也可能永远不会到达 (这会被认为是故障)。</p>
<p>好，返回我们的代码。我们已经提供了 <code>buy</code> 和 <code>sell</code> 方法，它们只是在买卖股份的时候做一些检查而已。 一旦买卖动作发出了，我们会向事件总线发送消息，它们会被 <code>审计服务</code> 和 <code>仪表盘服务</code> 同时消费。 所以，我们会使用 <code>publish</code> 方法。</p>
<p>要写 <code>sendActionOnTheEventBus</code> 的函数体，为了能够在 <code>EVENT_ADDRESS</code> 地址上发布一个包含 <code>JsonObject</code> 作为消息体的消息。 这个对象必须包含以下条目：</p>
<ul>
<li><p>  action → 动作 (买或者卖)</p>
</li>
<li><p>  quote → 报价， Json格式</p>
</li>
<li><p>  date → 日期 (long 型，以毫秒为单位)</p>
</li>
<li><p>  amount → 数量</p>
</li>
</ul>
<p>owned → 拥有这个股票的最新数量</p>
<pre><code>    vertx.eventBus().publish(EVENT_ADDRESS, new JsonObject()
            .put(&quot;action&quot;, action)
            .put(&quot;quote&quot;, quote)
            .put(&quot;date&quot;, System.currentTimeMillis())
            .put(&quot;amount&quot;, amount)
            .put(&quot;owned&quot;, newAmount)
    );</code></pre>
<p>让我们深入探讨以下：</p>
<ol>
<li><p> 它得到了 <code>EventBus</code> 实例，并且在上面调用 <code>publish</code>. 第一个参数 address 是消息发送的地址。</p>
</li>
<li><p> 消息体是一个 <code>JsonObject</code>，它包含这个动作的所有信息。 (买卖，报价 (这是另一个 JSON 对象), 日期…​）</p>
</li>
</ol>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="8-4-3-任务-协调异步方法和消费-HTTP-端点-投资组合估值"><a href="#8-4-3-任务-协调异步方法和消费-HTTP-端点-投资组合估值" class="headerlink" title="8.4.3. 任务 - 协调异步方法和消费 HTTP 端点 - 投资组合估值"></a>8.4.3. 任务 - 协调异步方法和消费 HTTP 端点 - 投资组合估值</h4><p>要实现的最后一个方法是 <code>evaluate</code>。这个方法计算当前投资组合的估值。 为了能够估值，这个函数需要访问股票的当前价值 (最后的报价)。这就需要消费 HTTP 端点，它是现在报价生成器里。 为此，你要：</p>
<ul>
<li><p>  发现这个服务。</p>
</li>
<li><p>  调用这个服务，来获得每一个你拥有股票的报价。</p>
</li>
<li><p>  当所有的调用都结束了，计算估值并且把估值返回给调用者。</p>
</li>
</ul>
<p>这有一点儿棘手。让我们一步一步来。第一步，在 <code>evaluate</code> ，我们需要拿到报价生成器提供的 HTTP 端点 (服务)。 这个服务的名字叫 <code>quotes</code>。我们在上一章已经发布了这个服务。因此，我们直接获得这个服务。</p>
<p>填充 <code>evaluate</code> 方法来获得 <code>quotes</code> 服务。我们可以通过 <code>HttpEndpoint.getWebClient</code> 得到 HTTP 服务。 服务的名字 <code>name</code> 是 <code>quote</code> 。如果你得不到这个服务，我们会得到一个异步的失败结果给处理器。 负责，调用 <code>computeEvaluation</code>。</p>
<pre><code>    HttpEndpoint.getWebClient(discovery, new JsonObject().put(&quot;name&quot;, &quot;quotes&quot;), client -&gt; &#123;
        if (client.failed()) &#123;
            // 失败了...      
            resultHandler.handle(Future.failedFuture(client.cause()));
        &#125; else &#123;
            // 我们得到了一个客户端      
            WebClient webClient = client.result();
            computeEvaluation(webClient, resultHandler);
        &#125;
    &#125;);</code></pre>
<p>获得服务的 Web 客户端。</p>
<p>客户端没有得到 (服务没有找到)，报错</p>
<p>我们拿到了客户端，继续…​</p>
<p>这里是 <code>computeEvaluation</code> 方法的实现：</p>
<pre><code>    // 每一家公司都需要调用一次服务    
    List&lt;Future&gt; results = portfolio.getShares()
            .entrySet().stream().map(entry -&gt;
                    getValueForCompany(webClient, entry.getKey(), entry.getValue()))
            .collect(Collectors.toList());
    // 我们只能在所有结果都得到以后返回，为此我们建立了组合预期。这是个集合处理器(set handler)    
    // 在所有预期都被赋值以后调用    
    CompositeFuture.all(results).setHandler(ar -&gt; &#123;
        double sum = results.stream().mapToDouble(fut -&gt; (double) fut.result()).sum();
        resultHandler.handle(Future.succeededFuture(sum));
    &#125;);</code></pre>
<p>首先，我们得到了一个 <code>Future</code> 列表，每个都会得到一家公司的股票估值 (1)。 这些估值是异步到达的 (他调用 HTTP 服务获得最新值)。我们不知道什么时候所有这些 <code>Future</code> 都返回并且赋值了。 幸运的是， Vert.x 为这种情况提供了 <code>CompositeFuture</code> (2)。 <code>CompositeFuture.all</code> 当所有的 <code>Future</code> 都赋值返回之后，它注册的的处理器会被调用。 所以当处理器被调用的时候，我们知道所有的预期都已经得到了数值，我们可以计算总和了 (3) 。 最终，我们使用 <code>resultHandler</code> 把这个总和发送给客户端 (4)。</p>
<p>好，我们只是用 <code>getValueForCompany</code> 方法来调用服务。下一步我们会写这个方法的内容。我们会需要建立一个 <code>Future</code> 对象，通过它报告操作完成了。 这个预期是这个方法的 “返回” 结果。然后，它会调用 HTTP 端点(<code>/?name= + encode(company)</code>)。</p>
<p>当应答返回时，检查状态 (应该是 200) 然后获得消息体 (用 <code>bodyHandler</code>)。这个消息题会被用 <code>buffer.toJsonObject()</code> 处理成 <code>JsonObject</code>。 估值是通过 <code>numberOfShares</code> * <code>bid</code> 价格 (从消息体获得)。估值计算出来后，完成 future。 别忘了，如果有故障，我们需要把故障也上报给 future。为了简单，如果这个公司我们不知道 (应答的状态 不 是 200)，我们假设股票的估值是 0.0。</p>
<pre><code>private Future&lt;Double&gt; getValueForCompany(WebClient client, String company, int numberOfShares) &#123;    // 创建预期对象，它将要在收到估值的时候得到赋值    
    Future&lt;Double&gt; future = Future.future();
    client.get(&quot;/?name=&quot; + encode(company)).as(BodyCodec.jsonObject()).send(ar -&gt; &#123;
        if (ar.succeeded()) &#123;
            HttpResponse&lt;JsonObject&gt; response = ar.result();
            if (response.statusCode() == 200) &#123;
                double v = numberOfShares * response.body().getDouble(&quot;bid&quot;);
                future.complete(v);
            &#125; else &#123;
                future.complete(0.0);
            &#125;
        &#125; else &#123;
            future.fail(ar.cause());
        &#125;
    &#125;);
    return future;
&#125;</code></pre>
<p>首先，我们建立一个 <code>Futuer</code> 对象，这将是这个方法的返回值 (1)。然后，我们调用 Web 客户端的 <code>get</code> 方法获得公司最新的报价 (2)。 <code>get</code> 准备了请求消息，但是在 <code>send</code> 调用之前，不会发出消息。这个 Web 客户端已经配置了正确的 IP 和端口 (服务发现可以做到这些)。 然后，我们可以读消息体并且计算估值。做完这些，我们就把估值赋值给 <code>Future</code> (3)。 如果找不到这个公司，他就是估值为 <code>0.0</code> (4)。 如果收发消息的过程中有什么错误发生，我们用 <code>Throwable</code> 给 future 设置错误状态 (5)。</p>
<h3 id="8-5-任务-发布一个服务"><a href="#8-5-任务-发布一个服务" class="headerlink" title="8.5. 任务 - 发布一个服务"></a>8.5. 任务 - 发布一个服务</h3><p>现在，服务的实现已经完成。让我们发布它吧！首先，我们需要一个 <code>vertical</code> 来建立这个具体的·服务对象， 在事件中线上注册这个服务并且发布这个服务到服务发现基础设施上。</p>
<p>打开 <code>io.vertx.workshop.portfolio.impl.PortfolioVerticle</code> 类。<code>start</code> 方法就做了我们所说的步骤:</p>
<ol>
<li><p>建立服务对象:</p>
<p> PortfolioServiceImpl service = new PortfolioServiceImpl(vertx, discovery, config().getDouble(“money”, 10000.00));</p>
</li>
<li><p>在事件总线上注册服务，我们用到了 <code>ProxyHelper</code>:</p>
<p> ProxyHelper.registerService(PortfolioService.class, vertx, service, ADDRESS);</p>
</li>
<li><p>在服务发现基础设施上发布服务，让其他人知道它的存在：</p>
<p> publishEventBusService(“portfolio”, ADDRESS, PortfolioService.class, ar -&gt; {  if (ar.failed()) {    ar.cause().printStackTrace();  } else {    System.out.println(“Portfolio service published : “ + ar.succeeded());  }});</p>
</li>
</ol>
<p><code>publishEventBusService</code> 的实现如下：</p>
<pre><code>    // 建立服务记录
    Record record = EventBusService.createRecord(name, address, serviceClass);
    // 发布这个服务记录
    discovery.publish(record, ar -&gt; &#123;
        if (ar.succeeded()) &#123;
            registeredRecords.add(record);
            completionHandler.handle(Future.succeededFuture());
        &#125; else &#123;
            completionHandler.handle(Future.failedFuture(ar.cause()));
        &#125;
    &#125;);</code></pre>
<p>我们做完了吗？不…​ 我们还有一个服务需要发布。记住，当买卖股份的时候，我们同时在服务总线上发送消息。这也是一个服务 (准确的讲，它是一个消息源服务)。</p>
<p>在 <code>start</code> 方法的末尾，写一些代码来发布 <code>portfolio-events</code> 服务。<code>EVENT_ADDRESS</code> 是事件服务总线地址。</p>
<p>对于不同的服务类型，有不同的 <code>publish</code> 方法</p>
<pre><code>   publishMessageSource(&quot;portfolio-events&quot;, EVENT_ADDRESS, ar -&gt; &#123;
        if (ar.failed()) &#123;
            ar.cause().printStackTrace();
        &#125; else &#123;
            System.out.println(&quot;Portfolio Events service published : &quot; + ar.succeeded());
        &#125;
    &#125;);</code></pre>
<p>现在，我们做完了，我们需要编译打包和运行这个服务。</p>
<h3 id="8-6-运行了"><a href="#8-6-运行了" class="headerlink" title="8.6. 运行了 !"></a>8.6. 运行了 !</h3><p>编译打包：</p>
<pre><code>  cd portfolio-service
  mvn clean package</code></pre>
<p>然后，在另一个终端启动它：</p>
<pre><code>java -jar target/portfolio-service-1.0-SNAPSHOT-fat.jar</code></pre>
<p>看，投资组合服务启动了。它发现了 <code>quotes</code> 报价服务，并且随时提供服务。</p>
<p>我们回到仪表盘，你应该可以看到一些新的服务，而且左上角会显示 现金(cash) 。</p>
<p>仪表盘通过异步 RPC 机制消费投资组合服务。编译的时候，基于 JavaScript 的客户端已经生成了，页面可以使用 SockJS 的通信机制和他沟通。 实现层上，事件总线和 SockJS 之间还有一个桥接器。</p>
<p>好吧，是时候，买卖一些股份了。请关注下一章。</p>
<h2 id="9-算法交易"><a href="#9-算法交易" class="headerlink" title="9. 算法交易"></a>9. 算法交易</h2><p>在 <code>投资组合(portfolio)</code> 项目里，我们已经实现了管理投资组合的事件总线服务。 在报价生成器里，我们把报价发送给事件总线。 交易员程序是消费这两个服务的组件，它只有一个目的：赚钱(或者赔钱…​)!</p>
<p>在这一章，我们将要开发两个交易员程序 (它们的交易逻辑非常简单愚蠢，我们显然可以做的更好)：</p>
<ul>
<li><p>  第一个交易员程序是用 Java 开发的</p>
</li>
<li><p>  第二个交易员程序是用 Kotlin 开发的</p>
</li>
</ul>
<h3 id="9-1-愚蠢的算法交易员"><a href="#9-1-愚蠢的算法交易员" class="headerlink" title="9.1. 愚蠢的算法交易员"></a>9.1. 愚蠢的算法交易员</h3><p>在我们开始实现它之前，让我们介绍以下它们显然不符合逻辑的交易算法。</p>
<ol>
<li><p> 算法交易员随机挑选一个公司名字，随机选择股份数量 (<code>x</code>)。</p>
</li>
<li><p> 他随机买或者卖这家公司的 <code>x</code> 个股份。</p>
</li>
</ol>
<p>它不检查他是不是有足够的股份或者现金，他只是试着买卖…​ 这个逻辑在 <code>io.vertx.workshop.trader.impl.TraderUtils</code> 里实现了。</p>
<h3 id="9-2-部署几个使用不同语言实现的竖直体"><a href="#9-2-部署几个使用不同语言实现的竖直体" class="headerlink" title="9.2. 部署几个使用不同语言实现的竖直体"></a>9.2. 部署几个使用不同语言实现的竖直体</h3><p><code>compulsive-trader</code> 项目包含了一个 主竖直体 (<code>io.vertx.workshop.trader.impl.MainVerticle</code>) 它即将配置和部署这些竖直体：</p>
<pre><code>@Overridepublic
void start() throws Exception &#123;
    // Java 交易员    
    vertx.deployVerticle(JavaCompulsiveTraderVerticle.class.getName(), new DeploymentOptions().setInstances(2));
    // Kotlin 交易员 ...    
    vertx.deployVerticle(&quot;GroovyCompulsiveTraderVerticle.groovy&quot;);
&#125;</code></pre>
<p><code>JavaCompulsiveTraderVerticle</code> 在部署时传入了参数 <code>DeploymentOptions</code> (1)。 配置里的 实例数量 默认是 2, 所以 Vert.x 不止一次实例化这个竖直体，它被实例话了两次 (生成了两个对象)。 所以以上代码部署了三个交易员。</p>
<p>Groovy 竖直体是通过文件名部署的。竖直体文件是在 <code>src/main/resources</code> 路径下，会被移到胖 jar 包的根路径下。</p>
<p>现在是时候实现这些竖直体了。</p>
<h3 id="9-3-Java-版的交易员程序"><a href="#9-3-Java-版的交易员程序" class="headerlink" title="9.3. Java 版的交易员程序"></a>9.3. Java 版的交易员程序</h3><p>打开 <code>io.vertx.workshop.trader.impl.JavaCompulsiveTraderVerticle</code> 类，在 <code>TODO</code> 的位置，需要：</p>
<ol>
<li><p> 初始化交易员</p>
</li>
<li><p> 获取我们需要的两个服务</p>
</li>
<li><p> 当两个服务都获得到的时候，在每一个市场数据到达的时候应用交易逻辑买卖股票</p>
</li>
</ol>
<h4 id="9-3-1-任务-1-初始化交易员"><a href="#9-3-1-任务-1-初始化交易员" class="headerlink" title="9.3.1. 任务 - 1. 初始化交易员"></a>9.3.1. 任务 - 1. 初始化交易员</h4><p>首先，我们看一下 <code>start</code> 方法的定义：<code>start(Future&lt;Void&gt; future)</code> 。 这个 <code>future</code> 让我们在初始化结束的时候通知成功与否。 我们必须显式的完成这个 <code>future</code> 或者让他失败。</p>
<p>为了初始化这个交易员，去掉 <code>future.fail</code> 语句，并且使用 <code>TraderUtils</code> 初始化 <code>company</code> 和 <code>numberOfShares</code> 变量。</p>
<pre><code>    String company = TraderUtils.pickACompany();
    int numberOfShares = TraderUtils.pickANumber();
    System.out.println(&quot;Java compulsive trader configured for company &quot;+company +&quot; and shares: &quot;+numberOfShares);</code></pre>
<h4 id="9-3-2-任务-2-获得几个服务"><a href="#9-3-2-任务-2-获得几个服务" class="headerlink" title="9.3.2. 任务 - 2. 获得几个服务"></a>9.3.2. 任务 - 2. 获得几个服务</h4><p>交易员需要 <code>Portfolio</code> 服务和 <code>market</code> 服务 (发送市场数据的消息源)。 我们需要在拿到这两个服务之后才能启动交易逻辑。 这里我们使用到了上一章提到 <code>Future</code>组合。</p>
<p>紧跟着我们已经写的代码，写下获得两个服务的代码。当两个服务都获得以后 (使用 <code>all</code> 组合操作)，什么也不用做。<code>handler</code> 会在下一步填入</p>
<p>：</p>
<pre><code>    // 我们需要获得两个服务，建立两个预期对象来获得服务
    Future&lt;MessageConsumer&lt;JsonObject&gt;&gt; marketFuture = Future.future();
    Future&lt;PortfolioService&gt; portfolioFuture = Future.future();
    // 获得服务，使用 &quot;特定&quot; 完成来给预期的赋值
    MessageSource.getConsumer(discovery, new JsonObject().put(&quot;name&quot;, &quot;market-data&quot;), marketFuture.completer());
    EventBusService.getProxy(discovery, PortfolioService.class, portfolioFuture.completer());
    // 当一切结束，(服务都得到以后), 设置处理器
    CompositeFuture.all(marketFuture, portfolioFuture).setHandler(ar -&gt; &#123;
        // 下一步....
    &#125;);</code></pre>
<p>首先，我们建立两个 <code>Future</code> 对象，它们会在得到服务之后收到结果 (1)。 在 (2) 我们获得消息源服务并且使用特定的 <code>Handler</code> 来赋值 <code>Future</code>。 <code>completer</code>本质上是一个 <code>Handler</code>，它得到结果并且八只设置给 <code>Future</code> 或者把它置为失败。 我们在 (3) 中使用了相同的方法来获取 <code>Portfolio</code> 服务。</p>
<p>最终，在 (4)，我们建立了 <code>CompositeFuture</code>，它会在所有列表里的 <code>Future</code> 都被赋值以后，调用相应的 <code>Handler</code></p>
<p>9.3.3. 任务 - 3. 应用交易逻辑</p>
<p>基本上要做完了！现在我们写最后一个处理器。如果获取服务失败，我们在 <code>future</code> 上报告故障。 负责，在市场服务上注册一个消息消费者。每次你得到一个消息，应用 <code>TraderUtils.dumbTradingLogic</code> 方法。 接着，我们完成 <code>future</code>。</p>
<pre><code>    if (ar.failed()) &#123;
        future.fail(&quot;One of the required service cannot &quot; + &quot;be retrieved: &quot; + ar.cause());
    &#125; else &#123;
    // 我们的服务:  
        PortfolioService portfolio = portfolioFuture.result();
        MessageConsumer&lt;JsonObject&gt; marketConsumer = marketFuture.result();
        // 监听市场行情...   
        marketConsumer.handler(message -&gt; &#123;
            JsonObject quote = message.body();
            TraderUtils.dumbTradingLogic(company, numberOfShares, portfolio, quote);
        &#125;);
        future.complete();
    &#125;</code></pre>
<p>首先，我们需要检查服务成功获得 (1)。如果成功了，我们发 <code>Future</code> 对象打开，取出服务 (2)。 我们给 <code>marketConsumer</code> 消息源服务设置一个 <code>Handler</code> 来执行交易逻辑 (4)。 最终，在第 (5) 行，我们完成 <code>start</code> 的传入参数 <code>future</code>。这里没有任何 结果 ，我们只是通知这个完成状态。 同样，请注意 <code>future.fail</code> 是在标注一个初始化失败。</p>
<h4 id="9-3-4-一小段代码"><a href="#9-3-4-一小段代码" class="headerlink" title="9.3.4. 一小段代码"></a>9.3.4. 一小段代码</h4><p>这里是完整的代码：</p>
<pre><code>    super.start();
    String company = TraderUtils.pickACompany();
    int numberOfShares = TraderUtils.pickANumber();
    System.out.println(&quot;Java compulsive trader configured for company &quot; + company + &quot; and shares: &quot; + numberOfShares);
    // 我们需要获得两个服务，建立两个预期对象来获得服务    
    Future&lt;MessageConsumer&lt;JsonObject&gt;&gt; marketFuture = Future.future();
    Future&lt;PortfolioService&gt; portfolioFuture = Future.future();
    // 获得服务，使用 &quot;特定&quot; 完成来给预期的赋值    
    MessageSource.getConsumer(discovery, new JsonObject().put(&quot;name&quot;, &quot;market-data&quot;), marketFuture.completer());
    EventBusService.getProxy(discovery, PortfolioService.class, portfolioFuture.completer());
    // 当一切结束，(服务都得到以后), 设置处理器  
    CompositeFuture.all(marketFuture, portfolioFuture).setHandler(ar -&gt; &#123;
        if (ar.failed()) &#123;
            future.fail(&quot;One of the required service cannot &quot; + &quot;be retrieved: &quot; + ar.cause());
        &#125; else &#123;
            // 我们的服务：
            PortfolioService portfolio = portfolioFuture.result();
            MessageConsumer&lt;JsonObject&gt; marketConsumer = marketFuture.result();
            // 监听市场行情...    
            marketConsumer.handler(message -&gt; &#123;
                JsonObject quote = message.body();
                TraderUtils.dumbTradingLogic(company, numberOfShares, portfolio, quote);
            &#125;);
            future.complete();
        &#125;
    &#125;);</code></pre>
<h4 id="9-3-5-运行交易员"><a href="#9-3-5-运行交易员" class="headerlink" title="9.3.5. 运行交易员"></a>9.3.5. 运行交易员</h4><p>我们可以运行交易员程序，看一下它是怎么进行市场交易的。先编译打包：</p>
<pre><code>cd compulsive-traders
mvn clean package</code></pre>
<p>然后启动这个程序：</p>
<pre><code>java -jar target/compulsive-traders-1.0-SNAPSHOT-fat.jar</code></pre>
<p>如果你回到仪表盘，你可以看到投资组合的一些变化。</p>
<h3 id="9-4-任务-写一个-Groovy-竖直体"><a href="#9-4-任务-写一个-Groovy-竖直体" class="headerlink" title="9.4. 任务 - 写一个 Groovy 竖直体"></a>9.4. 任务 - 写一个 Groovy 竖直体</h3><p>这个 Groovy 交易员使用的是相同的交易逻辑，但是，这个竖直体是用 Groovy 语言开发的。为了方便理解，代码和 Java 版的十分类似。</p>
<p>打开 <code>src/main/resources/GroovyCompulsiveTraderVerticle.groovy</code>。这个竖直体是 Groovy 脚本。 所以竖直体的 <code>start</code> 方法就是这个脚本的内容. Vert.x 是支持 Groovy 类型的.</p>
<p>如果你不了解 Groovy，可以直接把方案拷贝粘贴。如果你了解 Groovy, 你可以尝试按照 Java 交易员的逻辑实现以下交易员。</p>
<ul>
<li><p>  Groovy 版本的 Vert.x API 都在 <code>io.vertx.groovy.x.y</code> 里，比方说 <code>io.vertx.groovy.core.CompositeFuture</code>。</p>
</li>
<li><p>  Json 对象就是 Groovy 映射 (map)，所以在 Java 里的 <code>MessageConsumer&lt;JsonObject&gt;</code> 就是 Groovy 里的 <code>MessageConsumer&lt;Map&gt;</code>。</p>
</li>
</ul>
<pre><code>import io.vertx.core.CompositeFuture
import io.vertx.core.Future
import io.vertx.core.eventbus.MessageConsumer
import io.vertx.core.json.JsonObject
import io.vertx.servicediscovery.ServiceDiscovery
import io.vertx.servicediscovery.types.EventBusService
import io.vertx.servicediscovery.types.MessageSource
import io.vertx.workshop.portfolio.PortfolioService
import io.vertx.workshop.trader.impl.TraderUtils

def company = TraderUtils.pickACompany();
def numberOfShares = TraderUtils.pickANumber();

println(&quot;Groovy compulsive trader configured for company &quot; + company + &quot; and shares: &quot; + numberOfShares);

// 建立发现服务对象。
def discovery = ServiceDiscovery.create(vertx);

Future&lt;MessageConsumer&lt;Map&gt;&gt; marketFuture = Future.future();
Future&lt;PortfolioService&gt; portfolioFuture = Future.future();

MessageSource.getConsumer(discovery,
        JsonObject.mapFrom([&quot;name&quot;: &quot;market-data&quot;]), marketFuture.completer());
EventBusService.getProxy(discovery,
        Class.forName(&quot;io.vertx.workshop.portfolio.PortfolioService&quot;), portfolioFuture.completer());

// 成功结束以后 (所有服务都得到了), 执行处理器代码
CompositeFuture.all(marketFuture, portfolioFuture).setHandler( &#123; ar -&gt;
  if (ar.failed()) &#123;
    System.err.println(&quot;One of the required service cannot be retrieved: &quot; + ar.cause());
  &#125; else &#123;
    // 我们的服务：
    PortfolioService portfolio = portfolioFuture.result();
    MessageConsumer&lt;Map&gt; marketConsumer = marketFuture.result();

    // 监听市场行情...
    marketConsumer.handler( &#123; message -&gt;
      Map quote = message.body();
      TraderUtils.dumbTradingLogic(company, numberOfShares, portfolio, quote);
    &#125;);
  &#125;
&#125;);</code></pre>
<p>正如你所见，代码和 Java 版非常相近。我们可以指出一些不同点：</p>
<ul>
<li><p>  好吧，这是 Groovy。当一个接口被标记成 <code>@VertxGen</code> 的时候，Vert.x 会把这个接口对所有(可配置)语言的支持都翻译出来</p>
</li>
<li><p>  在所有 <code>import</code> 语句里，你可以看到它们导入了依赖的包(和 Java 相同)…​</p>
</li>
<li><p>  我们必须必须建立一个服务发现器。</p>
</li>
</ul>
<p>这个例子用 Groovy 开发完毕，它和 JavaScript, Ruby 或者 Ceylon 非常相似。</p>
<p>我们在新的版本里已经没有办法找到 <code>io.vertx.groovy.</code> 等包。所以在写本文的时候，我们需要用 <code>io.vertx.</code> 包来替代它们。并且稍微改变了一些代码，以便他能够执行。另外，新编本里带有一个 <code>Kontlin</code> 实现的交易员。你可以使用类名 <code>io.vertx.workshop.trader.impl.KotlinCompulsiveTraderVerticle</code> 来找到它。并且用 <code>vertx.deployVerticle(String className)</code> 来启动它。</p>
<p>是时候重新编译打包，重启我们的交易员程序了。 键入 <code>CTRL+C</code> 关闭正在执行的交易员。然后重新编译打包：</p>
<pre><code>mvn clean package</code></pre>
<p>接着，启动我们的应用程序：</p>
<pre><code>java -jar target/compulsive-traders-1.0-SNAPSHOT-fat.jar</code></pre>
<p>如果你回到仪表盘，你可以看到投资组合的一些变动。现在我们有三个交易员帮助让你更富有了。：）</p>
<h2 id="10-审计服务"><a href="#10-审计服务" class="headerlink" title="10. 审计服务"></a>10. 审计服务</h2><p>法律就是法律…​ Sarbanes-Oxley 动议 要求你保存你在金融市场上做过的所有交易的跟踪记录。审计服务把你买卖的股票金额记录到数据库中。 这是 HSQL 数据库，当然其他的数据库也是相似的，即使是 no-sql 数据库。</p>
<h3 id="10-1-数据的异步访问"><a href="#10-1-数据的异步访问" class="headerlink" title="10.1. 数据的异步访问"></a>10.1. 数据的异步访问</h3><p>基于之前的讨论， Vert.x 是异步的，你千万不能阻塞事件循环。你知道什么是阻塞操作吗？ 数据库访问，现在流行的 JDBC 就是阻塞的！ 幸运的是， Vert.x 提供了一个异步 JDBC 客户端。</p>
<p>原则非常简单(这适用于所有访问阻塞系统的客户端)：<br><img src="./2018-11-05_java_vertx/7.png" alt="7.png"> </p>
<p>Worker ? 是的, Vert.x 里的标注 workers (使用一个独立的线程池) 是用来执行阻塞代码的。 他可以是一个被标注为 worker的竖直体 (verticle) 或者是一个实现了`vertx.executeBlocking` 构建函数。 虽然有这些功能，你还是最好不要滥用这个功能能，否则你会降低系统的扩展性。</p>
<p>和数据库互操作，通常不会是一个单独的操作。他会是一连串操作的组合。例如：</p>
<ol>
<li><p> 获得数据库连接</p>
</li>
<li><p> 删除一些数据表</p>
</li>
<li><p> 建立一些数据表</p>
</li>
<li><p> 关闭数据库连接</p>
</li>
</ol>
<p>所以，我们需要组合这些操作，而且在需要的时候报故障。我们将会在审计组件中看到怎么做。 in the Audit component.</p>
<h3 id="10-2-审计服务"><a href="#10-2-审计服务" class="headerlink" title="10.2. 审计服务"></a>10.2. 审计服务</h3><p>这就是审计服务：</p>
<ol>
<li><p> 从事件总线上收听金融操作</p>
</li>
<li><p> 把收到的操作存储到数据库中</p>
</li>
<li><p> 暴露一个 REST API，通过它，可以拿到最后10次操作。</p>
</li>
</ol>
<p>与数据互操作，我们用到了 <code>vertx-jdbc-client</code>, 这是 JDBC 的异步版本。所以你会看到一些 SQL 代码 （你会喜欢的）。</p>
<h3 id="10-3-Rxjava"><a href="#10-3-Rxjava" class="headerlink" title="10.3. Rxjava"></a>10.3. Rxjava</h3><h4 id="10-3-1-简介"><a href="#10-3-1-简介" class="headerlink" title="10.3.1. 简介"></a>10.3.1. 简介</h4><p>Vert.x 使用简单的异步回调，它的 <code>预期(Future)</code> 对象是一个有用的工具帮助你协调回调函数。 RxJava 实现了在 JVM 上的反应式扩展库，它可以用来组合异步和基于事件的程序。</p>
<p>基于 RxJava，你通过数据流象进行代码建模(也叫可观察的 <code>Observable</code>)。这些数据流是数据传输的管道。 这些 <code>观察者(Observable)</code> 可以代表有限，或者无限的数据流，甚至是只有一个元素的数据流。 当我们确切知道一个流只有一个元素时，我们可以方便的使用 <code>单例(Single)</code> 类型。 最后，一个 <code>结束(Completable)</code> 代表一个没有任何元素的流，也就是说。它只能以没有结果的方式结束，或者失败。</p>
<p>使用这些反应式类型，订阅(subscription) 操作就可以了。</p>
<pre><code>    Observable&lt;String&gt; observable = getStringObservable();
    // Subscribe to the stream
    observable.subscribe(item -&gt; &#123;
        // Received a String item  
    &#125;, error -&gt; &#123;
        // Error termination =&gt; no more items 
    &#125;, () -&gt; &#123;
        // Normal termination =&gt; no more items
    &#125;);</code></pre>
<p>单例由于只有一个元素，用起来比较简单。它们和预期(Future)/承诺(Promise)除了有很多值得注意的不同以外还是有一些共同点的：</p>
<ul>
<li><p>  一个 预期/承诺 是异步操作的结果。也就是说，你启动了一个服务器，你得到的承诺是，服务器会返回绑定的结果。</p>
</li>
<li><p>一个单例结果通常在订阅的时候有一个副作用。也就是说，你订阅了一个单例，副作用导致服务启动后，单例只会通知单个绑定的结果。</p>
<pre><code>  Single&lt;String&gt; single = getStringSingle();
  // Subscribe to the single
  single.subscribe(item -&gt; &#123;
      // Completion with the string item
  &#125;, error -&gt; &#123;
      // Completion with an error
  &#125;);</code></pre>
</li>
</ul>
<h4 id="10-3-2-组合和转换"><a href="#10-3-2-组合和转换" class="headerlink" title="10.3.2. 组合和转换"></a>10.3.2. 组合和转换</h4><p>RxJava 提供了一组非常有用的针对组合，和转换异步流的操作。</p>
<p>在这个实验课里，你会使用重要的几个重要的操作：<code>map</code>, <code>flatMap</code> and <code>zip</code> 。</p>
<p><code>map</code> 操作可以同步的把一个操作的结果进行转换。</p>
<pre><code>    // Transform the stream of strings into a stream of Buffer
    Observable&lt;Buffer&gt; observable = getStringObservable().map(s -&gt; vertx.fileSystem().readFileBlocking(s));

    // Transform the string single into a Buffer single
    Single&lt;Buffer&gt; single = getStringSingle().map(s -&gt; vertx.fileSystem().readFileBlocking(s));</code></pre>
<p><code>map</code> 的一个不足之处就是它的同步性。为了从文件里获得内容，我们必须使用 阻塞 版本的文件系统API，这就破坏了 Vert.x的黄金规则。</p>
<p>幸运的是，我们还有一个异步版本的映射，<code>flatMap</code>。</p>
<pre><code>// Transform the stream of strings into a stream of Buffer
Observable&lt;Buffer&gt; observable = getStringObservable().flatMap(s -&gt; &#123;
    Single&lt;Buffer&gt; single = vertx.fileSystem().rxReadFile();
    return single.toObservable();
&#125;);

// Transform the string single into a Buffer single
Single&lt;Buffer&gt; single = getStringSingle().flatMap(s -&gt; &#123;
    Single&lt;Buffer&gt; single = vertx.fileSystem().rxReadFile();
    return single;
&#125;);</code></pre>
<p><code>zip</code> 操作符可以把多个 <code>Observable</code>/<code>Single</code> 组合成一个单独的结果，我们看到的结果是 <code>Single</code>:</p>
<pre><code>Single&lt;String&gt; single1 = getStringSingle();
Single&lt;String&gt; single2 = getStringSingle();
Single&lt;String&gt; single3 = getStringSingle();

Single&lt;String&gt; combinedSingle = Single.zip(single1, single2, single3, (s1,s2,s3) -&gt; s1 + s2 + s3);

combinedSingle.subscribe(s -&gt; &#123;
    // Got the three concatenated strings
&#125;, error -&gt; &#123;
    // At least one of single1, single2 or single3 failed
&#125;);</code></pre>
<p>它工作起来象 <code>Observable</code>，但是为了简洁起见，我们在这里就不多说了。</p>
<h3 id="10-4-Vert-x-Rx"><a href="#10-4-Vert-x-Rx" class="headerlink" title="10.4. Vert.x Rx"></a>10.4. Vert.x Rx</h3><p>Vert.x 有一个 Rx 异步版本的 API， 它的包都有前缀 <code>io.vertx.rxjava</code>， 例如 <code>io.vertx.rxjava.core.Vertx`是 Rx 版本的 `io.vertx.core.Vertx</code>。 这些 RX化的Vert.x 暴露的异步方法都是单例 <code>Single</code> 和流类型 <code>Observable</code>.</p>
<h4 id="10-4-1-Vert-x-流"><a href="#10-4-1-Vert-x-流" class="headerlink" title="10.4.1. Vert.x 流"></a>10.4.1. Vert.x 流</h4><p>类型 <code>ReadStream&lt;T&gt;</code> 是对反应式 <code>T</code> 项目序列的建模。举例来说，<code>HttpServerRequest</code> 就是 <code>ReadStream&lt;Buffer&gt;</code>。</p>
<p>RX化 版本暴露了 <code>toObservable()</code> 方法，用来把流转换成 <code>Observable&lt;T&gt;</code>。</p>
<pre><code>import io.vertx.rxjva.core.Vertx;
import io.vertx.rxjva.core.http.HttpServer;

...

Vertx vertx = Vert.vertx();
HttpServer server = vertx.createHttpServer();
server.requestHandler(request -&gt; &#123;
  if (request.path().equals(&quot;/upload&quot;)) &#123;
    Observable&lt;Buffer&gt; observable = request.toObservable();
    observable.subscribe(buffer -&gt; &#123;
      // Got an uploaded buffer
      &#125;, error -&gt; &#123;
      // Got an error =&gt; no more buffers
      &#125;, () -&gt; &#123;
      // Done =&gt; no more buffers
    &#125;);
  &#125;
&#125;);</code></pre>
<p>在本节，我们不会使用 <code>Observable</code>，反应式流并不是我们的重点。但是我们会应用 <code>Single</code> 。</p>
<h4 id="10-4-2-Vert-x-单例"><a href="#10-4-2-Vert-x-单例" class="headerlink" title="10.4.2. Vert.x 单例"></a>10.4.2. Vert.x 单例</h4><p>每一个异步方法，例如最后一个参数类型是 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 的方法，都会有一个 RX化 的版本。它的名字就是在原方法名前加上 <code>rx</code> 。 它的参数和原函数基本一致，只是去掉了最后一个参数。它会有一个返回值，一个单例 <code>Single</code> 的异步类型。</p>
<p>不象原方法，调用 rx 版本并不会真正的调用什么。你会拿到一个单例，你会在订阅这个单例的时候调用到实际的方法。</p>
<pre><code>import io.vertx.rxjva.core.Vertx;
import io.vertx.rxjva.core.http.HttpServer;

...

Vertx vertx = Vert.vertx();
HttpServer server = vertx.createHttpServer();
server.requestHandler(request -&gt; ...);

// 这个单例建立了，但是服务并没有在这时启动
Single&lt;HttpServer&gt; listenSingle = server.rxListen(8080);

// 出发服务器启动
listenSingle.subscribe(
  server -&gt; &#123;
    // 服务器启动，并且绑定到 8080 端口
  &#125;, error -&gt; &#123;
    // 服务器没有启动
  &#125;);</code></pre>
<h3 id="10-5-任务-返回单例的组合方法"><a href="#10-5-任务-返回单例的组合方法" class="headerlink" title="10.5. 任务 - 返回单例的组合方法"></a>10.5. 任务 - 返回单例的组合方法</h3><p>打开 <code>io.vertx.workshop.audit.impl.AuditVerticle</code> 类。这个竖直体第一个重要的细节是 <code>start</code> 方法。 象 Java 交易员的 <code>start</code> 方法一样，这个方法是异步的，并且通过传入的 <code>Future</code> 对象报告完成状态。</p>
<pre><code>public void start(Future&lt;Void&gt; future) &#123;
  super.start();

  // 建立 jdbc 客户端
  jdbc = JDBCClient.createNonShared(vertx, config());

  // TODO
  // ----
  Single&lt;MessageConsumer&lt;JsonObject&gt;&gt; ready = Single.error(new UnsupportedOperationException(&quot;not yet implemented&quot;));
  // ----

  readySingle.doOnSuccess(consumer -&gt; &#123;
    // 如果成功，我们把消息处理函数设置好。它会把消息存储到数据库
    consumer.handler(message -&gt; storeInDatabase(message.body()));
  &#125;).subscribe(consumer -&gt; &#123;
    // 成功完成竖直体的启动
    future.complete();
  &#125;, error -&gt; &#123;
    // 通知竖直体启动失败
    future.fail(error);
  &#125;);
&#125;</code></pre>
<p>当 <code>Future</code> 被赋值以后，Vert.x 会认为竖直体成功部署了。当竖直提不能启动的时候，它也有可能上报一个失败。</p>
<p>初始化审计服务，我们需要以下操作：</p>
<ul>
<li><p>  准备数据库 (表）</p>
</li>
<li><p>  启动 HTTP 服务并且暴露 REST API。另外发布这个服务。</p>
</li>
<li><p>  从消息源接收股票操作</p>
</li>
</ul>
<p>所以，这很清楚是三个毫不相干的操作。但是，审计服务必须在所有三个操作全都完成。</p>
<p>请用以下代码替换 <code>TODO</code> 代码块。这写代码(用对象提供的方法)获取了三个单例对象，并且 等(wait) 这三个任务都完成。 这三个单例应该组成一个 <code>Single&lt;MessageConsumer&lt;JsonObject&gt;&gt;</code> 。</p>
<p>当这个单例成功的时候，它会在投资组合消息源上注册一个消息监听器。监听器会把每个接收到的消息存储到数据库。</p>
<p>它完成的时候，会调用 <code>future.complete()</code> 和 <code>future.fail(cause)</code>，这样会通知 Vert.x 开始过程已经完成 （或者成功或者失败）。</p>
<pre><code>Single&lt;Void&gt; databaseReady = initializeDatabase(config().getBoolean(&quot;drop&quot;, false));
Single&lt;Void&gt; httpEndpointReady = configureTheHTTPServer()
    .flatMap(server -&gt; rxPublishHttpEndpoint(&quot;audit&quot;, &quot;localhost&quot;, server.actualPort()));
Single&lt;MessageConsumer&lt;JsonObject&gt;&gt; messageConsumerReady = retrieveThePortfolioMessageSource();
Single&lt;MessageConsumer&lt;JsonObject&gt;&gt; readySingle = Single.zip(
    databaseReady,
    httpEndpointReady,
    messageConsumerReady,
    (db, http, consumer) -&gt; consumer);</code></pre>
<p>首先我们生成了三个单例 <code>Single</code>，每个执行活动一个。我们将很快看到它们是怎么建立的。然后，我们把所有单例用 <code>Single.zip</code> 函数组合起来。 zip 函数返回消费者单例，这是我们唯一关心的一个。</p>
<h3 id="10-6-任务-实现一个返回单例的方法"><a href="#10-6-任务-实现一个返回单例的方法" class="headerlink" title="10.6. 任务 - 实现一个返回单例的方法"></a>10.6. 任务 - 实现一个返回单例的方法</h3><p>现在我们的竖直体扩充 (extends) 了 <code>RxMicroServiceVerticle</code> 基类。 这个类和 <code>MicroServiceVerticle</code> 提供了相同的方法接口，不同点是使用了 Rx 单例。</p>
<p>我们已经提到过，异步方法的特征是最后一个参数是 <code>Handler</code>。 这里有一个等价的语法，就是在操作结束之后，返回一个 <code>Single</code> 对象。</p>
<pre><code>void asyncMethod(a, b, Handler&lt;AsyncResult&lt;R&gt;&gt; handler);// 语义等价Single&lt;R&gt; asyncMethod(a, b);</code></pre>
<p>实际上，调用者可以订阅这个 <code>Single</code> 对象来执行异步操作，并且得到操作完成和失败的通知。</p>
<pre><code>Single&lt;R&gt; single = asyncMethod(a, b);single.subscribe(r  -&gt; &#123;    // 基于结果完成工作  &#125;, err -&gt; &#123;    // 处理故障  &#125;);</code></pre>
<p>让我们用这种模式实现 <code>configureTheHTTPServer</code> 方法。在这个方法里，我们将要用一个新的 Vert.x 组件：Vert.x Web。 Vert.x Web是一个 Vert.x 用来建立现代web应用的扩展。这里我们将要用到 <code>Router</code>，这可以让我们轻松实现 REST API (类似 Hapi 和 ExressJS)。 所以：</p>
<ol>
<li><p> 建立一个 <code>Router</code> 对象，使用函数: <code>Router.router(vertx)</code></p>
</li>
<li><p> 在路由器上注册一个路径 (在跟路径上 <code>/</code>) , 就叫 <code>retrieveOperations</code></p>
</li>
<li><p> 建立一个 HTTP 服务器，然它负责处理在 <code>router.accept</code> 上的请求。</p>
</li>
<li><p> 获取配置文件里写好的端口。如果没有设置，我们会传入 <code>0</code> （程序会选择一个随机端口）。 因为服务会暴露在服务记录上，消费者可以获得这个端口，所以我们可以随机使用一个端口。</p>
</li>
<li><p> 使用 <code>rxListen</code> 启动这个服务。这是一个 rx版本的监听方法，所以它返回一个单例。</p>
</li>
</ol>
<pre><code>    // Use a Vert.x Web router for this REST API.
    Router router = Router.router(vertx);
    router.get(&quot;/&quot;).handler(this::retrieveOperations);

    return vertx.createHttpServer()
            .requestHandler(router::accept)
            .rxListen(config().getInteger(&quot;http.port&quot;, 0));</code></pre>
<p>It creates a Router. The Router is an object from Vert.x web that ease the creation of REST API with Vert.x. We won’t go into too much details here, but if you want to implement REST API with Vert.x, this is the way to go. On our Router we declare a route: when a request arrive on /, it calls this Handler. Then, we create the HTTP server. The requestHandler is a specific method of the router, and we return the result of the rxListen method.</p>
<p>这样的话，调用者调用这个方法，并且得到一个 <code>单例(Single)</code>。它可以订阅这个单例来绑定服务器，并且得到成功失败的通知。</p>
<p>如果你阅读 <code>retrieveThePortfolioMessageSource</code> 方法，你能看到类似的模式。</p>
<h3 id="10-7-使用异步-JDBC"><a href="#10-7-使用异步-JDBC" class="headerlink" title="10.7. 使用异步 JDBC"></a>10.7. 使用异步 JDBC</h3><p>在 <code>start</code> 方法里，我们调用了 <code>initializeDatabase</code>。让我们看看这个方法，它使用了另一种活动组合。这个方法：</p>
<ul>
<li><p>  得到了一个数据库连接</p>
</li>
<li><p>  删除了数据表</p>
</li>
<li><p>  建立了数据表</p>
</li>
<li><p>  关闭了连接(不管前两步操作是不是成功)</p>
</li>
</ul>
<p>所有这些操作都有可能失败。</p>
<p>在上一个段落，你已经见到返回 <code>Single</code> 的方法了。<code>链(Chains)</code> 是另外一种函数组合的方式。</p>
<ol>
<li><p> 你有一个输入</p>
</li>
<li><p> 你执行第一个 <code>Function</code>，从步骤 (1) 拿到输入，并且返回一个 <code>Single</code></p>
</li>
<li><p> 你执行第二个 <code>Function</code>，从步骤 (2) 拿到输入，并且返回一个 <code>Single</code></p>
</li>
<li><p> …​.</p>
</li>
</ol>
<p>整个链的返回会是一个 <code>Single</code> 对象。如果任何一个链上的操作失败，这个 <code>Single</code> 被标记成失败，否则，它成功完成，返回最后一个操作的结果：</p>
<pre><code>Single&lt;X&gt; chain = input.flatMap(function1).flatMap(function2).flatMap(function3);</code></pre>
<p>所以链接函数，我们只是需要几个 <code>Functions</code> 和一个能够触发整个链的 <code>Single</code>。 让我们先建立一个 <code>Single</code>：</p>
<pre><code>// 这是我们Rx操作的起始点。
// 这个单例会在数据库连接建立之后完成。
// 我们会使用这个单例作为连接的引用，在关闭连接的时候我们会用到它
Single&lt;SQLConnection&gt; connectionRetrieved = jdbc.rxGetConnection();</code></pre>
<p>然后，我们会用 <code>flatMap</code> 方法继续组合单例。<code>flatMap</code> 会传入 <code>SQLConnection</code> 参数和返回一个包含数据库初始化结果的单例。</p>
<ol>
<li><p> 我们建立了一个批处理</p>
</li>
<li><p> <code>rxBatch</code> 执行这个批处理，并且返回你一个单例作为结果</p>
</li>
<li><p>最终，我们用 <code>doAfterTerminate</code> 关闭这个连接</p>
<p> Single&lt;List<Integer>&gt; resultSingle = connectionRetrieved<br>   .flatMap(conn -&gt; {</p>
<pre><code> // 当我们得到了数据库连接

 // 准备批处理
 List&lt;String&gt; batch = new ArrayList&lt;&gt;();
 if (drop) &#123;
   // 数据表被删除以后，我们会重新建立
   batch.add(DROP_STATEMENT);
 &#125;
 // 直接建立数据库表
 batch.add(CREATE_TABLE_STATEMENT);

 // 我们组合了一个批处理语句
 Single&lt;List&lt;Integer&gt;&gt; next = conn.rxBatch(batch);

 // 不管结果如何，只要有数据连接，我们就关闭它。
 return next.doAfterTerminate(conn::close);</code></pre>
<p>   });</p>
</li>
</ol>
<p><code>resultSingle</code> 是最后返回的是 <code>Single&lt;List&lt;Integer&gt;&gt;</code> 。因为上层的调用函数并不需要任何细节信息，我们只需要返回 <code>Single&lt;Void&gt;</code> 。</p>
<p>这用 <code>map</code> 操作很容易做到。</p>
<pre><code>return resultSingle.&lt;Void&gt;map(null);</code></pre>
<p>你瞧。</p>
<h3 id="10-8-任务-异步-JDBC-和基于回调的组合"><a href="#10-8-任务-异步-JDBC-和基于回调的组合" class="headerlink" title="10.8. 任务 - 异步 JDBC 和基于回调的组合"></a>10.8. 任务 - 异步 JDBC 和基于回调的组合</h3><p>你可能会问为什么我们需要做这种组合。让我们实现一个没有任何组合的操作 (只用回调函数)。这个 <code>retrieveOperations</code> 方法会在 HTTP 请求到达时被调用，它会返回一个包含10个最新股票操作的 JSON 对象。换一种说法：</p>
<ol>
<li><p> 得到一个数据库连接</p>
</li>
<li><p> 查询数据库</p>
</li>
<li><p> 操作返回数据集拿到股票操作列表</p>
</li>
<li><p> 把股票操作列表写入到 HTTP 响应中</p>
</li>
<li><p> 关闭数据库</p>
</li>
</ol>
<p>步骤 (1) 和 (2) 都是异步的. (5) 也是异步的, 而且我们没有必要等待最终完成。 在代码里，我们不会使用组合 (这是这个练习的目的)。 <code>retrieveOperations</code> 里，我们使用 处理器(Handlers) / 回调(Callbacks) 。</p>
<pre><code>// 1 - 得到一个连接
jdbc.getConnection(ar -&gt; &#123;
  SQLConnection connection = ar.result();
  if (ar.failed()) &#123;
    context.fail(ar.cause());
  &#125; else &#123;
    // 2. 执行查询
    connection.query(SELECT_STATEMENT, result -&gt; &#123;
      ResultSet set = result.result();

      // 3. 建立股票操作列表
      List&lt;JsonObject&gt; operations = set.getRows().stream()
          .map(json -&gt; new JsonObject(json.getString(&quot;OPERATION&quot;)))
          .collect(Collectors.toList());

      // 4. 把列表写入 HTTP 响应
      context.response().setStatusCode(200).end(Json.encodePrettily(operations));

      // 5. 关闭连接
      connection.close();
    &#125;);
  &#125;
&#125;);</code></pre>
<p>很显然，我们也可以不使用组合操作。但是你可以想象以下，如果你有好几个异步操作来链接，这会使回调异常复杂。这会是回调地狱 (callback hell)。 在这种情况下，我们建议：使用 Vert.x 组合操作或者使用 rx化 版本的 Vert.x API。</p>
<h3 id="10-9-展示一下"><a href="#10-9-展示一下" class="headerlink" title="10.9. 展示一下 !"></a>10.9. 展示一下 !</h3><p>让我们看看这是怎么工作的。</p>
<p>首先，我们先构建包：</p>
<pre><code>cd audit-service
mvn clean package</code></pre>
<p>然后，你需要启动这个程序：</p>
<pre><code> java -jar target/audit-service-1.0-SNAPSHOT-fat.jar</code></pre>
<p>重启并且刷新仪表盘，然后你可以看到在右上角看到股票操作啦！</p>
<h2 id="11-仪表盘解析"><a href="#11-仪表盘解析" class="headerlink" title="11. 仪表盘解析"></a>11. 仪表盘解析</h2><p>这一节是关于仪表盘的。它的内容包括：</p>
<ol>
<li><p> 如何配置 Vert.x web 来暴露静态资源</p>
</li>
<li><p> 如何实现实现一个 REST 端点委派给另外一个 REST 终结点 (代理模式)</p>
</li>
<li><p> 如何保护微服务相互操作不被故障影响(异常处理，超时，回路代理)</p>
</li>
<li><p> 如何配置一个 SockJS - 事件总线桥接器</p>
</li>
<li><p> 如何从浏览器上消费一个事件总线代理</p>
</li>
</ol>
<p>仪表盘是一个单独的竖直体 (<code>io.vertx.workshop.dashboard.DashboardVerticle</code>).</p>
<h3 id="11-1-Vert-x-Web-和静态文件"><a href="#11-1-Vert-x-Web-和静态文件" class="headerlink" title="11.1. Vert.x Web 和静态文件"></a>11.1. Vert.x Web 和静态文件</h3><p>在之前几节里，我们提到过 Vert.x web 是一种用来建立 Web 应用的 Vert.x 组件。 这个架构是以 <code>路由器(Router)</code> 为核心的。 你创建一个路由器并且配置 路由(routes)。对每一个路由，你都需要配置 HTTP 动词 和 路径（path) 和相对应的 <code>处理器(Handler)</code>。 在收到对应请求时，处理器会被调用。<code>路由器(router)</code> 可以这样创建：</p>
<pre><code>Router router = Router.router(vertx);</code></pre>
<p>Vert.x web 提供了一组 <code>Handler</code> 累处理标准的任务，像处理静态文件：</p>
<pre><code>// Static content
router.route(&quot;/*&quot;).handler(StaticHandler.create());</code></pre>
<p>这样，所有在 <code>webroot</code>下(默认值) 或者服务器根目录下的文件都可以通过服务访问到了。 举例说明，<code>webroot/index.html</code> 就可以通过 <a target="_blank" rel="noopener" href="http://0.0.0.0:8080/index.html">http://0.0.0.0:8080/index.html</a> 访问到了。</p>
<p>路由器配置好以后，我们就可以启动 HTTP 服务来使用这个路由器处理请求了：</p>
<pre><code>vertx.createHttpServer()    .requestHandler(router::accept)    .listen(8080);</code></pre>
<h3 id="11-2-委派-REST-调用"><a href="#11-2-委派-REST-调用" class="headerlink" title="11.2. 委派 REST 调用"></a>11.2. 委派 REST 调用</h3><p>我们经常需要实现基于 REST API 的服务。由于每个调用都会阻塞一个线程，在其他传统架构上，我们需要等所有 REST API 都返回，这个模式有可能会非常费时低效。 使用 Vert.x 委派会把这个问题变简单。异步和非阻塞。</p>
<p>在仪表盘的例子里，我们想要获得股票操作列表。这个列表是审计服务提供的。 所以，仪表盘我们这样定义路由：</p>
<pre><code>router.get(&quot;/operations&quot;).handler(this::callAuditService);</code></pre>
<p>处理器是这样的:</p>
<pre><code>private void callAuditService(RoutingContext context) &#123;
  if (client == null) &#123;
      context.response()
        .putHeader(&quot;content-type&quot;, &quot;application/json&quot;)
        .setStatusCode(200)
        .end(new JsonObject().put(&quot;message&quot;, &quot;No audit service&quot;).encode());
  &#125; else &#123;
      client.get(&quot;/&quot;).send(ar -&gt; &#123;
        if (ar.succeeded()) &#123;
          HttpResponse&lt;Buffer&gt; response = ar.result();
          context.response()
            .putHeader(&quot;content-type&quot;, &quot;application/json&quot;)
            .setStatusCode(200)
            .end(response.body());
      &#125;
    &#125;);
  &#125;
&#125;</code></pre>
<p>审计服务会在竖直体的 <code>start</code> 函数里拿到。如果服务没有找到，这个处理器返回 no audit service 消息。 否则，他会使用找到的 HTTP 客户端调用审计服务 REST API。应答消息只是简单的把 HTTP 请求的返回传递给客户端。</p>
<h3 id="11-3-任务-用异常处理器和超时管理故障"><a href="#11-3-任务-用异常处理器和超时管理故障" class="headerlink" title="11.3. 任务 - 用异常处理器和超时管理故障"></a>11.3. 任务 - 用异常处理器和超时管理故障</h3><p>我们已经在上一节看到了在`callAuditService` 是怎么工作的…​ 好吧，那么我们怎么在一个分布式系统中知道： 远端出故障了。 我们最好在这个方法里处理故障。 Vert.x 提供了四种处理故障的方法：</p>
<ul>
<li><p>  异步结果和预期(future)返回故障信息</p>
</li>
<li><p>  异常处理器(exception handlers)</p>
</li>
<li><p>  超时(timeout)</p>
</li>
<li><p>  断路器(circuit breaker)</p>
</li>
</ul>
<p>我们已经了解了第一个方式。这一小节将会应用超时。下一个小节将会使用断路器。</p>
<p>把下面的 <code>callAuditServiceTimeout</code> 方法拷贝到 <code>DashboardVertical</code>, 他会设置 HTTP 请求的 <code>超时(timeout)</code>。 <code>RoutingContext</code> 的 <code>fail</code> 方法会在故障的时候调用。 如果返回结果在超时之前没有返回，这个异步结果就会失败。 不要忘了把 `/operations`` 处理器换成这个方法。</p>
<pre><code>private void callAuditServiceTimeout(RoutingContext context) &#123;
  if (client == null) &#123;
    context.response()
        .putHeader(&quot;content-type&quot;, &quot;application/json&quot;)
        .setStatusCode(200)
        .end(new JsonObject().put(&quot;message&quot;, &quot;No audit service&quot;).encode());
  &#125; else &#123;
    client.get(&quot;/&quot;)
        .timeout(5000)
        .send(ar -&gt; &#123;
      if (ar.succeeded()) &#123;
        HttpResponse&lt;Buffer&gt; response = ar.result();
        context.response()
            .putHeader(&quot;content-type&quot;, &quot;application/json&quot;)
            .setStatusCode(200)
            .end(response.body());
      &#125; else &#123;
        context.fail(ar.cause());
      &#125;
    &#125;);
  &#125;
&#125;</code></pre>
<p>做完上面的步骤，我们重新编译打包仪表盘</p>
<pre><code>cd trader-dashboard
mvn clean package</code></pre>
<p>然后，在另一个终端启动它：</p>
<pre><code>java -jar target/trader-dashboard-1.0-SNAPSHOT-fat.jar</code></pre>
<p>刷新仪表盘页面。在审计服务终端，终止这个服务然后查看仪表盘如何反应(你可以用 inspector/dev tools 查看 AJAX 请求)。然后，重新启动审计服务。发生了什么？</p>
<h3 id="11-4-任务-使用断路器管理故障"><a href="#11-4-任务-使用断路器管理故障" class="headerlink" title="11.4. 任务 - 使用断路器管理故障"></a>11.4. 任务 - 使用断路器管理故障</h3><p>断路器是一个可以信赖的模式，它可以用一个简单的状态机来表示：</p>
<p><img src="./2018-11-05_java_vertx/8.png" alt="8.png"> </p>
<p>因为它可以光滑的从故障里恢复，所以这个模式在基于微服务的应用里非常流行。 一个断路器从 close 状态开始。这时它监视一个操作。每次这个操作失败的时候，它增加故障计数。 当计数超过某个阀值的时候，断路器就打开，变成 open 状态。在打开状态，操作本身不会再被调用，另外一个回调会被立即调用。 过一段时间以后，断路器会变成半开 half-open 状态。在这个状态，操作在第一个请求到达时被调用。其它请求会被重定向到回滚方法。 如果操作调用失败，断路器重新打开，直到另一次重试。如果重试成功，它会关闭。</p>
<p>断路器的实现有很多版本。Netflix Hystrix 是最流行的一种。Vert.x 提供了自己的实现。实际上，Hystrix 并不强制 Vert.x 改变线程模型，使用 Hystrix 是可能的，只是有些笨重。</p>
<p>在 <code>DashboardVerticle.java</code> 文件里，断路器 <code>circuit</code> 在 <code>start</code> 方法里被初始化了：</p>
<pre><code>circuit = CircuitBreaker.create(
    &quot;http-audit-service&quot;,                  //断路器的名字
    vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(2)                 //多少次失败会打开 open 断路器
        .setFallbackOnFailure(true)        //当检查到一个故障以后，是不是需要调用回滚 fallback 函数。即使关闭 close 状态也不例外
        .setResetTimeout(2000)             //从打开状态到半开状态转换需要多长时间     
        .setTimeout(1000))                 //操作持续多久没有完成，会被认为是操作失败
    .openHandler(v -&gt; retrieveAuditService());   </code></pre>
<p>在断路器转换成打开状态的时候，需要执行的处理。这里我们重新获取审计服务</p>
<p>使用断路器，我们可以写一个 <code>callAuditServiceWithExceptionHandlerWithCircuitBreaker</code> 方法来发现审计服务。 <code>circuit.&lt;Buffer&gt;executeWithFallback</code> 函数会被用到。别忘了修改路由 <code>/operations</code> 的处理器。</p>
<p>做完这些步骤，可以重新编译打包，重新启动仪表盘。你可以关闭审计服务，看看仪表盘的行为。重启审计服务，你可以从仪表盘看到断路器的状态。</p>
<p>Show me the code</p>
<h3 id="11-5-SockJS-事件总线桥接器"><a href="#11-5-SockJS-事件总线桥接器" class="headerlink" title="11.5. SockJS - 事件总线桥接器"></a>11.5. SockJS - 事件总线桥接器</h3><p>SockJS 是运行在浏览器上的 JavaScript 函数库。它提供了类似 WebSocket 的对象。 SockJS 提供了一个明了的，跨不同浏览器的，Javascript API。我们可以用它建立低延迟，全双工，跨域通信的浏览器和网络服务器之间的通道。 从实现机制上讲，SockJS 会先尝试使用本地 WebSockets。如果不工作，他会使用一些针对具体浏览器的特殊传输层协议。并且把他们包装成 WebSocket 类似的抽象层。 SockJS 客户端需要有一个服务器对端来进行通信。如你所愿，Vert.x 实现了它！</p>
<p>使用 SockJS - 事件总线桥接器，浏览器可从事件总线上以发送和接收消息。</p>
<p>为了启动桥接器，你需要以下代码：</p>
<pre><code>SockJSHandler sockJSHandler = SockJSHandler.create(vertx);                     //(1)   
BridgeOptions options = new BridgeOptions();
options
    .addOutboundPermitted(new PermittedOptions().setAddress(&quot;market&quot;))         //(2)   
    .addOutboundPermitted(new PermittedOptions().setAddress(&quot;portfolio&quot;))
    .addOutboundPermitted(new PermittedOptions().setAddress(&quot;service.portfolio&quot;))
    .addInboundPermitted(new PermittedOptions().setAddress(&quot;service.portfolio&quot;));

sockJSHandler.bridge(options);                                                 //(3)   
router.route(&quot;/eventbus/*&quot;).handler(sockJSHandler);                            //(4)                                         </code></pre>
<p>在 (1) 里, 我们建立了 <code>SockJSHandler</code>。我们要配置它，默认情况下，由于安全的要求，没有任何消息会被传输。 一组允许的地址被配置到桥接器里 (2) 。 对外的地址是为了消息能从事件总线发送到浏览器，对内地址是为了消息能从浏览器到事件总线。 最后，在 (3) 和 (4) ，我们配置了处理器并且在 <code>router</code> 建立了一个路由器。<code>/eventbus/*</code> 路径是用来让 SockJS 客户端(在浏览器里)协商链接，接收和发送消息。</p>
<p>这不是唯一的以个事件总线上的桥接器。我们还有 TCP 事件总线侨界器针对本地系统。 请注意，SockJS 桥接器也可以从 Node.JS 里调用。</p>
<h3 id="11-6-从浏览器消费事件总线的服务"><a href="#11-6-从浏览器消费事件总线的服务" class="headerlink" title="11.6. 从浏览器消费事件总线的服务"></a>11.6. 从浏览器消费事件总线的服务</h3><p>像上面说的，通过SockJS和事件总线的桥接器，浏览器可以和事件总线之间收发消息。 事件总线服务是通过总线传递消息的，所以我们在浏览器上是可以实现服务的客户端的。 Vert.x 会为你生成客户端。</p>
<p>因此，如果你打开 <code>index.html</code> 文件，你可以看到：</p>
<pre><code>&lt;script src=&quot;libs/portfolio_service-proxy.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>这就导入了 Vert.x 生成的脚本。接下来，我们可以使用这个服务：</p>
<pre><code>var service = new PortfolioService(eventbus, &quot;service.portfolio&quot;);
service.getPortfolio(function (err, res) &#123;
   // ....
&#125;</code></pre>
<p>很好，你可以直接从浏览器调用服务了。</p>
<h2 id="12-结语"><a href="#12-结语" class="headerlink" title="12. 结语"></a>12. 结语</h2><p>你做到了！或者你只是跳到了这一节。无论如何，祝贺你。我们希望你享受整个实验课，并且学到了一些东西。 这里有很多 Vert.x 能做的事情，我们还没有涉及到。</p>
<p>不要忘了，反应式系统的原则，和 Vert.x 实际上需要我们在变成思路上有所变化。</p>
<ul>
<li><p>  Vert.x 是一个建立反应式系统的工具包。</p>
</li>
<li><p>  异步，非阻塞的开发模式可能在第一眼看上去难以理解，但是它很快就会变成方便的工具。 同样不该忘记的是，计算机是异步的，所以使用这种开发模式是开启计算机计算能力的正确方法。</p>
</li>
</ul>
<p>我建议，如果你愿意，你可以阅读下面的参考资料：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="http://vertx.io/">Vert.x 主网站</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="http://vertx.io/blog/posts/introduction-to-vertx.html">一个系列博客说明如何开始用 Vert.x 开发</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/vert-x3/vertx-microservice-toolbox">一些为微服务应用开发的基础组件</a></p>
</li>
</ul>
<h2 id="13-参考文献"><a href="#13-参考文献" class="headerlink" title="13. 参考文献"></a>13. 参考文献</h2><p>这是一些推荐的阅读材料。并不是针对微服务或者 Vert.x 的，它们提供的概念层的讨论已经超出了这两个主题。</p>
<ul>
<li><p>  A. S. Tanenbaum, M Van Steam. Distributed Systems - Principles and Paradigms. 2003</p>
</li>
<li><p>  L. Bass, I. Weber, L. Zhu. Devops, A software Architect’s Perspective. 2015</p>
</li>
<li><p>  P. Clements, F. Bachmann, L Bass, D. Garlan, J. Ivers, R. Little, P. Merson, R. Nord, J. Stafford. Documenting Software Architecture. 2010</p>
</li>
<li><p>  S. Krakowiak. Middleware Architecture with Patterns and Frameworks. 2009 (unfinished), <a target="_blank" rel="noopener" href="http://lig-membres.imag.fr/krakowia/Files/MW-Book/Chapters/Preface/preface.html">http://lig-membres.imag.fr/krakowia/Files/MW-Book/Chapters/Preface/preface.html</a></p>
</li>
<li><p>  J. Lewis, M. Fowler. Microservices - a definition of this new architectural term, 2014, <a target="_blank" rel="noopener" href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></p>
</li>
</ul>
<h2 id="14-附录-A-启动，终止，列表命令"><a href="#14-附录-A-启动，终止，列表命令" class="headerlink" title="14. 附录 A - 启动，终止，列表命令"></a>14. 附录 A - 启动，终止，列表命令</h2><p>即便不是必须，Vert.x 提供了一个方便的启动器 <code>Lancher</code> 类。这个类 只 是应用程序的起始点。 它使用指定的参数初始化 Vert.x ，部署给定的竖直体，等等。</p>
<p>首先，这个启动器是可以扩展的。比如，在这个实验课，我们有自己的启动器(<code>io.vertx.workshop.common.Launcher</code>)，它扩展了 Vert.x 自带的。 另外，这个启动器包含了可以扩充的 命令(command) 集合。 <code>运行(run)</code> 是默认的命令来执行指定的竖直体。默认情况下，这里有一些其他可用的命令:</p>
<pre><code>bare      启动一个裸露的 vert.x 实例
list      列出所有 vert.x 应用
run       在自己的 vert.x 实例里执行一个叫做 &lt;main-verticale&gt; 竖直体
start     在后台启动一个 vert.x 应用程序实例
stop      终止一个 vert.x 应用程序
test      执行 Vert.x 单元测试，在自己的 vert.x 实例里调用 &lt;test-verticle&gt;</code></pre>
<p>你也可以添加你的命令。</p>
<p>在这个小节，我们会专注于 <code>start</code>, <code>stop</code> 和 <code>list</code> 命令。</p>
<p>当我们启动了微服务，它们并不会在后台运行，会阻塞我们的终端。 <code>start</code> 命令可以让 Vert.x 应用在后台运行。对于报价生成器应用，我们可以使用下面的命令行：</p>
<pre><code>java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar start -id quote-generator --redirect-output</code></pre>
<p>命令(command) 名字就紧跟这 jar 文件名。<code>id</code> 参数给你的应用起了一个名字。默认情况下，它生成了一个 UUID。 <code>--redirect-output</code> 选项使 Vert.x 把输出重定向到终端。</p>
<p>现在，我们看一个实则列出运行中的 Vert.x 应用，你可以：</p>
<pre><code>java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar list 
Listing vert.x applications...
quote-generator target/quote-generator-1.0-SNAPSHOT-fat.jar</code></pre>
<p>然后，<code>stop</code> 关闭这个应用，你可以用命令：</p>
<pre><code>java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar stop quote-generator</code></pre>
<p>基于此，你可以写一个简单的命令行脚本来启动所有的微服务</p>
<pre><code># Skip this instruction to use your version
cd solution

cd quote-generator
mvn clean package
java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar start -id quote-generator --redirect-output
cd ..

cd portfolio-service
mvn clean package
java -jar target/portfolio-service-1.0-SNAPSHOT-fat.jar start -id portfolio-service --redirect-output
cd ..

cd compulsive-traders
mvn clean package
java -jar target/compulsive-traders-1.0-SNAPSHOT-fat.jar start -id compulsive-traders --redirect-output
cd ..

cd audit-service
mvn clean package
java -jar target/audit-service-1.0-SNAPSHOT-fat.jar start -id audit-service --redirect-output
cd ..

cd trader-dashboard
mvn clean package
java -jar target/trader-dashboard-1.0-SNAPSHOT-fat.jar start -id trader-dashboard --redirect-output
cd ..</code></pre>
<p>当每一个服务都启动以后。你可以用 <code>list</code> 命令查看运行的程序：</p>
<pre><code>java -jar target/trader-dashboard-1.0-SNAPSHOT-fat.jar list
Listing vert.x applications...
quote-generator target/quote-generator-1.0-SNAPSHOT-fat.jar
portfolio-service       target/portfolio-service-1.0-SNAPSHOT-fat.jar
compulsive-traders      target/compulsive-traders-1.0-SNAPSHOT-fat.jar
audit-service   target/audit-service-1.0-SNAPSHOT-fat.jar
trader-dashboard        target/trader-dashboard-1.0-SNAPSHOT-fat.jar</code></pre>
<p>你可以使用任何一个胖 jar 包来执行 <code>list</code> 和 <code>stop</code> 命令</p>
<p>你可以写一个相反的脚本来停止每一个服务：</p>
<pre><code>cd quote-generator
java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar stop trader-dashboard
java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar stop quote-generator
java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar stop audit-service
java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar stop compulsive-traders
java -jar target/quote-generator-1.0-SNAPSHOT-fat.jar stop portfolio-service</code></pre>
<p><code>stop</code> 命令会发送一个信号给它要终止的进程。无论如何，这会需要一些时间。进程不会立即被终止。我们可以用 <code>list</code> 命令查看状态。</p>
<p>[1]. 反应式系统和反应式编程是两个不同的 概念 。反应式编程是使用观察和操作数据流的开发模式。而反应式系统会针对一下作出反应：请求，故障，负载高点，并且通过异步消息相互作用。<br>[2]. 异步：调用者不会等待结果返回，但是传递一个 回调函数(callback) ，以便结果计算出来的时候调用<br>[3]. 非阻塞：代码必须不阻塞线程，所以他必须放弃阻塞IO,长时间的处理，等等情况<br>[4]. 这是软件工程研究所对 架构风格 的规范说明<br>[5]. 更快更容易改变的能力，这和Agile软件工程方法无关</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/interview/2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/interview/2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86.html" class="post-title-link" itemprop="url">技术面试要了解的算法和数据结构知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-26T00:00:00+00:00">2018-10-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">Java 面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="在线练习"><a href="#在线练习" class="headerlink" title="在线练习"></a>在线练习</h4><ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode.com/">LeetCode</a></li>
<li>  <a target="_blank" rel="noopener" href="https://vjudge.net/">Virtual Judge</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.careercup.com/">CareerCup</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.hackerrank.com/">HackerRank</a></li>
<li>  <a target="_blank" rel="noopener" href="https://codefights.com/">CodeFights</a></li>
<li>  <a target="_blank" rel="noopener" href="https://open.kattis.com/">Kattis</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.hackerearth.com/">HackerEarth</a></li>
<li>  <a target="_blank" rel="noopener" href="https://codility.com/programmers/lessons/1-iterations/">Codility</a></li>
<li>  <a target="_blank" rel="noopener" href="http://codeforces.com/">Code Forces</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.codechef.com/">Code Chef</a></li>
<li>  <a target="_blank" rel="noopener" href="http://www.spoj.com/">Sphere Online Judge – SPOJ</a></li>
</ul>
<h4 id="在线编程面试"><a href="#在线编程面试" class="headerlink" title="在线编程面试"></a>在线编程面试</h4><ul>
<li>  <a target="_blank" rel="noopener" href="http://www.gainlo.co/#!/">Gainlo</a></li>
<li>  <a target="_blank" rel="noopener" href="https://refdash.com/">Refdash</a></li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li>  链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。</li>
<li>  <strong>单链表</strong> ：每个节点仅指向下一个节点，最后一个节点指向空（null）。</li>
<li>  <strong>双链表</strong> ：每个节点有两个指针p，n。p指向前一个节点，n指向下一个节点；最后一个节点指向空。</li>
<li>  <strong>循环链表</strong> ：每个节点指向下一个节点，最后一个节点指向第一个节点。</li>
<li>时间复杂度：<ul>
<li>  索引：O(n)</li>
<li>  查找：O(n)</li>
<li>  插入：O(1)</li>
<li>  删除：O(1)</li>
</ul>
</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li>  栈是一个元素集合，支持两个基本操作：push用于将元素压入栈，pop用于删除栈顶元素。</li>
<li>  后进先出的数据结构（Last In First Out, LIFO）</li>
<li>时间复杂度<ul>
<li>  索引：O(n)</li>
<li>  查找：O(n)</li>
<li>  插入：O(1)</li>
<li>  删除：O(1)</li>
</ul>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>  队列是一个元素集合，支持两种基本操作：enqueue 用于添加一个元素到队列，dequeue 用于删除队列中的一个元素。</li>
<li>  先进先出的数据结构（First In First Out, FIFO）。</li>
<li>时间复杂度<ul>
<li>  索引：O(n)</li>
<li>  查找：O(n)</li>
<li>  插入：O(1)</li>
<li>  删除：O(1)</li>
</ul>
</li>
</ul>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><ul>
<li>  树是无向、联通的无环图。</li>
</ul>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>  二叉树是一个树形数据结构，每个节点最多可以有两个子节点，称为左子节点和右子节点。</li>
<li>  <strong>满二叉树（Full Tree）</strong> ：二叉树中的每个节点有 0 或者 2 个子节点。</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/1.jpeg"></p>
<ul>
<li>  <strong>完美二叉树（Perfect Binary）</strong> ：二叉树中的每个节点有两个子节点，并且所有的叶子节点的深度是一样的。</li>
<li>  <strong>完全二叉树</strong> ：二叉树中除最后一层外其他各层的节点数均达到最大值，最后一层的节点都连续集中在最左边。</li>
</ul>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><ul>
<li>  二叉查找树（BST）是一种二叉树。其任何节点的值都大于等于左子树中的值，小于等于右子树中的值。</li>
<li>时间复杂度<ul>
<li>  索引：O(log(n))</li>
<li>  查找：O(log(n))</li>
<li>  插入：O(log(n))</li>
<li>  删除：O(log(n))</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/2.jpeg"></p>
<h4 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h4><ul>
<li>  字典树，又称为基数树或前缀树，是一种用于存储键值为字符串的动态集合或关联数组的查找树。树中的节点并不直接存储关联键值，而是该节点在树中的位置决定了其关联键值。一个节点的所有子节点都有相同的前缀，根节点则是空字符串。</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/3.jpeg"></p>
<h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><ul>
<li>  树状数组，又称为二进制索引树（Binary Indexed Tree，BIT），其概念上是树，但以数组实现。数组中的下标代表树中的节点，每个节点的父节点或子节点的下标可以通过位运算获得。数组中的每个元素都包含了预计算的区间值之和，在整个树更新的过程中，这些计算的值也同样会被更新。</li>
<li>时间复杂度<ul>
<li>  区间求和：O(log(n))</li>
<li>  更新：O(log(n))</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/4.jpeg"></p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><ul>
<li>  线段树是用于存储区间和线段的树形数据结构。它允许查找一个节点在若干条线段中出现的次数。</li>
<li>时间复杂度<ul>
<li>  区间查找：O(log(n))</li>
<li>  更新：O(log(n))</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/5.jpeg"></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li>  堆是一种基于树的满足某些特性的数据结构：整个堆中的所有父子节点的键值都满足相同的排序条件。堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。</li>
<li>时间复杂度<ul>
<li>  索引：O(log(n))</li>
<li>  查找：O(log(n))</li>
<li>  插入：O(log(n))</li>
<li>  删除：O(log(n))</li>
<li>  删除最大值/最小值：O(1)</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/6.jpeg"></p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><ul>
<li>  哈希用于将任意长度的数据映射到固定长度的数据。哈希函数的返回值被称为哈希值、哈希码或者哈希。如果不同的主键得到相同的哈希值，则发生了冲突。</li>
<li>  <strong>Hash Map</strong> ： <em>hash map</em>  是一个存储键值间关系的数据结构。HashMap 通过哈希函数将键转化为桶或者槽中的下标，从而便于指定值的查找。</li>
<li>冲突解决<ul>
<li>  <strong>链地址法（</strong> <strong>Separate Chaining</strong> <strong>）</strong> ：在链地址法中，每个桶（bucket）是相互独立的，每一个索引对应一个元素列表。处理HashMap 的时间就是查找桶的时间（常量）与遍历列表元素的时间之和。</li>
<li>  <strong>开放地址法（</strong> <strong>Open Addressing</strong> <strong>）</strong> ：在开放地址方法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个未被占用的地址。开放地址即某个元素的位置并不永远由其哈希值决定。</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/7.jpeg"></p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ul>
<li>  图是G =（V，E）的有序对，其包括顶点或节点的集合 V 以及边或弧的集合E，其中E包括了两个来自V的元素（即边与两个顶点相关联 ，并且该关联为这两个顶点的无序对）。</li>
<li>  <strong>无向图</strong> ：图的邻接矩阵是对称的，因此如果存在节点 u 到节点 v 的边，那节点 v 到节点 u 的边也一定存在。</li>
<li>  <strong>有向图</strong> ：图的邻接矩阵不是对称的。因此如果存在节点 u 到节点 v 的边并不意味着一定存在节点 v 到节点 u 的边。</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/8.jpeg"></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>  稳定：否</li>
<li>时间复杂度<ul>
<li>  最优：O(nlog(n))</li>
<li>  最差：O(n^2)</li>
<li>  平均：O(nlog(n))</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/9.jpeg"></p>
<h4 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h4><ul>
<li>  合并排序是一种分治算法。这个算法不断地将一个数组分为两部分，分别对左子数组和右子数组排序，然后将两个数组合并为新的有序数组。</li>
<li>  稳定：是</li>
<li>时间复杂度：<ul>
<li>  最优：O(nlog(n))</li>
<li>  最差：O(nlog(n))</li>
<li>  平均：O(nlog(n))</li>
</ul>
</li>
</ul>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li>  桶排序是一种将元素分到一定数量的桶中的排序算法。每个桶内部采用其他算法排序，或递归调用桶排序。</li>
<li>时间复杂度<ul>
<li>  最优：Ω(n + k)</li>
<li>  最差: O(n^2)</li>
<li>  平均：Θ(n + k)</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/10.jpeg"></p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li>  基数排序类似于桶排序，将元素分发到一定数目的桶中。不同的是，基数排序在分割元素之后没有让每个桶单独进行排序，而是直接做了合并操作。</li>
<li>时间复杂度<ul>
<li>  最优：Ω(nk)</li>
<li>  最差: O(nk)</li>
<li>  平均：Θ(nk)</li>
</ul>
</li>
</ul>
<h4 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h4><p>深度优先 <strong>搜索</strong></p>
<ul>
<li>  深度优先搜索是一种先遍历子节点而不回溯的图遍历算法。</li>
<li>  时间复杂度：O(|V| + |E|)</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/11.jpeg"></p>
<p>广度优先 <strong>搜索</strong></p>
<ul>
<li>  广度优先搜索是一种先遍历邻居节点而不是子节点的图遍历算法。</li>
<li>  时间复杂度：O(|V| + |E|)</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/12.jpeg"></p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul>
<li>  拓扑排序是有向图节点的线性排序。对于任何一条节点 u 到节点 v 的边，u 的下标先于 v。</li>
<li>  时间复杂度：O(|V| + |E|)</li>
</ul>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><ul>
<li>  Dijkstra 算法是一种在有向图中查找单源最短路径的算法。</li>
<li>  时间复杂度：O(|V|^2)</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/13.jpeg"></p>
<h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><ul>
<li>  _Bellman-Ford _ 是一种在带权图中查找单一源点到其他节点最短路径的算法。</li>
<li>  虽然时间复杂度大于 Dijkstra 算法，但它可以处理包含了负值边的图。</li>
<li>时间复杂度：<ul>
<li>  最优：O(|E|)</li>
<li>  最差：O(|V||E|)</li>
</ul>
</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/14.jpeg"></p>
<h4 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h4><ul>
<li>  _Floyd-Warshall _ 算法是一种在无环带权图中寻找任意节点间最短路径的算法。</li>
<li>  该算法执行一次即可找到所有节点间的最短路径（路径权重和）。</li>
<li>时间复杂度：<ul>
<li>  最优：O(|V|^3)</li>
<li>  最差：O(|V|^3)</li>
<li>  平均：O(|V|^3)</li>
</ul>
</li>
</ul>
<h4 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h4><ul>
<li>  最小生成树算法是一种在无向带权图中查找最小生成树的贪心算法。换言之，最小生成树算法能在一个图中找到连接所有节点的边的最小子集。</li>
<li>  时间复杂度：O(|V|^2)</li>
</ul>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><ul>
<li>  _Kruskal _ 算法也是一个计算最小生成树的贪心算法，但在 Kruskal 算法中，图不一定是连通的。</li>
<li>  时间复杂度：O(|E|log|V|)</li>
</ul>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><ul>
<li>  贪心算法总是做出在当前看来最优的选择，并希望最后整体也是最优的。</li>
<li>使用贪心算法可以解决的问题必须具有如下两种特性：<ul>
<li>最优子结构<ul>
<li>  问题的最优解包含其子问题的最优解。</li>
</ul>
</li>
<li>贪心选择<ul>
<li>  每一步的贪心选择可以得到问题的整体最优解。</li>
</ul>
</li>
</ul>
</li>
<li>  实例-硬币选择问题</li>
<li>  给定期望的硬币总和为 V 分，以及 n 种硬币，即类型是 i 的硬币共有 coinValue[i] 分，i的范围是 [0…n – 1]。假设每种类型的硬币都有无限个，求解为使和为 V 分最少需要多少硬币？</li>
<li>  硬币：便士（1美分），镍（5美分），一角（10美分），四分之一（25美分）。</li>
<li>假设总和 V 为41,。我们可以使用贪心算法查找小于或者等于 V 的面值最大的硬币，然后从 V 中减掉该硬币的值，如此重复进行。<ul>
<li>  V = 41 | 使用了0个硬币</li>
<li>  V = 16 | 使用了1个硬币(41 – 25 = 16)</li>
<li>  V = 6 | 使用了2个硬币(16 – 10 = 6)</li>
<li>  V = 1 | 使用了3个硬币(6 – 5 = 1)</li>
<li>  V = 0 | 使用了4个硬币(1 – 1 = 0)</li>
</ul>
</li>
</ul>
<p>位 <strong>运算</strong></p>
<ul>
<li>  位运算即在比特级别进行操作的技术。使用位运算技术可以带来更快的运行速度与更小的内存使用。</li>
<li>  测试第 k 位：s &amp; (1 &lt;&lt; k);</li>
<li>  设置第k位：s |= (1 &lt;&lt; k);</li>
<li>  关闭第k位：s &amp;= ~(1 &lt;&lt; k);</li>
<li>  切换第k位：s ^= (1 &lt;&lt; k);</li>
<li>  乘以2n：s &lt;&lt; n;</li>
<li>  除以2n：s &gt;&gt; n;</li>
<li>  交集：s &amp; t;</li>
<li>  并集：s | t;</li>
<li>  减法：s &amp; ~t;</li>
<li>  提取最小非0位：s &amp; (-s);</li>
<li>  提取最小0位：~s &amp; (s + 1);</li>
<li>  交换值：x ^= y; y ^= x; x ^= y;</li>
</ul>
<h2 id="运行时分析"><a href="#运行时分析" class="headerlink" title="运行时分析"></a><strong>运行时分析</strong></h2><h4 id="大-O-表示"><a href="#大-O-表示" class="headerlink" title="大 O 表示"></a>大 O 表示</h4><ul>
<li>  大 O 表示用于表示某个算法的上界，用于描述最坏的情况。</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/15.jpeg"></p>
<h4 id="小-O-表示"><a href="#小-O-表示" class="headerlink" title="小 O 表示"></a>小 O 表示</h4><ul>
<li>  小 O 表示用于描述某个算法的渐进上界，二者逐渐趋近。</li>
</ul>
<h4 id="大-Ω-表示"><a href="#大-Ω-表示" class="headerlink" title="大 Ω 表示"></a>大 Ω 表示</h4><ul>
<li>  大 Ω 表示用于描述某个算法的渐进下界。</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/16.jpeg"></p>
<h4 id="小-ω-表示"><a href="#小-ω-表示" class="headerlink" title="小 ω 表示"></a>小 ω 表示</h4><ul>
<li>  小 ω 表示用于描述某个算法的渐进下界，二者逐渐趋近。</li>
</ul>
<h4 id="Theta-Θ-表示"><a href="#Theta-Θ-表示" class="headerlink" title="Theta Θ 表示"></a>Theta Θ 表示</h4><ul>
<li>  Theta Θ 表示用于描述某个算法的确界，包括最小上界和最大下界。</li>
</ul>
<p><img src="./2018-10-26_%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86/17.jpeg"></p>
<h4 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h4><ul>
<li>数据结构<ul>
<li>  <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=mFPmKGIrQs4&index=1&list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd">UC Berkeley Data Structures</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=T0yzrZL1py0&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=1">MIT Advanced Data Structures</a></li>
</ul>
</li>
<li>算法<ul>
<li>  <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=1">MIT Introduction to Algorithms</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c">MIT Advanced Algorithms</a></li>
</ul>
</li>
</ul>
<h4 id="面试宝典"><a href="#面试宝典" class="headerlink" title="面试宝典"></a>面试宝典</h4><ul>
<li>  <a target="_blank" rel="noopener" href="https://www.amazon.com/Competitive-Programming-3rd-Steven-Halim/dp/B00FG8MNN8">Competitive Programming 3 – Steven Halim &amp; Felix Halim</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850/ref=sr_1_1?s=books&ie=UTF8">Cracking The Coding Interview – Gayle Laakmann McDowell</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.amazon.com/Cracking-PM-Interview-Product-Technology-ebook/dp/B00ISYMUR6/ref=sr_1_1?s=books&ie=UTF8">Cracking The PM Interview – Gayle Laakmann McDowell &amp; Jackie Bavaro</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&qid=1490295989&sr=8-1&keywords=Introduction+to+Algorithms">Introduction to Algorithms – Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest &amp; Clifford Stein</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.36dsj.com/archives/80717">技术面试要了解的算法和数据结构知识</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/interview/2018-10-25_Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/interview/2018-10-25_Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html" class="post-title-link" itemprop="url">Java面试整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-25T00:00:00+00:00">2018-10-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">Java 面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-谈谈你对-springmvc-的理解"><a href="#1-谈谈你对-springmvc-的理解" class="headerlink" title="1.谈谈你对 springmvc 的理解"></a>1.谈谈你对 springmvc 的理解</h3><p>第一印象，以为问的 spring，但是别人问的好像是 springmvc</p>
<p>ps: spring mvc 类似于 struts 的一个 MVC 开框架，其实都是属于 spring，spring mvc需要有 spring 的架包作为支撑才能跑起来，所以 spingMVC 只是 sping 中一个小功能，小模块而已。</p>
<p>继续谈 spring：</p>
<p>Spring 的两大核心 AOP 与 IOC，可以单独用于任何应用，包括与 Struts 等 MVC 框架与Hibernate 等 ORM 框架的集成。</p>
<p>Spring 的核心是 Bean 工厂(Bean Factory)，用以构造我们所需要的(Model)。<br>在此基础之上，Spring 提供了 AOP（Aspect-Oriented Programming, 面向层面的编程）的实现，用它来提供非管理环境下申明方式的事务、安全等服务；</p>
<p>对 Bean 工厂的扩展 ApplicationContext 更加方便我们实现 J2EE 的应用；</p>
<p>DAO/ORM 的实现方便我们进行数据库的开发；</p>
<p>Web MVC 和 Spring Web 提供了 Java Web 应用的框架或与其他流行的 Web<br>框架进行集成。</p>
<p>那么 AOP 和 IOC 又是什么呢？</p>
<p>IOC 控制反转，简单的理解就是将类的创建和依赖关系写在配置文件里，由配置文件注入，实现了松耦合。</p>
<p>形象的说明：所谓依赖，从程序的角度看，就是比如 A 要调用 B 的方法，那么 A 就依赖于B，反正 A 要用到 B，则 A 依赖于 B。所谓倒置，你必须理解如果不倒置，会怎么着，因为A 必须要有 B，才可以调用 B，如果不倒置，意思就是 A 主动获取 B 的实例：B b = new B()，这就是最简单的获取 B 实例的方法（当然还有各种设计模式可以帮助你去获得 B 的实例，比如工厂、Locator 等等），然后你就可以调用 b 对象了。</p>
<p>所以，不依赖倒置(控制反转)，意味着 A 要主动获取 B，才能使用 B；</p>
<p>AOP 面向切面，简单理解：就是将安全，事务等于程序逻辑相对独立的功能抽取出来，利用 spring 的配置文件将这些功能插进去，实现了按照方面编程，提高了复用性。</p>
<p>形象的说明：面向切面编程的目标就是分离关注点。什么是关注点呢？就是你要做的事，就是关注点。</p>
<p>从 Spring 的角度看，AOP 最大的用途就在于提供了事务管理的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring 在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！</p>
<h3 id="2-关于-springmvc-和-structs-的对比"><a href="#2-关于-springmvc-和-structs-的对比" class="headerlink" title="2.关于 springmvc 和 structs 的对比"></a>2.关于 springmvc 和 structs 的对比</h3><p>很常见的问题，个人理解，从两方面来说：</p>
<p>a&gt; 设计思想上： spring 可以理解为一个 servlet 的扩展，而 structs 则更符合面向对象思想，它是一个过滤器 filter.</p>
<p>b&gt; 实现机制上：springmvc 的拦截是方法级别的拦截，一个方法对应一个 URL 以及一个request 和 response 对象，所以 URL 参数对于方法是独享的，而 structs 则是类级别的拦截，那么每一次请求的 URL 都会实例化这个 action 类，而类属性被所有方法共享，所以一个 action 共享一个 request 和 response 对象，参数的传递是通过 get/set 来实现。</p>
<p>c&gt; 对 于 ajax 的支持 ： springmvc 对 于 ajax 的支持更加简单 ，只需一个注解<br>@ResponseBody ，然后直接返回响应文本即可，而 structs 则需要 out 流输出。</p>
<h3 id="3-对于常见的-POST-请求乱码，该如何处理？"><a href="#3-对于常见的-POST-请求乱码，该如何处理？" class="headerlink" title="3.对于常见的 POST 请求乱码，该如何处理？"></a>3.对于常见的 POST 请求乱码，该如何处理？</h3><p>常用的有三种方式：<br>a&gt; 在 web.xml 中加入 encoding 来过滤 URL<br>b&gt; 修改 Tomcat 的配置文件，添加编码，使服务器的编码和工程的编码一致<br>c&gt; 对方法参数进行 String 编码</p>
<h3 id="4-mybatis-的生命周期是怎么样的？"><a href="#4-mybatis-的生命周期是怎么样的？" class="headerlink" title="4.mybatis 的生命周期是怎么样的？"></a>4.mybatis 的生命周期是怎么样的？</h3><p>a&gt; 创建 SqlSessionFactory<br>b&gt;通过 SqlSessionFactory 创建 SqlSession<br>c&gt;通过 sqlsession 执行数据库操作<br>d&gt;调用 session.commit()提交事务<br>e&gt;调用 session.close()关闭会话</p>
<h3 id="5-mybatis-的配置文件有哪些内容？"><a href="#5-mybatis-的配置文件有哪些内容？" class="headerlink" title="5.mybatis 的配置文件有哪些内容？"></a>5.mybatis 的配置文件有哪些内容？</h3><p>properties（属性）<br>settings（配置）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境集合属性对象）<br>environment（环境子属性对象）<br>transactionManager（事务管理）<br>dataSource（数据源）<br>mappers（映射器）</p>
<h3 id="6-使用-mybatis-的-mapper-接口调用时有"><a href="#6-使用-mybatis-的-mapper-接口调用时有" class="headerlink" title="6.使用 mybatis 的 mapper 接口调用时有"></a>6.使用 mybatis 的 mapper 接口调用时有</h3><p>哪些要求?<br>a&gt; Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同<br>b&gt; Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的<br>parameterType 的类型相同<br>c&gt; Mapper 接口方法的输出参数类型和mapper.xml 中定义的每个sql 的 resultType的类型相同<br>d&gt; Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</p>
<h3 id="7-mybatis-和-hibernate-的不同"><a href="#7-mybatis-和-hibernate-的不同" class="headerlink" title="7.mybatis 和 hibernate 的不同"></a>7.mybatis 和 hibernate 的不同</h3><p>a&gt; Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的 sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。<br>b&gt; mybatis 相对于 hibernate 很灵活，体现在 sql 语句的可控性，但是这就对不同数据库的适应就要写复杂的配置文件。</p>
<h3 id="8-mybatis-的缓存？"><a href="#8-mybatis-的缓存？" class="headerlink" title="8.mybatis 的缓存？"></a>8.mybatis 的缓存？</h3><p>a&gt; Mybatis 首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis 内部存储缓存使用一个 HashMap， key 为 hashCode + sqlId + Sql 语句。value 为从查询出来映射生成的 java 对象<br>b&gt; Mybatis 的二级缓存即查询缓存，它的作用域是一个 mapper 的namespace，即在同一个 namespace 中查询 sql 可以从缓存中获取数据。二级缓存是可以跨 SqlSession的。</p>
<h3 id="9-为什么使用-hibernate，好处是什么？"><a href="#9-为什么使用-hibernate，好处是什么？" class="headerlink" title="9.为什么使用 hibernate，好处是什么？"></a>9.为什么使用 hibernate，好处是什么？</h3><p>a&gt; 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。<br>b&gt; hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</p>
<h3 id="10-什么是-hibernate-的延迟加载？"><a href="#10-什么是-hibernate-的延迟加载？" class="headerlink" title="10. 什么是 hibernate 的延迟加载？"></a>10. 什么是 hibernate 的延迟加载？</h3><p>延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。在 Hibernate 中提供了对实体对象的延迟加载以及对集合的延迟加载，另外在 Hibernate3 中还提供了对属性的延迟加载。</p>
<h3 id="11-怎么优化-hibernate？"><a href="#11-怎么优化-hibernate？" class="headerlink" title="11. 怎么优化 hibernate？"></a>11. 怎么优化 hibernate？</h3><p>a&gt; 使用双向一对多关联，不使用单向一对多<br>b&gt; 灵活使用单向一对多关联<br>c&gt; 一对多集合使用 Bag,多对多集合使用 Set<br>d&gt; 表字段要少，表关联可以使用二级缓存</p>
<h3 id="12-hibernate-中-save-和-saveorupdate？"><a href="#12-hibernate-中-save-和-saveorupdate？" class="headerlink" title="12. hibernate 中 save 和 saveorupdate？"></a>12. hibernate 中 save 和 saveorupdate？</h3><p>save() 方法很显然是执行保存操作的，如果是对一个新的刚 new 出来的对象进行保存，自然要使用这个方法了，数据库中没有这个对象。<br>update() 如果是对一个已经存在的托管对象进行更新那么肯定是要使用update() 方法了，数据中有这个对象。<br>saveOrUpdate() 这个方法是更新或者插入，有主键就执行更新，如果没有主键就执行插入。<br>在 Hibernate 中 saveOrUpdate()方法在执行的时候，先会去 session 中去找存不存在指定的字段，如果存在直接 update，否则 save，这个时候问题就发生了</p>
<h3 id="13-缓存技术？"><a href="#13-缓存技术？" class="headerlink" title="13. 缓存技术？"></a>13. 缓存技术？</h3><p>可做缓存的技术，Ehcache, Linkedhashmap, Memcached, Redis，视需求而定。<br>其中，LinkedHashMap 和 Ehcache 都是单机缓存技术，即只能在一个应用内实现缓存，不能实现多台机器使用相同的缓存区域（分布式缓存），LinkedHashMap 的底层是用 HashMap 实现的，特点元素的排序是按链表方式排序，按写入或输出的顺序排序，最后一次写入或读取的元素放到最后。JDK 自带 Memcached、Redis 都可以适用于分布式缓存，需要独立部署，使多台机器可以使用同一个缓存服务器，实现集群的缓存共享，其中 redis 支持的数据类型更多，使用更方便，最重要的是：Memcached 的数据只能存在内存中，重启后即消失，而 Redis 可以持久化，因此 Redis 可以作为一个 NoSql 数据库使用。</p>
<h3 id="14-什么是反射机制？"><a href="#14-什么是反射机制？" class="headerlink" title="14. 什么是反射机制？"></a>14. 什么是反射机制？</h3><p>场景：一个大型的软件，不可能一次就把 它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定 是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。<br>反射的优点当然是体现在它的动态性上面，能运行时确定类型，绑定对象。动态编译最大限度发挥了 java 的灵活性，体现了多态的应用，降低类之间的藕合性。 一句话，反射机制的优点就是可以实现动态创建对象和编译，缺点就是会消耗一些资源。</p>
<h3 id="15-hashtable-和-hashmap-的区别？"><a href="#15-hashtable-和-hashmap-的区别？" class="headerlink" title="15. hashtable 和 hashmap 的区别？"></a>15. hashtable 和 hashmap 的区别？</h3><p>Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。从 map 接口实现来看，HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。由于是轻量级实现，hash 算法是一致的，不存在谁的效率高谁的效率低。</p>
<h3 id="16-接口和抽象类的区别？"><a href="#16-接口和抽象类的区别？" class="headerlink" title="16. 接口和抽象类的区别？"></a>16. 接口和抽象类的区别？</h3><p>从两个方面来回答：</p>
<p>a&gt; 语法层面：<br>接口只能存在 public abstract 方法，而抽象类可以提供成员方法的具体实现。<br>接口的成员变量是 public static final 类型的，而抽象类是没有限制的。<br>接口不可以保护静态代码块以及静态方法，而抽象类是可以的。<br>接口是可以多实现的，抽象类只能单继承。</p>
<p>b&gt; 设计层面：<br>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板。</p>
<h3 id="17-线程安全和不安全是什么意思？"><a href="#17-线程安全和不安全是什么意思？" class="headerlink" title="17. 线程安全和不安全是什么意思？"></a>17. 线程安全和不安全是什么意思？</h3><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。<br>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据<br>造成所得到的数据是脏数据。</p>
<h3 id="18-怎么实现线程？"><a href="#18-怎么实现线程？" class="headerlink" title="18. 怎么实现线程？"></a>18. 怎么实现线程？</h3><p>在语法上有两种，但是他们其实是一种方式， Thread 类的实例就是一个线程但是它需要调用 Runnable 接口来执行，由于线程类本身就是调用的 Runnable 接口所以你可以继承Thread 类或者直接调用 Runnable 接口来重写 run()方法实现线程。</p>
<h3 id="19-Thread-类中的-start-和-run-方法有什么区别"><a href="#19-Thread-类中的-start-和-run-方法有什么区别" class="headerlink" title="19. Thread 类中的 start() 和 run() 方法有什么区别?"></a>19. Thread 类中的 start() 和 run() 方法有什么区别?</h3><p>当你调用 run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h3 id="20-ThreadLocal-是什么？"><a href="#20-ThreadLocal-是什么？" class="headerlink" title="20. ThreadLocal 是什么？"></a>20. ThreadLocal 是什么？</h3><p>ThreadLocal 并不是一个 Thread，而是 Thread 的局部变量，当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<h3 id="21-ThreadLocal-和线程同步相比的优势？"><a href="#21-ThreadLocal-和线程同步相比的优势？" class="headerlink" title="21. ThreadLocal 和线程同步相比的优势？"></a>21. ThreadLocal 和线程同步相比的优势？</h3><p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
<p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>而 ThreadLocal 则从另一个角度来解决多线程的并发访问。ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。</p>
<p>简单来说：对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h3 id="22-谈谈你业务中的分布式？"><a href="#22-谈谈你业务中的分布式？" class="headerlink" title="22. 谈谈你业务中的分布式？"></a>22. 谈谈你业务中的分布式？</h3><p>这个问题，从场景来回答，为什么需要分布式？<br>随着互联网的发展，传统单工程项目的很多性能瓶颈越发凸显，性能瓶颈可以有几个方面。<br>a&gt; 应用服务层：随着用户量的增加，并发量增加，单项目难以承受如此大的并发请求导致的性能瓶颈。<br>b&gt; 底层数据库层：随着业务的发展，数据库压力越来越大，导致的性能瓶颈。</p>
<p>针对上面两点，我觉得可以从两方面解决。</p>
<h4 id="应用服务层的解决方案有几种："><a href="#应用服务层的解决方案有几种：" class="headerlink" title="应用服务层的解决方案有几种："></a>应用服务层的解决方案有几种：</h4><p>应用系统集群：应用系统集群最简单的就是服务器集群，比如：tomcat 集群。应用系统集群的时候，比较凸显的问题是 session 共享，session 共享我们一是可以通过服务器插件来解决。另外一种也可以通过 redis 等中间件实现。</p>
<p>服务化拆分：服务化拆分，是目前非常火热的一种方式。现在都在提微服务话。通过对传统项目进行服务化拆分，达到服务独立解耦，单服务又可以横向扩容。服务化拆分遇到的经典问题就是分布式事务问题。目前，比较常用的分布式事务解决方案有几种：消息最终一致性、TCC 补偿型事务、尽最大能力通知。</p>
<h4 id="底层数据库层："><a href="#底层数据库层：" class="headerlink" title="底层数据库层："></a>底层数据库层：</h4><p>如果系统的性能压力出现在数据库，那我们就可以读写分离、分库分表等方案进行解决。</p>
<h3 id="23-怎么解决-session-共享的问题？"><a href="#23-怎么解决-session-共享的问题？" class="headerlink" title="23. 怎么解决 session 共享的问题？"></a>23. 怎么解决 session 共享的问题？</h3><p>其实，我也没处理过，查找了一些资料：<br>a&gt; 客户端 cookie 加密。（一般用于内网中企业级的系统中，要求用户浏览器端的 cookie不能禁用，禁用的话，该方案会失效）。<br>b&gt; 集群中，各个应用服务器提供了 session 复制的功能，tomcat 和 jboss 都实现了这样的功能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session 数据需要序列化，影响性能。<br>c&gt; session 的持久化，使用数据库或者 redis 来保存 session。就算服务器宕机也没事儿，数据库中的 session 照样存在。特点：每次请求 session 都要读写数据库，会带来性能开销。使用内存数据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>d&gt; 用共享存储来保存 session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞一台服务器，全部对 session 落地。特点：频繁的进行序列化和反序列化会影响性能。</p>
<p>From:  <a target="_blank" rel="noopener" href="https://hacpai.com/article/1492737273763">https://hacpai.com/article/1492737273763</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-12-16_Linux%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E6%B1%82%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-12-16_Linux%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E6%B1%82%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86.html" class="post-title-link" itemprop="url">Linux 两个文件求交集、并集、差集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-16T00:00:00+00:00">2017-12-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、交集"><a href="#一、交集" class="headerlink" title="一、交集"></a>一、交集</h1><pre><code>sort a.txt b.txt | uniq -d</code></pre>
<h1 id="二、并集"><a href="#二、并集" class="headerlink" title="二、并集"></a>二、并集</h1><pre><code>sort a.txt b.txt | uniq </code></pre>
<h1 id="三、差集"><a href="#三、差集" class="headerlink" title="三、差集"></a>三、差集</h1><p>a.txt-b.txt:</p>
<pre><code>sort a.txt b.txt b.txt | uniq -u</code></pre>
<p>b.txt - a.txt:</p>
<pre><code>sort b.txt a.txt a.txt | uniq -u</code></pre>
<h1 id="四、相关的解释"><a href="#四、相关的解释" class="headerlink" title="四、相关的解释"></a>四、相关的解释</h1><p>使用sort可以将文件进行排序，可以使用sort后面的玲玲，例如 -n 按照数字格式排序，例如 -i 忽略大小写，例如使用-r 为逆序输出等</p>
<p>uniq为删除文件中重复的行，得到文件中唯一的行，后面的命令 -d 表示的是输出出现次数大于1的内容 -u表示的是输出出现次数为1的内容，那么对于上述的求交集并集差集的命令做如下的解释：</p>
<p>sort a.txt b.txt | uniq -d：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，使用-d输出两个文件中次数大于1的内容，即是得到交集</p>
<p>sort a.txt b.txt | uniq ：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，即可得到两个文件的并集</p>
<p>sort a.txt b.txt b.txt | uniq -u：将两个文件排序，最后输出a.txt b.txt b.txt文件中只出现过一次的内容，因为有两个b.txt所以只会输出只在a.txt出现过一次的内容，即是a.txt-b.txt差集</p>
<p>对于b.txt-a.txt为同理</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-12-15_%E8%BF%9140%E5%BC%A0%E5%9B%BE%E8%A7%A3%E8%A2%AB%E9%97%AE%E5%8D%83%E7%99%BE%E9%81%8D%E7%9A%84TCP.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-12-15_%E8%BF%9140%E5%BC%A0%E5%9B%BE%E8%A7%A3%E8%A2%AB%E9%97%AE%E5%8D%83%E7%99%BE%E9%81%8D%E7%9A%84TCP.html" class="post-title-link" itemprop="url">硬不硬你说了算！近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-14T00:00:00+00:00">2017-12-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文：<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/964c8184326daff02aea8a746">https://xie.infoq.cn/article/964c8184326daff02aea8a746</a></p>
<h5 id="每日一句英语学习，每天进步一点点："><a href="#每日一句英语学习，每天进步一点点：" class="headerlink" title="每日一句英语学习，每天进步一点点："></a>每日一句英语学习，每天进步一点点：</h5><p><img src="https://static001.geekbang.org/infoq/49/499d675ebb7370be1b4f48072165cd97.png"></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管面试 Java 、C/C++、Python 等开发岗位， <code>TCP</code> 的知识点可以说是的必问的了。</p>
<p>任 TCP 虐我千百遍，我仍待 TCP 如初恋。</p>
<p>遥想小林当年校招时常因 <code>TCP</code> 面试题被刷，真是又爱又狠….</p>
<p>过去不会没关系，今天就让我们来消除这份恐惧，微笑着勇敢的面对它吧！</p>
<p>所以小林整理了关于 TCP 三次握手和四次挥手的面试题型，跟大家一起探讨探讨。</p>
<h3 id="1-TCP-基本认识"><a href="#1-TCP-基本认识" class="headerlink" title="1. TCP 基本认识"></a>1. TCP 基本认识</h3><p><img src="https://static001.geekbang.org/infoq/89/894da164df8246a5aade7ef066caf227.png"></p>
<h3 id="2-TCP-连接建立"><a href="#2-TCP-连接建立" class="headerlink" title="2. TCP 连接建立"></a>2. TCP 连接建立</h3><p><img src="https://static001.geekbang.org/infoq/c8/c86218625f00e557463c2b4f8fe584b9.png"></p>
<h3 id="3-TCP-连接断开"><a href="#3-TCP-连接断开" class="headerlink" title="3. TCP 连接断开"></a>3. TCP 连接断开</h3><p><img src="https://static001.geekbang.org/infoq/2e/2e64328896031a540c627b9d14b7c74a.png"></p>
<h3 id="4-Socket-编程"><a href="#4-Socket-编程" class="headerlink" title="4. Socket 编程"></a>4. Socket 编程</h3><p><img src="https://static001.geekbang.org/infoq/28/28d927271d27c27d17418f08c1209c26.png"></p>
<blockquote>
<p>PS：本次文章不涉及 TCP 流量控制、拥塞控制、可靠性传输等方面知识，这些留在下篇哈！</p>
</blockquote>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="01-TCP-基本认识"><a href="#01-TCP-基本认识" class="headerlink" title="01 TCP 基本认识"></a>01 TCP 基本认识</h3><blockquote>
<h4 id="瞧瞧-TCP-头格式"><a href="#瞧瞧-TCP-头格式" class="headerlink" title="瞧瞧 TCP 头格式"></a><strong>瞧瞧 TCP 头格式</strong></h4></blockquote>
<p>我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</p>
<p><img src="https://static001.geekbang.org/infoq/c4/c4d5f4de31a8128cfba6cebc0af54329.png"></p>
<p>序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</p>
<p>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p>
<p>控制位：</p>
<ul>
<li><p>ACK：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</p>
</li>
<li><p>RST：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</p>
</li>
<li><p>SYN：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</p>
</li>
<li><p>FIN：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</p>
</li>
</ul>
<blockquote>
<h4 id="为什么需要-TCP-协议？-TCP-工作在哪一层？"><a href="#为什么需要-TCP-协议？-TCP-工作在哪一层？" class="headerlink" title="为什么需要 TCP 协议？ TCP 工作在哪一层？"></a><strong>为什么需要 TCP 协议？ TCP 工作在哪一层？</strong></h4></blockquote>
<p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p><img src="https://static001.geekbang.org/infoq/7c/7cd7bee694090e3947e390d55609d7a5.png"></p>
<p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p>
<p>因为 TCP 是一个工作在传输层的<em>可靠</em>数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p>
<blockquote>
<h4 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a><strong>什么是 TCP ？</strong></h4></blockquote>
<p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p><img src="https://static001.geekbang.org/infoq/df/df503788d8161d8cb54e5d989a8681d0.png"></p>
<ul>
<li><p>面向连接：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li><p>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p>字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p>
</li>
</ul>
<blockquote>
<h4 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a><strong>什么是 TCP 连接？</strong></h4></blockquote>
<p>我们来看看 RFC 793 是如何定义「连接」的：</p>
<p>*Connections:</p>
<p>The reliability and flow control mechanisms described above require</p>
<p>that TCPs initialize and maintain certain status information for</p>
<p>each data stream.  The combination of this information, including</p>
<p>sockets, sequence numbers, and window sizes, is called a connection.*</p>
<p>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</p>
<p><img src="https://static001.geekbang.org/infoq/16/1669ba151945024e8d35d00ed11cd102.png"></p>
<p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p>
<ul>
<li><p>Socket：由 IP 地址和端口号组成</p>
</li>
<li><p>序列号：用来解决乱序问题等</p>
</li>
<li><p>窗口大小：用来做流量控制</p>
</li>
</ul>
<blockquote>
<h4 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a><strong>如何唯一确定一个 TCP 连接呢？</strong></h4></blockquote>
<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li><p>源地址</p>
</li>
<li><p>源端口</p>
</li>
<li><p>目的地址</p>
</li>
<li><p>目的端口</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/c6/c6657c60da6096dbb64516b23faf8bbf.png"></p>
<p>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<blockquote>
<h4 id="有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a><strong>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</strong></h4></blockquote>
<p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:</p>
<p><img src="https://static001.geekbang.org/infoq/7d/7d3d56db341c40b63f870cb867126780.png"></p>
<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p>
<ul>
<li><p>首先主要是文件描述符限制，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目；</p>
</li>
<li><p>另一个是内存限制，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p>
</li>
</ul>
<blockquote>
<h4 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a><strong>UDP 和 TCP 有什么区别呢？分别的应用场景是？</strong></h4></blockquote>
<p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p>
<p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（ 64 位），UDP 的头部格式如下：</p>
<p><img src="https://static001.geekbang.org/infoq/cd/cd435b1bdfb3928a9b0eb3835fd9d170.png"></p>
<ul>
<li><p>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</p>
</li>
<li><p>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</p>
</li>
<li><p>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</p>
</li>
</ul>
<p>TCP 和 UDP 区别：</p>
<ol>
<li>连接</li>
</ol>
<ul>
<li><p>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</p>
</li>
<li><p>UDP 是不需要连接，即刻传输数据。</p>
</li>
</ul>
<ol start="2">
<li>服务对象</li>
</ol>
<ul>
<li><p>TCP 是一对一的两点服务，即一条连接只有两个端点。</p>
</li>
<li><p>UDP 支持一对一、一对多、多对多的交互通信</p>
</li>
</ul>
<ol start="3">
<li>可靠性</li>
</ol>
<ul>
<li><p>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</p>
</li>
<li><p>UDP 是尽最大努力交付，不保证可靠交付数据。</p>
</li>
</ul>
<ol start="4">
<li>拥塞控制、流量控制</li>
</ol>
<ul>
<li><p>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</p>
</li>
<li><p>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</p>
</li>
</ul>
<ol start="5">
<li>首部开销</li>
</ol>
<ul>
<li><p>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</p>
</li>
<li><p>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</p>
</li>
</ul>
<p>TCP 和 UDP 应用场景：</p>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><p><code>FTP</code> 文件传输</p>
</li>
<li><p><code>HTTP</code> / <code>HTTPS</code></p>
</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li><p>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</p>
</li>
<li><p>视频、音频等多媒体通信</p>
</li>
<li><p>广播通信</p>
</li>
</ul>
<blockquote>
<h4 id="为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></h4></blockquote>
<p>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。</p>
<blockquote>
<h4 id="为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？"><a href="#为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？" class="headerlink" title="为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？"></a><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></h4></blockquote>
<p>先说说 TCP 是如何计算负载数据长度：</p>
<p><img src="https://static001.geekbang.org/infoq/5b/5b4439c86a6c26b88021821ce52bc900.png"></p>
<p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>大家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p>
<p>这么一问，确实感觉 UDP 「包长度」是冗余的。</p>
<p><strong>因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4 </code>字节的整数倍。</strong></p>
<p>如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以小林觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</p>
<h3 id="02-TCP-连接建立"><a href="#02-TCP-连接建立" class="headerlink" title="02 TCP 连接建立"></a>02 TCP 连接建立</h3><blockquote>
<h4 id="TCP-三次握手过程和状态变迁"><a href="#TCP-三次握手过程和状态变迁" class="headerlink" title="TCP 三次握手过程和状态变迁"></a><strong>TCP 三次握手过程和状态变迁</strong></h4></blockquote>
<p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手而进行的。</p>
<p><img src="https://static001.geekbang.org/infoq/07/07b64eaf858949d47eb4f849ef4c1da6.png"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/ce/ceb79461f00b1bdc6e165e772b187a5c.png"></p>
<ul>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。 </li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/a4/a47d635b1229d727cbe5d29cf1fe0d2d.png"></p>
<ul>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/0f/0f78ca8ec8adab08063c638dd1d854c2.png"></p>
<ul>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</p>
</li>
<li><p>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</p>
</li>
</ul>
<p>从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。</p>
<p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<blockquote>
<h4 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a><strong>如何在 Linux 系统中查看 TCP 状态？</strong></h4></blockquote>
<p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>
<p><img src="https://static001.geekbang.org/infoq/c2/c2705e8698ff55a3d8e24addab283ec1.png"></p>
<blockquote>
<h4 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a><strong>为什么是三次握手？不是两次、四次？</strong></h4></blockquote>
<p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p>
<p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p>
<p>在前面我们知道了什么是 TCP 连接：</p>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</li>
</ul>
<p>所以，重要的是为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</p>
<p>接下来以三个方面分析三次握手的原因：</p>
<ul>
<li><p>三次握手才可以阻止重复历史连接的初始化（主要原因）</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
</li>
</ul>
<p>原因一：避免历史连接</p>
<p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的首要原因：</p>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？</p>
<p><img src="https://static001.geekbang.org/infoq/77/77d3d90d038d9fd8c4b5a958585a0275.png"></p>
<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p>
<ul>
<li><p>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</p>
</li>
<li><p>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</p>
</li>
<li><p>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</p>
</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li><p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</p>
</li>
<li><p>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</p>
</li>
</ul>
<p>所以， TCP 使用三次握手建立连接的最主要原因是防止历史连接初始化了连接。</p>
<p>原因二：同步双方初始序列号</p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：  </p>
<ul>
<li><p>接收方可以去除重复的数据；</p>
</li>
<li><p>接收方可以根据数据包的序列号按序接收；</p>
</li>
<li><p>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</p>
</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p>
<p><img src="https://static001.geekbang.org/infoq/4c/4c7d19df7e5964f1ee7a0a079ac30c51.png"></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p>原因三：避免资源浪费</p>
<p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<p><img src="https://static001.geekbang.org/infoq/9f/9fbe25cb230d0eeac7026705ae0baaac.png"></p>
<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<p>小结</p>
<p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p>
</li>
<li><p>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
</li>
</ul>
<blockquote>
<h4 id="为什么客户端和服务端的初始序列号-ISN-是不相同的？"><a href="#为什么客户端和服务端的初始序列号-ISN-是不相同的？" class="headerlink" title="为什么客户端和服务端的初始序列号 ISN 是不相同的？"></a><strong>为什么客户端和服务端的初始序列号 ISN 是不相同的？</strong></h4></blockquote>
<p>因为网络中的报文会延迟、会复制重发、也有可能丢失，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p>
<blockquote>
<h4 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a><strong>初始序列号 ISN 是如何随机产生的？</strong></h4></blockquote>
<p>起始 <code>ISN</code> 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。</p>
<p>ISN = M + F (localhost, localport, remotehost, remoteport)</p>
<ul>
<li><p><code>M</code> 是一个计时器，这个计时器每隔 4 毫秒加 1。</p>
</li>
<li><p><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</p>
</li>
</ul>
<blockquote>
<h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a><strong>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</strong></h4></blockquote>
<p>我们先来认识下 MTU 和 MSS</p>
<p><img src="https://static001.geekbang.org/infoq/60/60111facd139b927c9b5fd15b5155d4e.png"></p>
<ul>
<li><p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</p>
</li>
<li><p><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</p>
</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p>
<p>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</p>
<p>这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p>
<p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p><img src="https://static001.geekbang.org/infoq/1c/1c37d93a459cf2653b115520897b7fdf.png"></p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</p>
<blockquote>
<h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a><strong>什么是 SYN 攻击？如何避免 SYN 攻击？</strong></h4></blockquote>
<p>SYN 攻击</p>
<p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。</p>
<p><img src="https://static001.geekbang.org/infoq/87/876685751a1208f386ac086361e1f6fd.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p>
<p>避免 SYN 攻击方式一</p>
<p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p>
<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li>
</ul>
<pre><code>net.core.netdev_max_backlog</code></pre>
<ul>
<li>SYN_RCVD 状态连接的最大个数：</li>
</ul>
<pre><code>net.ipv4.tcp_max_syn_backlog</code></pre>
<ul>
<li>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：</li>
</ul>
<pre><code>net.ipv4.tcp_abort_on_overflow</code></pre>
<p>避免 SYN 攻击方式二</p>
<p>我们先来看下 Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列是如何工作的？</p>
<p><img src="https://static001.geekbang.org/infoq/ba/bacdd7b578796f34cb86fa25772ecaf2.png"></p>
<p>正常流程：</p>
<ul>
<li><p>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</p>
</li>
<li><p>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</p>
</li>
<li><p>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</p>
</li>
<li><p>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/28/2803287ad2a1a5bc22e99d835ce348fd.png"></p>
<p>应用程序过慢：</p>
<ul>
<li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/94/94428a864b689a21c37bb0bbfc9b4b6f.png"></p>
<p>受到 SYN 攻击：</p>
<ul>
<li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</li>
</ul>
<p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p>
<pre><code>net.ipv4.tcp_syncookies = 1</code></pre>
<p><img src="https://static001.geekbang.org/infoq/78/78efbdc15cbb52b3970c7181912fd24f.png"></p>
<ul>
<li><p>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</p>
</li>
<li><p>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</p>
</li>
<li><p>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。 </p>
</li>
<li><p>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</p>
</li>
</ul>
<hr>
<h3 id="03-TCP-连接断开"><a href="#03-TCP-连接断开" class="headerlink" title="03 TCP 连接断开"></a>03 TCP 连接断开</h3><blockquote>
<h4 id="TCP-四次挥手过程和状态变迁"><a href="#TCP-四次挥手过程和状态变迁" class="headerlink" title="TCP 四次挥手过程和状态变迁"></a><strong>TCP 四次挥手过程和状态变迁</strong></h4></blockquote>
<p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过四次挥手方式。</p>
<p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<p><img src="https://static001.geekbang.org/infoq/20/2085b747725cd09fb01334cd29774b6d.png"></p>
<ul>
<li><p>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FINWAIT1</code> 状态。</p>
</li>
<li><p>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</p>
</li>
<li><p>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</p>
</li>
<li><p>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</p>
</li>
<li><p>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</p>
</li>
<li><p>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</p>
</li>
<li><p>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</p>
</li>
</ul>
<p>你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。</p>
<p>这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。</p>
<blockquote>
<h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a><strong>为什么挥手需要四次？</strong></h4></blockquote>
<p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li><p>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p>
</li>
<li><p>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</p>
</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<blockquote>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a><strong>为什么 TIME_WAIT 等待的时间是 2MSL？</strong></h4></blockquote>
<p><code>MSL</code> 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<p>比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p><code>2MSL</code> 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。</p>
<p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。</p>
<p>其定义在 Linux 内核代码里的名称为 TCPTIMEWAITLEN：</p>
<pre><code>#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT 

                                    state, about 60 seconds  */</code></pre>
<p>如果要修改 TIMEWAIT 的时间长度，只能修改 Linux 内核代码里 TCPTIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<blockquote>
<h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="**为什么需要 TIME_WAIT 状态？ **"></a>**为什么需要 TIME_WAIT 状态？ **</h4></blockquote>
<p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li><p>防止具有相同「四元组」的「旧」数据包被收到；</p>
</li>
<li><p>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</p>
</li>
</ul>
<p>原因一：防止旧连接的数据包</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p><img src="https://static001.geekbang.org/infoq/5e/5e3336e73d8b924381f347d0ebab1b71.png"></p>
<ul>
<li><p>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</p>
</li>
<li><p>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</p>
</li>
</ul>
<p>所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p>
<p>原因二：保证连接正确关闭</p>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p>
<p>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</p>
<p>也就是说，TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p><img src="https://static001.geekbang.org/infoq/6a/6a44dd001ef2ece18297121c90305861.png"></p>
<ul>
<li><p>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</p>
</li>
<li><p>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</p>
</li>
</ul>
<p>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：</p>
<ul>
<li><p>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</p>
</li>
<li><p>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</p>
</li>
</ul>
<p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以保证双方的连接都可以正常的关闭。</p>
<blockquote>
<h4 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a><strong>TIME_WAIT 过多有什么危害？</strong></h4></blockquote>
<p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</p>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li><p>第一是内存资源占用；</p>
</li>
<li><p>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</p>
</li>
</ul>
<p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过如下参数设置指定</p>
<pre><code>net.ipv4.ip_local_port_range</code></pre>
<p>如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</p>
<p>客户端受端口资源限制：</p>
<p>客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p>
<p>服务端受系统资源限制：</p>
<p>由于一个TCP四元组表示TCP连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口 但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量TIMEWAIT时，系统资源被占满时，会导致处理不过来新的连接。</p>
<blockquote>
<h4 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a><strong>如何优化 TIME_WAIT？</strong></h4></blockquote>
<p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li><p>打开 net.ipv4.tcptwreuse 和 net.ipv4.tcp_timestamps 选项；</p>
</li>
<li><p>net.ipv4.tcpmaxtw_buckets</p>
</li>
<li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p>
</li>
</ul>
<p>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</p>
<p>如下的 Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。</p>
<pre><code>net.ipv4.tcp_tw_reuse = 1</code></pre>
<p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<pre><code>net.ipv4.tcp_timestamps=1（默认即为 1）</code></pre>
<p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p>
<p>由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p>方式二：net.ipv4.tcp_max_tw_buckets</p>
<p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</p>
<p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p>
<p>方式三：程序中使用 SO_LINGER</p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<pre><code>structlingerso_linger;

so_linger.l_onoff = 1;

so_linger.l_linger = 0;

setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));</code></pre>
<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
<p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<blockquote>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="####  如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><strong>####  <strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></strong></h4></blockquote>
<p>TCP 有一个机制是保活机制。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<pre><code>net.ipv4.tcp_keepalive_time=7200

net.ipv4.tcp_keepalive_intvl=75  

net.ipv4.tcp_keepalive_probes=9</code></pre>
<ul>
<li><p>tcpkeepalivetime=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</p>
</li>
<li><p>tcpkeepaliveintvl=75：表示每次检测间隔 75 秒；</p>
</li>
<li><p>tcpkeepaliveprobes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</p>
</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>
<p><img src="https://static001.geekbang.org/infoq/cd/cda8c0d7f9ec4fb4c57b93556a0dc151.png"></p>
<p>这个时间是有点长的，我们也可以根据实际的需求，对以上的保活相关的参数进行设置。</p>
<p>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<p>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</p>
<p>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</p>
<p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</p>
<hr>
<h3 id="03-Socket-编程"><a href="#03-Socket-编程" class="headerlink" title="03 Socket 编程"></a>03 Socket 编程</h3><blockquote>
<h4 id="针对-TCP-应该如何-Socket-编程？"><a href="#针对-TCP-应该如何-Socket-编程？" class="headerlink" title="针对 TCP 应该如何 Socket 编程？"></a><strong>针对 TCP 应该如何 Socket 编程？</strong></h4></blockquote>
<p><img src="https://static001.geekbang.org/infoq/42/421b5b49759b5821c84756b1a1956a3d.png"></p>
<ul>
<li><p>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</p>
</li>
<li><p>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</p>
</li>
<li><p>服务端调用 <code>listen</code>，进行监听；</p>
</li>
<li><p>服务端调用 <code>accept</code>，等待客户端连接；</p>
</li>
<li><p>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</p>
</li>
<li><p>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</p>
</li>
<li><p>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</p>
</li>
<li><p>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</p>
</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<blockquote>
<h4 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a><strong>listen 时候参数 backlog 的意义？</strong></h4></blockquote>
<p>Linux内核中会维护两个队列：</p>
<ul>
<li><p>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</p>
</li>
<li><p>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/2d/2ddfa757dd19bf3216d37ad04e9f6d8e.png"></p>
<pre><code>intlisten(int socketfd, int backlog)</code></pre>
<ul>
<li><p>参数一 socketfd 为 socketfd 文件描述符</p>
</li>
<li><p>参数二 backlog，这参数在历史有一定的变化</p>
</li>
</ul>
<p>在 早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</p>
<p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 backlog 是 accept 队列。</p>
<blockquote>
<h4 id="accept-发送在三次握手的哪一步？"><a href="#accept-发送在三次握手的哪一步？" class="headerlink" title="accept 发送在三次握手的哪一步？"></a><strong>accept 发送在三次握手的哪一步？</strong></h4></blockquote>
<p>我们先看看客户端连接服务端时，发送了什么？</p>
<p><img src="https://static001.geekbang.org/infoq/66/66747eaab2836882c1b4927863c1d6c3.png"></p>
<ul>
<li><p>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 clientisn，客户端进入 SYNCSENT 状态；</p>
</li>
<li><p>服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 clientisn+1，表示对 SYN 包 clientisn 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 serverisn，服务器端进入 SYNCRCVD 状态；</p>
</li>
<li><p>客户端协议栈收到 ACK 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 server_isn+1；</p>
</li>
<li><p>应答包到达服务器端后，服务器端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</p>
</li>
</ul>
<p>从上面的描述过程，我们可以得知客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</p>
<blockquote>
<h4 id="客户端调用-close-了，连接是断开的流程是什么？"><a href="#客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么？"></a><strong>客户端调用 close 了，连接是断开的流程是什么？</strong></h4></blockquote>
<p>我们看看客户端主动调用了 <code>close</code>，会发生什么？</p>
<p><img src="https://static001.geekbang.org/infoq/19/19814f807c7d98bb98ad653c29f1c223.png"></p>
<ul>
<li><p>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FINWAIT1 状态；</p>
</li>
<li><p>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</p>
</li>
<li><p>接着，当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得会发出一个 FIN 包，之后处于 LAST_ACK 状态；</p>
</li>
<li><p>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</p>
</li>
<li><p>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</p>
</li>
<li><p>客户端进过 <code>2MSL</code> 时间之后，也进入 CLOSED 状态；</p>
</li>
</ul>
<hr>
<p>[1] 趣谈网络协议专栏.刘超.极客时间.</p>
<p>[2] 网络编程实战专栏.盛延敏.极客时间.</p>
<p>[3] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社</p>
<p>[4] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社</p>
<p>[5] 图解TCP/IP.竹下隆史.人民邮电出版社</p>
<p>[6] <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc793.html">https://www.rfc-editor.org/rfc/rfc793.html</a></p>
<p>[7] <a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-tcp-three-way-handshake">https://draveness.me/whys-the-design-tcp-three-way-handshake</a></p>
<p>[9] <a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-tcp-time-wait/">https://draveness.me/whys-the-design-tcp-time-wait/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
