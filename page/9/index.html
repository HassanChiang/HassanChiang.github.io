<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.fenxiangz.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="分享之">
<meta property="og:url" content="https://blog.fenxiangz.com/page/9/index.html">
<meta property="og:site_name" content="分享之">
<meta property="og:description" content="Share everything">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hassan">
<meta property="article:tag" content="JAVA,Linux,技术分享,网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.fenxiangz.com/page/9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>分享之</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="分享之" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分享之</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Share everything</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hassan</p>
  <div class="site-description" itemprop="description">Share everything</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">153</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-11-24_%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%EF%BC%88UDP%EF%BC%89%E5%92%8C%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88TCP%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-11-24_%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%EF%BC%88UDP%EF%BC%89%E5%92%8C%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88TCP%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="post-title-link" itemprop="url">面向报文（UDP）和面向字节流（TCP）的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+00:00">2017-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。若太短，会是 IP 太小。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p>
<p>面向字节流的话，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<p>下图是 TCP 和 UDP 协议的一些应用。</p>
<p><img src="./2017-11-24_%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%EF%BC%88UDP%EF%BC%89%E5%92%8C%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88TCP%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/1.png"> </p>
<p>下图是 TCP 和 UDP 协议的比较。<br><img src="./2017-11-24_%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%EF%BC%88UDP%EF%BC%89%E5%92%8C%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88TCP%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/2.png"> </p>
<p>这里再详细说一下面向连接和面向无连接的区别：</p>
<p>面向连接举例：两个人之间通过电话进行通信;<br>面向无连接举例：邮政服务，用户把信函放在邮件中期待邮政处理流程来传递邮政包裹。显然，不可达代表不可靠。<br>从程序实现的角度来看，可以用下图来进行描述。</p>
<p><img src="./2017-11-24_%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%EF%BC%88UDP%EF%BC%89%E5%92%8C%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88TCP%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/3.png"> </p>
<p>从上图也能清晰的看出，TCP 通信需要服务器端侦听 listen、接收客户端连接请求 accept，等待客户端 connect 建立连接后才能进行数据包的收发（recv/send）工作。而 UDP 则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发（recvfrom/sendto）工作。</p>
<p>在前面讲解 UDP 时，提到了 UDP 保留了报文的边界，下面我们来谈谈 TCP 和 UDP 中报文的边界问题。在默认的阻塞模式下，TCP 无边界，UDP 有边界。</p>
<p>对于 TCP 协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于 UDP 协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种 UDP 的通讯模式是有边界的。</p>
<p>TCP 无边界，造成对采用 TCP 协议发送的数据进行接收比较麻烦，在接收的时候易出现粘包，即发送方发送的若干包数据到接收方接收时粘成一包。由于 TCP 是流协议，对于一个 socket 的包，如发送 10AAAAABBBBB 两次，由于网络原因第一次又分成两次发送， 10AAAAAB 和 BBBB，如果接包的时候先读取 10(包长度) 再读入后续数据，当接收得快，发送的慢时，就会出现先接收了 10AAAAAB, 会解释错误 , 再接到 BBBB10AAAAABBBBB，也解释错误的情况。这就是 TCP 的粘包。</p>
<p>在网络传输应用中，通常需要在网络协议之上再自定义一个协议封装一下，简单做法就是在要发送的数据前面再加一个自定义的包头，包头中可以包含数据长度和其它一些信息，接收的时候先收包头，再根据包头中描述的数据长度来接收后面的数据。详细做法是：先接收包头，在包头里指定包体长度来接收。设置包头包尾的检查位（ 比如以 0xAA 开头，0xCC 结束来检查一个包是否完整）。对于 TCP 来说：</p>
<p>1）不存在丢包，错包，所以不会出现数据出错 ；<br>2）如果包头检测错误，即为非法或者请求，直接重置即可。</p>
<p>为了避免粘包现象，可采取以下几种措施。</p>
<p>一、对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>二、对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；<br>三、由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</p>
<p>原文：<a target="_blank" rel="noopener" href="http://blog.csdn.net/ce123/article/details/8976006">http://blog.csdn.net/ce123/article/details/8976006</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-11-25_%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8ECDN%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-11-25_%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8ECDN%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">一张图说明 CDN 网络的原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+00:00">2017-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C-%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">网络/其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="./2017-11-25_%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8ECDN%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8E%9F%E7%90%86/1.png"> </p>
<p>CDN用户访问流程图</p>
<ol>
<li><p>用户向浏览器输入 <a target="_blank" rel="noopener" href="http://www.web.com/">www.web.com</a> 这个域名，浏览器第一次发现本地没有 dns 缓存，则向网站的 DNS 服务器请求；</p>
</li>
<li><p>网站的 DNS 域名解析器设置了 CNAME，指向了 <a target="_blank" rel="noopener" href="http://www.web.51cdn.com/">www.web.51cdn.com</a>, 请求指向了 CDN 网络中的智能 DNS 负载均衡系统；</p>
</li>
<li><p>智能 DNS 负载均衡系统解析域名，把对用户响应速度最快的 IP 节点返回给用户；</p>
</li>
<li><p>用户向该 IP 节点（CDN 服务器）发出请求；</p>
</li>
<li><p>由于是第一次访问，CDN 服务器会向原 web 站点请求，并缓存内容；</p>
</li>
<li><p>请求结果发给用户。</p>
</li>
</ol>
<p>CDN 网络是在用户和服务器之间增加 Cache 层，如何将用户的请求引导到 Cache 上获得源服务器的数据，主要是通过接管 DNS 实现，这就是 CDN 的最基本的原理，当然很多细节没有涉及到，比如第 1 步，首先向本地的 DNS 服务器请求。第 5 步，内容淘汰机制（根据 TTL）等。但原理大体如此。</p>
<p>当用户访问加入 CDN 服务的网站时，域名解析请求将最终交给全局负载均衡 DNS 进行处理。全局负载均衡 DNS 通过一组预先定义好的策略，将当时最接近用 户的节点地址提供给用户，使用户能够得到快速的服务。同时，它还与分布在世界各地的所有 CDNC 节点保持通信，搜集各节点的通信状态，确保不将用户的请求 分配到不可用的 CDN 节点上，实际上是通过 DNS 做全局负载均衡。</p>
<p>对于普通的 Internet 用户来讲，每个 CDN 节点就相当于一个放置在它周围的 WEB。通过全局负载均衡 DNS 的控制，用户的请求被透明地指向离他最近的节点，节点中 CDN 服务器会像网站的原始服务器一样，响应用户的请求。由于它离用户更近，因而响应时间必然更快。</p>
<p>每个 CDN 节点由两部分组成: 负载均衡设备和高速缓存服务器</p>
<p>负载均衡设备负责每个节点中各个 Cache 的负载均衡，保证节点的工作效率; 同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载 DNS 的通信，实现整个系统的负载均衡。CDN 的管理系统是整个系统能够正常运转的保证。它不仅能对系统中的各个子系统和设备进行实时监控，对各种故障产生相应的告警，还可以实时监测到系统中 总的流量和各节点的流量，并保存在系统的数据库中，使网管人员能够方便地进行进一步分析。通过完善的网管系统，用户可以对系统配置进行修改。</p>
<p>理论上，最简单的 CDN 网络有一个负责全局负载均衡的 DNS 和各节点一台 Cache，即可运行。DNS 支持根据用户源 IP 地址解析不同的 IP，实现 就近访问。为了保证高可用性等，需要监视各节点的流量、健康状况等。一个节点的单台 Cache 承载数量不够时，才需要多台 Cache，多台 Cache 同时 工作，才需要负载均衡器，使 Cache 群协同工作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-11-26_%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Socket%E5%AE%9E%E7%8E%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-11-26_%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Socket%E5%AE%9E%E7%8E%B0.html" class="post-title-link" itemprop="url">深入剖析 Socket 实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+00:00">2017-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在我们平时的开发中用到的最多的是 HTTP 协议，而 HTTP 协议本身是一种应用层协议，属于文本协议；并且这种协议也基本上满足了应用的大部分需求。HTTP 协议当初的设计并没有想到它应用的是如此的广泛，所以设计的时候考虑的比较简单实用，也许也就是这种简单实用才这么广泛；但如今，HTTP 协议似乎并不能满足所有的需求，特别是当今的 web2.0 时代，浏览器应用横行的年代，也越来越多需要长连接的应用，所以在 HTML5 以及 Flash 等客户端应用中都加入了长连接的定义，并且我也相信在未来的互联网开发中会出现很多的长连接应用。在我们公司也曾经自己开发过长连接的应用，前端是基于 flash 的，后端是基于 Java 的实现，自己基于 TCP/IP 协议制定了一套稳定，安全，可靠的应用层协议，至今一直在线上运行，情况也比较稳定；在此，我想基于我的知识和对于 socket 的理解在这里做一次分享，也许不是很深入和透彻，但绝对很基础。</p>
<p>其实如果不理解套接字的具体实现所关联的数据结构和底层协议的工作细节，就很难抓住网络编程的精妙之处，对于 TCP 套接字（即 Socket 的实例）来说更是如此。这里我就对创建和使用 Socket 和 ServerSocket 实例的底层细节进行介绍。请注意，这些内容仅仅涵盖了一些普通的事件实例，略去了很多细节。尽管如此，我相信即使是这样的基础的理解也是有用的。如果希望了解更详尽的内容，可以参考 TCP 规范，或关于该方面的其他著作（例如 TCP/IP 详解）。</p>
<p>图 1 是一个 Socket 实例所关联的一些信息的简化视图。JVM 或其运行的平台（即，主机操作系统中的 “套接字层”）为这些类的支持提供了底层实现。Java 对象上的操作则转换成了这种底层抽象上的操作。在这里，“Socket” 指的是图 1 中的类之一，而 “套接字（socket）” 指的是底层抽象，这种抽象是有操作系统提供或由 JVM 自己实现（例如在嵌入式系统中）。有一点需要注意，即运行在统一主机上的其他程序可能也会通过底层套接字抽象来使用网络，因此会与 Java Socket 实例竞争系统资源，如端口等。</p>
<p><img src="./2017-11-26_%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Socket%E5%AE%9E%E7%8E%B0/1.png"></p>
<p>在此，“套接字结构” 是指底层实现（包括 JVM 和 TCP/IP，但通常是后者）的数据结构集，这些数据结构包括了特定 Socket 实例所关联的信息。例如，套接字结构除其他信息外还包括：</p>
<ul>
<li> 该套接字所关联的本地和远程互联网地址和端口号。本地互联网地址（图中标记为 “Local IP”）是赋值给本地主机的；本地端口号在 Socket 实例创建时设置的。远程地址和端口号标记了与本地套接字连接的远程套接字（如果没有连接的话）。不久，我们将对这些值确定的时间和方式做进一步介绍。</li>
</ul>
<ul>
<li>一个 FIFO（先进先出，First In First Out）队列用于存放接收到的等待分配的数据，以及一个用于存放等待传输的数据的队列。</li>
</ul>
<ul>
<li>列表对于 TCP 套接字，还包括了与打开和关闭 TCP 握手相关的额外协议状态信息。图 1 中，状态是 “关闭”；所有套接字的起始状态都是关闭的。</li>
</ul>
<p>一些多用途操作系统为用户提供了获取底层数据结构 “快照” 的工具，netstat 是其中之一，它在 UNIX（Linux）和 Windows 平台上都可用。只要给定适当的选项，netstat 就能显示和图 1 的那些信息：SendQ 和 RecvQ 中的字节数，本地和远程 IP 地址和端口号，以及连接状态等。netstat 的命令行选项有多种，但它输出看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections(server and established)</span><br><span class="line">Proto  Recv-Q  Send-Q  Local Address         Foreign Address       State</span><br><span class="line">tcp    0       0       0.0.0.0:36045           0.0.0.0:*            LISTEN</span><br><span class="line">tcp    0       0       0.0.0.0:111             0.0.0.0:*            LISTEN</span><br><span class="line">tcp    0       0       0.0.0.0:53363           0.0.0.0:*            LISTEN</span><br><span class="line">tcp    0       0       127.0.0.1:25            0.0.0.0:*            LISTEN</span><br><span class="line">tcp    0       0       128.133.190.219:34077   4.71.104.187:80      TIME_WAIT</span><br><span class="line">tcp    0       0       128.133.190.219:43346   79.62.132.8:22       ESTABLISHED</span><br><span class="line">tcp    0       0       128.133.190.219:875     128.133.190.43:2409  ESTABLISHED</span><br><span class="line">tcp6   0       0       :::22                   :::*                 LISTEN</span><br></pre></td></tr></table></figure>
<p>前 4 行和最后一行描述了正在侦听连接的服务器套接字。</p>
<p>第 5 行代表了到一个 Web 服务器（80 端口）的连接，该服务器已经单方面关闭。</p>
<p>倒数第 2 行是现有的 TCP 连接。</p>
<p>如果系统支持的话，你可能想要尝试一下 netstat，来检测下上文描述的场景的连接状态。然而要知道，这些图中描述的状态转换过程转瞬即逝，可能很难通过 netstat 提供的 “快照” 功能将其捕获。</p>
<p>了解这些数据结构，以及底层协议如何对其进行影响是非常有用的，因为它们控制了各种 Socket 对象行为的各个方面。例如，由于 TCP 提供了一种可信赖的字节流服务，任何写入 Socket 的 OutputStream 的数据副本都必须保留，直到其在连接的另一端被成功接收。向输出流写数据并不意味着数据实际上已经被发送，他们只是被复制到了本地缓冲区。就算在 Socket 的 OutputStream 上进行 flush 操作，也不能保证数据能够立即发送到信道。此外，字节流服务的自身属性决定了其无法保留输入流中消息的边界信息，这里的边界信息的意思就是上一个数据包和下一个数据包之间的区别信息。这使一些协议的接收和解析过程变得复杂。另一方面，对于 DatagramSocket，数据包并没有为重传而进行缓存，任何时候调用 send() 方法返回后，数据就已经发送给了执行传输任务的网络子系统。如果网络子系统由于某种原因无法处理这些消息，该数据包将毫无提示地被丢弃（不过这种情况很少发生）。</p>
<h3 id="缓冲区和-TCP"><a href="#缓冲区和-TCP" class="headerlink" title="缓冲区和 TCP"></a>缓冲区和 TCP</h3><p> 作为程序员，在使用 TCP 套接字时需要记住的最重要一点是：</p>
<blockquote>
<p>不能假设在连接的一端将数据写入输出流和在另一端从输入流读取数据之间有任何一致性。</p>
</blockquote>
<p>尤其是在发送端由单个输出流的 write() 方法传输的数据，可能会通过另一端的多个输入流的 read() 方法来获取；而一个 read() 方法可能会返回多个 write() 方法传输的数据。</p>
<p>为了展示这种情况，考虑如下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte[] buf0 &#x3D; new byte[1000];</span><br><span class="line">byte[] buf1 &#x3D; new byte[2000];</span><br><span class="line">byte[] buf2 &#x3D; new byte[5000];</span><br><span class="line">…</span><br><span class="line">Socket s &#x3D; new Socket(destAddr, destPort);</span><br><span class="line">OutputStream out &#x3D; s.getOutputStream();</span><br><span class="line">…</span><br><span class="line">out.write(buf0);</span><br><span class="line">…</span><br><span class="line">out.write(buf1);</span><br><span class="line">…</span><br><span class="line">out.write(buf2);</span><br><span class="line">…</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>
<p>其中，圆点代表了设置缓冲区数据的代码，但不包括对 out.write() 方法的调用。在本节的讨论中，“in” 代表接收端 Socket 的 InputStream，“out” 代表发送端 Socket 的 OutputStream。</p>
<p>这个 TCP 连接想接收端传输 8000 字节。在连接的接收端，这 8000 字节的分组方式取决于连接两端 out.write() 方法和 in.read() 方法的调用时间差，以及提供给 in.read() 方法的缓冲区大小。</p>
<p>我们可以认为 TCP 连接上发送的所有字节序列在某一瞬间被分成了 3 个 FIFO 队列；</p>
<ul>
<li>列表 SendQ：在发送端底层实现中缓存的字节，这些字节已经写入了输出流，但还没在接收端主机上成功接收。</li>
</ul>
<ul>
<li>列表 RecvQ：在接收端底层实现中缓存的字节，等待分配到接收程序，即从输入流中读取。</li>
</ul>
<ul>
<li> 列表 Delivered：接收者从输入流已经读取到的字节。</li>
</ul>
<p>调用 out.write() 方法将向 SendQ 追加字节。TCP 协议负责将字节按顺序从 SendQ 移动到 RecvQ。有重要的一点需要明确，这个转移过程无法由用户程序控制或直接观察到，并且在块中（chunk）发生，这些块的大小在一定程度上独立于传递给 write() 方法的缓冲区大小。</p>
<p>接收程序从 Socket 的 InputStream 读取数据时，字节就从 RecvQ 移动到 Delivered 中，而转移的块的大小依赖于 RecvQ 中的数据量和传递给 read() 方法缓冲区大小。</p>
<p><img src="./2017-11-26_%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Socket%E5%AE%9E%E7%8E%B0/2.png"><br>-&gt;图 2   3 次调用 write() 方法后 3 个队列的状态&lt;-</p>
<p>图 2 展示了上例中 3 次调用 out.write() 方法后，另一端调用 in.read() 方法前，以上 3 个队列的可能状态。不同的阴影效果分别代表了上文中 3 次调用 write() 方法传输的不同数据。</p>
<p>图 2 描述的发送端主机的 netstat 输出的瞬间状态中，会包含类似于下一行的内容：</p>
<p>在接收端主机，netstat 会显示：</p>
<p>现在假设接收者调用 read() 方法时使用的缓冲区数组大小为 2000 字节，read() 调用则将把等待分配队列 (RecvQ) 中的 1500 字节全部移动到数组中，返回值为 1500。注意，这些数据包括了第一次和第二次调用 write() 方法时传输的字节。在过一段时间，但 TCP 连接传完更多数据后，这三部分的状态可能如图 3 所示。</p>
<p><img src="./2017-11-26_%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Socket%E5%AE%9E%E7%8E%B0/3.png"><br>-&gt;图 3  第一次调用 read() 方法后&lt;-</p>
<p>如果接收者现在调用 read() 方法时使用 4000 字节的缓冲区数组，将有很多字节从等待分配队列（RecvQ）转移到已分配队列（Delivered）中。这包括第二次调用 write() 方法时剩下的 1500 字节加上第三次调用 write() 的前 2500 字节。此时队列的状态如图 4 所示。</p>
<p><img src="./2017-11-26_%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Socket%E5%AE%9E%E7%8E%B0/4.png"><br>-&gt;图 4  另一次调用 read() 后&lt;-</p>
<p>下次调用 read() 方法返回的字节数，取决于缓冲区数组的大小，以及发送方套接字 /TCP 实现通过网络向接收方实现传输数据的时机。数据从 SendQ 到 RecvQ 缓冲区的移动过程对应用程序协议的设计有重要的指导性。我们已经遇到过需要对使用带内（in-band）分隔符，并通过 Socket 来接收的消息进行解析的情况。</p>
<p>source: <a target="_blank" rel="noopener" href="http://blog.csdn.net/zapldy/article/details/5813984">http://blog.csdn.net/zapldy/article/details/5813984</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-11-27_%E6%90%AC%E7%93%A6%E5%B7%A5VPN%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-11-27_%E6%90%AC%E7%93%A6%E5%B7%A5VPN%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC.html" class="post-title-link" itemprop="url">搬瓦工 VPN 安装脚本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+00:00">2017-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C-%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">网络/其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">function installVPN()&#123;</span><br><span class="line">        echo &quot;begin to install VPN services&quot;;</span><br><span class="line">        #check wether vps suppot ppp and tun</span><br><span class="line"></span><br><span class="line">        yum remove -y pptpd ppp</span><br><span class="line">        iptables --flush POSTROUTING --table nat</span><br><span class="line">        iptables --flush FORWARD</span><br><span class="line">        rm -rf &#x2F;etc&#x2F;pptpd.conf</span><br><span class="line">        rm -rf &#x2F;etc&#x2F;ppp</span><br><span class="line"></span><br><span class="line">        arch&#x3D;&#96;uname -m&#96;</span><br><span class="line"></span><br><span class="line">        wget http:&#x2F;&#x2F;www.hi-vps.com&#x2F;downloads&#x2F;dkms-2.0.17.5-1.noarch.rpm</span><br><span class="line">        wget http:&#x2F;&#x2F;wty.name&#x2F;linux&#x2F;sources&#x2F;kernel_ppp_mppe-1.0.2-3dkms.noarch.rpm</span><br><span class="line">        wget http:&#x2F;&#x2F;www.hi-vps.com&#x2F;downloads&#x2F;kernel_ppp_mppe-1.0.2-3dkms.noarch.rpm</span><br><span class="line">        wget http:&#x2F;&#x2F;www.hi-vps.com&#x2F;downloads&#x2F;pptpd-1.3.4-2.el6.$arch.rpm</span><br><span class="line">        wget http:&#x2F;&#x2F;www.hi-vps.com&#x2F;downloads&#x2F;ppp-2.4.5-17.0.rhel6.$arch.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        yum -y install make libpcap iptables gcc-c++ logrotate tar cpio perl pam tcp_wrappers</span><br><span class="line">        rpm -ivh dkms-2.0.17.5-1.noarch.rpm</span><br><span class="line">        rpm -ivh kernel_ppp_mppe-1.0.2-3dkms.noarch.rpm</span><br><span class="line">        rpm -qa kernel_ppp_mppe</span><br><span class="line">        rpm -Uvh ppp-2.4.5-17.0.rhel6.$arch.rpm</span><br><span class="line">        rpm -ivh pptpd-1.3.4-2.el6.$arch.rpm</span><br><span class="line"></span><br><span class="line">        mknod &#x2F;dev&#x2F;ppp c 108 0 </span><br><span class="line">        echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward </span><br><span class="line">        echo &quot;mknod &#x2F;dev&#x2F;ppp c 108 0&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local</span><br><span class="line">        echo &quot;echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local</span><br><span class="line">        echo &quot;localip 172.16.36.1&quot; &gt;&gt; &#x2F;etc&#x2F;pptpd.conf</span><br><span class="line">        echo &quot;remoteip 172.16.36.2-254&quot; &gt;&gt; &#x2F;etc&#x2F;pptpd.conf</span><br><span class="line">        echo &quot;ms-dns 8.8.8.8&quot; &gt;&gt; &#x2F;etc&#x2F;ppp&#x2F;options.pptpd</span><br><span class="line">        echo &quot;ms-dns 8.8.4.4&quot; &gt;&gt; &#x2F;etc&#x2F;ppp&#x2F;options.pptpd</span><br><span class="line"></span><br><span class="line">        pass&#x3D;&#96;openssl rand 6 -base64&#96;</span><br><span class="line">        if [ &quot;$1&quot; !&#x3D; &quot;&quot; ]</span><br><span class="line">        then pass&#x3D;$1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        echo &quot;vpn pptpd $&#123;pass&#125; *&quot; &gt;&gt; &#x2F;etc&#x2F;ppp&#x2F;chap-secrets</span><br><span class="line"></span><br><span class="line">        iptables -t nat -A POSTROUTING -s 172.16.36.0&#x2F;24 -j SNAT --to-source &#96;ifconfig  | grep &#39;inet addr:&#39;| grep -v &#39;127.0.0.1&#39; | cut -d: -f2 | awk &#39;NR&#x3D;&#x3D;1 &#123; print $1&#125;&#39;&#96;</span><br><span class="line">        iptables -A FORWARD -p tcp --syn -s 172.16.36.0&#x2F;24 -j TCPMSS --set-mss 1356</span><br><span class="line">        service iptables save</span><br><span class="line"></span><br><span class="line">        chkconfig iptables on</span><br><span class="line">        chkconfig pptpd on</span><br><span class="line"></span><br><span class="line">        service iptables start</span><br><span class="line">        service pptpd start</span><br><span class="line"></span><br><span class="line">        echo &quot;VPN service is installed, your VPN username is vpn, VPN password is $&#123;pass&#125;&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function repaireVPN()&#123;</span><br><span class="line">        echo &quot;begin to repaire VPN&quot;;</span><br><span class="line">        mknod &#x2F;dev&#x2F;ppp c 108 0</span><br><span class="line">        service iptables restart</span><br><span class="line">        service pptpd start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addVPNuser()&#123;</span><br><span class="line">        echo &quot;input user name:&quot;</span><br><span class="line">        read username</span><br><span class="line">        echo &quot;input password:&quot;</span><br><span class="line">        read userpassword</span><br><span class="line">        echo &quot;$&#123;username&#125; pptpd $&#123;userpassword&#125; *&quot; &gt;&gt; &#x2F;etc&#x2F;ppp&#x2F;chap-secrets</span><br><span class="line">        service iptables restart</span><br><span class="line">        service pptpd start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;which do you want to?input the number.&quot;</span><br><span class="line">echo &quot;1. install VPN service&quot;</span><br><span class="line">echo &quot;2. repaire VPN service&quot;</span><br><span class="line">echo &quot;3. add VPN user&quot;</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">case &quot;$num&quot; in</span><br><span class="line">[1] ) (installVPN);;</span><br><span class="line">[2] ) (repaireVPN);;</span><br><span class="line">[3] ) (addVPNuser);;</span><br><span class="line">*) echo &quot;nothing,exit&quot;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/network/2017-11-28_HeidiSQL%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E9%93%BE%E6%8E%A5mysql.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/network/2017-11-28_HeidiSQL%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E9%93%BE%E6%8E%A5mysql.html" class="post-title-link" itemprop="url">Heidi SQL 通过 SSH 隧道链接 MySQL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+00:00">2017-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C-%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">网络/其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Heidi SQL 通过 SSH 隧道链接mysql，适用于 mysql 数据库本地机器不可达，只能通过 SSH 隧道的情况。</p>
<p>步骤：</p>
<p><strong>1. 选：</strong></p>
<p><img src="./2017-11-28_HeidiSQL%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E9%93%BE%E6%8E%A5mysql/1.png"></p>
<p><strong>2. 下载 plink，选择安装路径：</strong></p>
<p><img src="./2017-11-28_HeidiSQL%E9%80%9A%E8%BF%87SSH%E9%9A%A7%E9%81%93%E9%93%BE%E6%8E%A5mysql/2.png"></p>
<p><strong>3. 正常配置数据库链接信息即可</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/docker/2017-11-25_Docker_Get_Started.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/docker/2017-11-25_Docker_Get_Started.html" class="post-title-link" itemprop="url">Docker Get Started</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-25 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-25T00:00:00+00:00">2017-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>环境</strong></p>
<p>Vmware11 安装 Centos 7 系统，版本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -s -r </span><br><span class="line">Linux 3.10.0-229.el7.x86_64</span><br></pre></td></tr></table></figure>
<p><strong>安装</strong></p>
<p>1.使用 root 账户或具有 root 权限的用户登录。</p>
<p>2.更新安装包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>
<p>3.给 yum 添加 docker repository。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">[dockerrepo]</span><br><span class="line">name&#x3D;Docker Repository</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;repo&#x2F;main&#x2F;centos&#x2F;$releasever&#x2F;</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>4.安装 docker 引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-engine</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>启动 docker 守护进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure></li>
<li>验证 docker 安装和启动是否正确<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">    latest: Pulling from hello-world</span><br><span class="line">    a8219747be10: Pull complete</span><br><span class="line">    91c95931e552: Already exists</span><br><span class="line">    hello-world:latest: The image you are pulling has been verified. Important: image verification is a tech preview feature and should not be relied on to provide security.</span><br><span class="line">    Digest: sha256:aa03e5d0d5553b4c3473e89c8619cf79df368babd1.7.1cf5daeb82aab55838d</span><br><span class="line">    Status: Downloaded newer image for hello-world:latest</span><br><span class="line">    Hello from Docker.</span><br><span class="line">    This message shows that your installation appears to be working correctly.</span><br><span class="line">    To generate this message, Docker took the following steps:</span><br><span class="line">     1. The Docker client contacted the Docker daemon.</span><br><span class="line">     2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">            (Assuming it was not already locally available.)</span><br><span class="line">     3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">            executable that produces the output you are currently reading.</span><br><span class="line">     4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">            to your terminal.</span><br><span class="line">    To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">     $ docker run -it ubuntu bash</span><br><span class="line">    For more examples and ideas, visit:</span><br><span class="line">     http:&#x2F;&#x2F;docs.docker.com&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure>
ok，看见以上信息，就说明 docker 已经正确安装并启动。</li>
</ol>
<p>在系统里创建一个 docker 用户组</p>
<p>从 0.5.2 开始 docker 的守护进程总是以 root 用户来运行。docker 守护进程绑定的是 Unix 的 socket 而不是一个 TCP 端口。Unix 的 socket 默认属于 root 用户，所以，使用 docker 时必须加上 sudo。</p>
<p>从 0.5.3 开始，创建一个名为 docker 组，然后将用户加入这个组内。当 docker 守护进程启动时，它会把 Unix 的读写权限赋予 docker 组。这样，当你作为 docker 组内用户使用 docker 客户端时，你就无须使用 sudo 了。</p>
<p>需要注意的是，docker 用户组是等价于 root 用户的，进一步了 docker 用户组对系统安全的影响，可以看看这个：走你。</p>
<p>执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure>
<p>执行完后，退出 shell，再重新登录，以确保用户获得正确的运行权限。</p>
<p>重新登录系统后，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>执行结果应该同 “安装” 部分第六步的执行结果一样。</p>
<p>设置 docker 守护进程开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chkconfig docker on</span><br></pre></td></tr></table></figure>
<p>运行一下官方教程提供的镜像</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ docker run docker&#x2F;whalesay cowsay boo</span><br><span class="line">Unable to find image &#39;docker&#x2F;whalesay:latest&#39; locally</span><br><span class="line">latest: Pulling from docker&#x2F;whalesay</span><br><span class="line">e9e06b06e14c: Pull complete</span><br><span class="line">a82efea989f9: Pull complete</span><br><span class="line">37bea4ee0c81: Pull complete</span><br><span class="line">07f8e8c5e660: Pull complete</span><br><span class="line">676c4a1897e6: Pull complete</span><br><span class="line">5b74edbcaa5b: Pull complete</span><br><span class="line">1722f41ddcb5: Pull complete</span><br><span class="line">99da72cfe067: Pull complete</span><br><span class="line">5d5bd9951e26: Pull complete</span><br><span class="line">fb434121fc77: Already exists</span><br><span class="line">Digest: sha256:d6ee73f978a366cf97974115abe9c4099ed59c6f75c23d03c64446bb9cd49163</span><br><span class="line">Status: Downloaded newer image for docker&#x2F;whalesay:latest</span><br><span class="line"> _____</span><br><span class="line">&lt; boo &gt;</span><br><span class="line"> -----</span><br><span class="line">    \</span><br><span class="line">     \</span><br><span class="line">      \</span><br><span class="line">                    ##        .</span><br><span class="line">              ## ## ##       &#x3D;&#x3D;</span><br><span class="line">           ## ## ## ##      &#x3D;&#x3D;&#x3D;</span><br><span class="line">       &#x2F;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;___&#x2F; &#x3D;&#x3D;&#x3D;</span><br><span class="line">  ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ &#x2F;  &#x3D;&#x3D;&#x3D;- ~~~</span><br><span class="line">       \______ o          __&#x2F;</span><br><span class="line">        \    \        __&#x2F;</span><br><span class="line">          \____\______&#x2F;</span><br></pre></td></tr></table></figure>
<p>第一次执行的时候，会从 Docker Hub 上下载该镜像。镜像还挺大的，有 247MB，如果网速不快的，需要耐心等待。</p>
<p>Docker 的镜像（images）和容器（containers）</p>
<p>首先，看一下下面这个图例:</p>
<p>执行以上命令，docker 引擎会做这几件事：</p>
<ol>
<li>检查本地是否有 hello-world 镜像</li>
<li>如果没有则从 Docker Hub 下载该镜像，如果有，则使用本地镜像</li>
<li>把 hello-world 镜像加载到容器里，并执行。</li>
</ol>
<p>Docker 镜像可以是一个简单的命令行，执行完后就退出了。也可以是一个复杂的程序集合，比如一个数据库，启动后，可以进行复杂的数据库操作。</p>
<p>Docker 的镜像是只读的，可以理解为是一个软件。Docker 镜像通过镜像 ID 进行识别。镜像 ID 是一个 64 字符的十六进制的字符串。通常我们不会使用镜像 ID 来引用镜像，而是使用镜像名来引用。</p>
<p>查看本地镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker-whale            latest              03643993f0ca        7 minutes ago       255.6 MB</span><br><span class="line">hello-world             latest              690ed74de00f        4 months ago        960 B</span><br><span class="line">docker&#x2F;whalesay         latest              6b362a9f73eb        8 months ago        247 MB</span><br></pre></td></tr></table></figure>
<p>这里的 Image ID 只有前 12 个字符，想要显示全部，需要添加选项：–no-trunc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --no-trunc</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID                                                                  CREATED             SIZE</span><br><span class="line">docker-whale            latest              sha256:03643993f0cacd07968d99265815543a0f2d296e4fc434253b2b4ac2e2c84aae   About an hour ago   255.6 MB</span><br><span class="line">hello-world             latest              sha256:690ed74de00f99a7d00a98a5ad855ac4febd66412be132438f9b8dbd300a937d   4 months ago        960 B</span><br><span class="line">docker&#x2F;whalesay         latest              sha256:6b362a9f73eb8c33b48c95f4fcce1b6637fc25646728cf7fb0679b2da273c3f4   8 months ago        247 MB</span><br></pre></td></tr></table></figure>

<p>容器就是运行镜像的地方。当执行 docker run 的时候，就会启动一个容器，而 docker run hello-world 便会把 hello-world 这个程序加载到这个容器里面运行。每个容器相互独立，我们可以使用同一个镜像启动多个容器（多个虚拟环境），我们对其中一个容器所做的变更只会局限于那个容器本身，对容器的变更是写入到容器的文件系统的，而不是写入到 Docker 镜像中的。</p>
<p>容器之间可以通过暴露端口进行通信，这个在以后学习中再说。</p>
<p>Docker 使用 64 字符的十六进制的字符串来定义容器 ID，它是容器的唯一标识符。容器之间的交互是依靠容器 ID 识别的，由于容器 ID 的字符太长，我们通常只需键入容器 ID 的前 4 个字符即可。当然，我们还可以使用容器名，但显然用 4 字符的容器 ID 更为简便。</p>
<p>查看当前运行的容器可以使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">a45a2d3b95e7        sample-spring-boot-app   &quot;&#x2F;bin&#x2F;sh -c &#39;java -DC&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8080-&gt;8080&#x2F;tcp    silly_morse</span><br><span class="line">0b2494881e6c        sample-spring-boot-app   &quot;&#x2F;bin&#x2F;sh -c &#39;java -DC&quot;   3 minutes ago       Up 3 minutes        0.0.0.0:32771-&gt;8080&#x2F;tcp   compassionate_austin</span><br></pre></td></tr></table></figure>

<p>简单的理解，可以把 “镜像 - 容器” 理解为 “类 - 实例”。容器是一个实例，这个实例是根据镜像创建的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/linux/2017-11-27_update-alternatives_%E5%91%BD%E4%BB%A4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux/2017-11-27_update-alternatives_%E5%91%BD%E4%BB%A4.html" class="post-title-link" itemprop="url">update-alternatives 命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-25 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-25T00:00:00+00:00">2017-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>update-alternatives 是符号链接管理工具。用于分组管理命令的链接和优先级。</p>
<p>update-alternatives 以链接组进行管理，每一个链接组（link group）都有两种不同的模式：自动模式和手动模式，任一给定时刻一个组都是而且只能是其中的一种模式。</p>
<p>如果一个组处于自动模式，当包被安装或删除时，备选方案系统会自己决定是否和如何来更新相应链接（links）。</p>
<p>如果处于手动模式，备选方案系统会保留原先管理员所做的选择并且避免改变链接（除非发生 broken）。</p>
<p>当第一次被安装到系统时链接组被分配为自动模式；如果之后系统管理员对模式的设置做出更改，这个组会被自动转换为手动模式。</p>
<p>–display name</p>
<p>显示链接组的信息。信息包括链接组的模式（自动或手动）；链接的指针（链到了那一个文件）；优先级是多少；当前最优版本等。</p>
<p>–install link name path priority [–slave slink sname spath] …</p>
<p>其中 link 为系统中功能相同软件的公共链接目录，比如 / usr/bin/java(需绝对目录)；</p>
<p>name 为命令链接符名称，如 java；</p>
<p>path 为你所要使用新命令、新软件的所在目录；</p>
<p>priority 为优先级，当命令链接已存在时，需高于当前值，因为当 alternative 为自动模式时, 系统默认启用 priority 高的链接;</p>
<p>–slave 为从 alternative。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;java java &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk8&#x2F;bin&#x2F;java 300</span><br></pre></td></tr></table></figure>
<p>install 默认都为 auto 模式，因为大多数情况下 update-alternatives 命令都被 postinst (configure) or prerm (install) 调用的，如果将其更改成手动的话安装脚本将不会更新它了。</p>
<p>–config name</p>
<p>当使用 –config 选项时，update-alternatives 会列出所有链接组的主链接名，当前被选择的组会以 * 号标出。可以在提示下对链接指向做出改变，不过这会将模式变为手动。如果想恢复自动模式，你可以使用 –auto 选项，或者 –config 重新选择标为自动的组。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-alternatives --config editor</span><br><span class="line">There are 4 choices for the alternative editor (providing &#x2F;usr&#x2F;bin&#x2F;editor).</span><br><span class="line">  Selection    Path                Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            &#x2F;bin&#x2F;nano            40        auto mode</span><br><span class="line">  1            &#x2F;bin&#x2F;ed             -100       manual mode</span><br><span class="line">  2            &#x2F;bin&#x2F;nano            40        manual mode</span><br><span class="line">  3            &#x2F;usr&#x2F;bin&#x2F;vim.basic   30        manual mode</span><br><span class="line">  4            &#x2F;usr&#x2F;bin&#x2F;vim.tiny    10        manual mode</span><br><span class="line">Press enter to keep the current choice[*], or type selection number:</span><br><span class="line">--auto name</span><br></pre></td></tr></table></figure>
<p>重新使 name 链接组为自动模式。</p>
<p>–remove name path</p>
<p>删除 name 链接组里的 path 对应的符号链接</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/java/basic/2017-11-10_java-lambda.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/java/basic/2017-11-10_java-lambda.html" class="post-title-link" itemprop="url">Java8 lambda表达式10个示例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-10 15:51:24" itemprop="dateCreated datePublished" datetime="2017-11-10T15:51:24+00:00">2017-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java 基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java 8 刚于几周前发布，日期是2014年3月18日，这次开创性的发布在Java社区引发了不少讨论，并让大家感到激动。特性之一便是随同发布的lambda表达式，它将允许我们将行为传到函数里。在Java 8之前，如果想将行为传入函数，仅有的选择就是匿名类，需要6行代码。而定义行为最重要的那行代码，却混在中间不够突出。Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码。这样有时可读性更好，表达更清晰。在Java生态系统中，函数式表达与对面向对象的全面支持是个激动人心的进步。将进一步促进并行第三方库的发展，充分利用多核CPU。尽管业界需要时间来消化Java 8，但我认为任何严谨的Java开发者都不应忽视此次Java发布的核心特性，即lambda表达式、函数式接口、流API、默认方法和新的Date以及Time API。作为开发人员，我发现学习和掌握lambda表达式的最佳方法就是勇于尝试，尽可能多练习lambda表达式例子。鉴于受Java 8发布的影响最大的是Java集合框架（Java Collections framework），所以最好练习流API和lambda表达式，用于对列表（Lists）和集合（Collections）数据进行提取、过滤和排序。我一直在进行关于Java 8的写作，过去也曾分享过一些资源来帮助大家<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.jp/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html">掌握Java 8</a>。本文分享在代码中最有用的10个lambda表达式的使用方法，这些例子都短小精悍，将帮助你快速学会lambda表达式。</p>
<h2 id="Java-8-lambda表达式示例"><a href="#Java-8-lambda表达式示例" class="headerlink" title="Java 8 lambda表达式示例"></a>Java 8 lambda表达式示例</h2><p>我个人对Java 8发布非常激动，尤其是lambda表达式和流API。越来越多的了解它们，我能写出更干净的代码。虽然一开始并不是这样。第一次看到用lambda表达式写出来的Java代码时，我对这种神秘的语法感到非常失望，认为它们把Java搞得不可读，但我错了。花了一天时间做了一些lambda表达式和流API示例的练习后，我开心的看到了更清晰的Java代码。这有点像学习<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2011/09/generics-java-example-tutorial.html">泛型</a>，第一次见的时候我很讨厌它。我甚至继续使用老版Java 1.4来处理集合，直到有一天，朋友跟我介绍了使用泛型的好处（才意识到它的好处）。所以基本立场就是，不要畏惧lambda表达式以及方法引用的神秘语法，做几次练习，从集合类中提取、过滤数据之后，你就会喜欢上它。下面让我们开启学习Java 8 lambda表达式的学习之旅吧，首先从简单例子开始。</p>
<h3 id="例1、用lambda表达式实现Runnable"><a href="#例1、用lambda表达式实现Runnable" class="headerlink" title="例1、用lambda表达式实现Runnable"></a>例1、用lambda表达式实现Runnable</h3><p>我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -&gt; {}代码块替代了整个<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/12/inner-class-and-nested-static-class-in-java-difference.html">匿名类</a>。</p>
<pre><code>// Java 8之前：
new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
        System.out.println(&quot;Before Java8, too much code for too little to do&quot;);
        &#125;
&#125;).start();


//Java 8方式：
new Thread( () -&gt; System.out.println(&quot;In Java8, Lambda expression rocks !!&quot;) ).start();</code></pre>
<p>输出：</p>
<pre><code>too much code, for too little to do
Lambda expression rocks !!</code></pre>
<p>这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：</p>
<pre><code>(params) -&gt; expression
(params) -&gt; statement
(params) -&gt; &#123; statements &#125;</code></pre>
<p>例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：</p>
<pre><code>() -&gt; System.out.println(&quot;Hello Lambda Expressions&quot;);</code></pre>
<p>如果你的方法接收两个参数，那么可以写成如下这样：</p>
<pre><code>(int even, int odd) -&gt; even + odd</code></pre>
<p>顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。</p>
<h3 id="例2、使用Java-8-lambda表达式进行事件处理"><a href="#例2、使用Java-8-lambda表达式进行事件处理" class="headerlink" title="例2、使用Java 8 lambda表达式进行事件处理"></a>例2、使用Java 8 lambda表达式进行事件处理</h3><p>如果你用过Swing API编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：</p>
<pre><code>// Java 8之前：
JButton show =  new JButton(&quot;Show&quot;);
show.addActionListener(new ActionListener() &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
        System.out.println(&quot;Event handling without lambda expression is boring&quot;);
        &#125;
&#125;);


// Java 8方式：
show.addActionListener((e) -&gt; &#123;
        System.out.println(&quot;Light, Camera, Action !! Lambda expressions Rocks&quot;);
&#125;);</code></pre>
<p>Java开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2014/01/java-comparator-example-for-custom.html">Comparator</a>。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html">Runnable</a> 和 ActionListener 的过程中的套路来做。</p>
<h3 id="例3、使用lambda表达式对列表进行迭代"><a href="#例3、使用lambda表达式对列表进行迭代" class="headerlink" title="例3、使用lambda表达式对列表进行迭代"></a>例3、使用lambda表达式对列表进行迭代</h3><p>如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/03/how-to-loop-arraylist-in-java-code.html">使用</a><a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/03/how-to-loop-arraylist-in-java-code.html">lambda</a>或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个 forEach()  方法，它可以迭代所有对象，并将你的lambda代码应用在其中。</p>
<pre><code>// Java 8之前：
List features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);
for (String feature : features) &#123;
        System.out.println(feature);
&#125;


// Java 8之后：
List features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);
features.forEach(n -&gt; System.out.println(n));

// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，
// 看起来像C++的作用域解析运算符
features.forEach(System.out::println);</code></pre>
<p>输出：</p>
<pre><code>Lambdas
Default Method
Stream API
Date and Time API</code></pre>
<p><a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/10/jstl-foreach-tag-example-in-jsp-looping.html">列表循环</a>的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。你可以看到C++里面的双冒号、范围解析操作符现在在Java 8中用来表示方法引用。</p>
<h3 id="例4、使用lambda表达式和函数式接口Predicate"><a href="#例4、使用lambda表达式和函数式接口Predicate" class="headerlink" title="例4、使用lambda表达式和函数式接口Predicate"></a>例4、使用lambda表达式和函数式接口Predicate</h3><p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。下面是Java 8 Predicate 的例子，展示了过滤集合数据的多种常用方法。Predicate接口非常适用于做过滤。</p>
<pre><code>public static void main(args[])&#123;
        List languages = Arrays.asList(&quot;Java&quot;, &quot;Scala&quot;, &quot;C++&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;);

        System.out.println(&quot;Languages which starts with J :&quot;);
        filter(languages, (str)-&gt;str.startsWith(&quot;J&quot;));

        System.out.println(&quot;Languages which ends with a &quot;);
        filter(languages, (str)-&gt;str.endsWith(&quot;a&quot;));

        System.out.println(&quot;Print all languages :&quot;);
        filter(languages, (str)-&gt;true);

        System.out.println(&quot;Print no language : &quot;);
        filter(languages, (str)-&gt;false);

        System.out.println(&quot;Print language whose length greater than 4:&quot;);
        filter(languages, (str)-&gt;str.length() &gt; 4);
&#125;

public static void filter(List names, Predicate condition) &#123;
        for(String name: names)  &#123;
                if(condition.test(name)) &#123;
                        System.out.println(name + &quot; &quot;);
                &#125;
        &#125;
&#125;</code></pre>
<p>输出：</p>
<pre><code>Languages which starts with J :
Java
Languages which ends with a
Java
Scala
Print all languages :
Java
Scala
C++
Haskell
Lisp
Print no language :
Print language whose length greater than 4:
Scala
Haskell</code></pre>
<p> 更好的办法</p>
<pre><code>public static void filter(List names, Predicate condition) &#123;
        names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; &#123;
                System.out.println(name + &quot; &quot;);
        &#125;);
&#125;</code></pre>
<p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。</p>
<h3 id="例5、如何在lambda表达式中加入Predicate"><a href="#例5、如何在lambda表达式中加入Predicate" class="headerlink" title="例5、如何在lambda表达式中加入Predicate"></a>例5、如何在lambda表达式中加入Predicate</h3><p>上个例子说到，java.util.function.Predicate 允许将两个或更多的 Predicate 合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。例如，要得到所有以J开始，长度为四个字母的语言，可以定义两个独立的 Predicate 示例分别表示每一个条件，然后用 Predicate.and() 方法将它们合并起来，如下所示：</p>
<pre><code>// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，
// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入
Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(&quot;J&quot;);
Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == 4;
names.stream()
        .filter(startsWithJ.and(fourLetterLong))
        .forEach((n) -&gt; System.out.print(&quot;nName, which starts with &#39;J&#39; and four letter long is : &quot; + n));</code></pre>
<p>类似地，也可以使用 or() 和 xor() 方法。本例着重介绍了如下要点：可按需要将 Predicate 作为单独条件然后将其合并起来使用。简而言之，你可以以传统Java命令方式使用 Predicate 接口，也可以充分利用lambda表达式达到事半功倍的效果。</p>
<h3 id="例6、Java-8中使用lambda表达式的Map和Reduce示例"><a href="#例6、Java-8中使用lambda表达式的Map和Reduce示例" class="headerlink" title="例6、Java 8中使用lambda表达式的Map和Reduce示例"></a>例6、Java 8中使用lambda表达式的Map和Reduce示例</h3><p>本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -&gt; x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。使用流API的收集器类，可以得到所有含税的开销。有 toList() 这样的方法将 map 或任何其他操作的结果合并起来。由于收集器在流上做终端操作，因此之后便不能重用流了。你甚至可以用流API的 reduce() 方法将所有数字合成一个，下一个例子将会讲到。</p>
<pre><code>// 不使用lambda表达式为每个订单加上12%的税
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
for (Integer cost : costBeforeTax) &#123;
        double price = cost + .12*cost;
        System.out.println(price);
&#125;

// 使用lambda表达式
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).forEach(System.out::println);</code></pre>
<p>输出：</p>
<pre><code>112.0
224.0
336.0
448.0
560.0
112.0
224.0
336.0
448.0
560.0</code></pre>
<h4 id="例6-2、Java-8中使用lambda表达式的Map和Reduce示例"><a href="#例6-2、Java-8中使用lambda表达式的Map和Reduce示例" class="headerlink" title="例6.2、Java 8中使用lambda表达式的Map和Reduce示例"></a>例6.2、Java 8中使用lambda表达式的Map和Reduce示例</h4><p>在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用 reduce() 方法计算总和。</p>
<pre><code>// 为每个订单加上12%的税
// 老方法：
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
double total = 0;
for (Integer cost : costBeforeTax) &#123;
        double price = cost + .12*cost;
        total = total + price;
&#125;
System.out.println(&quot;Total : &quot; + total);

// 新方法：
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();
System.out.println(&quot;Total : &quot; + bill);</code></pre>
<p>输出：</p>
<pre><code>Total : 1680.0
Total : 1680.0</code></pre>
<h3 id="例7、通过过滤创建一个String列表"><a href="#例7、通过过滤创建一个String列表" class="headerlink" title="例7、通过过滤创建一个String列表"></a>例7、通过过滤创建一个String列表</h3><p>过滤是Java开发者在大规模集合上的一个常用操作，而现在使用lambda表达式和流API过滤大规模数据集合是惊人的简单。流提供了一个 filter() 方法，接受一个 Predicate 对象，即可以传入一个lambda表达式作为过滤逻辑。下面的例子是用lambda表达式过滤Java集合，将帮助理解。</p>
<pre><code>// 创建一个字符串列表，每个字符串长度大于2
List&lt;String&gt; filtered = strList.stream().filter(x -&gt; x.length()&gt; 2).collect(Collectors.toList());
System.out.printf(&quot;Original List : %s, filtered list : %s %n&quot;, strList, filtered);</code></pre>
<p>输出：</p>
<pre><code>Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]</code></pre>
<p>另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。</p>
<h3 id="例8、对列表的每个元素应用函数"><a href="#例8、对列表的每个元素应用函数" class="headerlink" title="例8、对列表的每个元素应用函数"></a>例8、对列表的每个元素应用函数</h3><p>我们通常需要对列表的每个元素使用某个函数，例如逐一乘以某个数、除以某个数或者做其它操作。这些操作都很适合用 map() 方法，可以将转换逻辑以lambda表达式的形式放在 map() 方法里，就可以对集合的各个元素进行转换了，如下所示。</p>
<pre><code>// 将字符串换成大写并用逗号链接起来
List&lt;String&gt; G7 = Arrays.asList(&quot;USA&quot;, &quot;Japan&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, &quot;U.K.&quot;,&quot;Canada&quot;);
String G7Countries = G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(&quot;, &quot;));
System.out.println(G7Countries);</code></pre>
<p>输出：</p>
<pre><code>USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA</code></pre>
<h3 id="例9、复制不同的值，创建一个子列表"><a href="#例9、复制不同的值，创建一个子列表" class="headerlink" title="例9、复制不同的值，创建一个子列表"></a>例9、复制不同的值，创建一个子列表</h3><p>本例展示了如何利用流的 distinct() 方法来对集合进行去重。</p>
<pre><code>// 用所有不同的数字创建一个正方形列表
List&lt;Integer&gt; numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);
List&lt;Integer&gt; distinct = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());
System.out.printf(&quot;Original List : %s,  Square Without duplicates : %s %n&quot;, numbers, distinct);</code></pre>
<p>输出：</p>
<pre><code>Original List : [9, 10, 3, 4, 7, 3, 4],  Square Without duplicates : [81, 100, 9, 16, 49]</code></pre>
<h3 id="例10、计算集合元素的最大值、最小值、总和以及平均值"><a href="#例10、计算集合元素的最大值、最小值、总和以及平均值" class="headerlink" title="例10、计算集合元素的最大值、最小值、总和以及平均值"></a>例10、计算集合元素的最大值、最小值、总和以及平均值</h3><p>IntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage() 方法来获得列表的所有元素的总和及平均值。</p>
<pre><code>//获取数字的个数、最小值、最大值、总和以及平均值
List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);
IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();
System.out.println(&quot;Highest prime number in List : &quot; + stats.getMax());
System.out.println(&quot;Lowest prime number in List : &quot; + stats.getMin());
System.out.println(&quot;Sum of all prime numbers : &quot; + stats.getSum());
System.out.println(&quot;Average of all prime numbers : &quot; + stats.getAverage());</code></pre>
<p>输出：</p>
<pre><code>Highest prime number in List : 29
Lowest prime number in List : 2
Sum of all prime numbers : 129
Average of all prime numbers : 12.9</code></pre>
<h3 id="Lambda表达式-vs-匿名类"><a href="#Lambda表达式-vs-匿名类" class="headerlink" title="Lambda表达式 vs 匿名类"></a>Lambda表达式 vs 匿名类</h3><p>既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法。</p>
<h3 id="Java-8-Lambda表达式要点"><a href="#Java-8-Lambda表达式要点" class="headerlink" title="Java 8 Lambda表达式要点"></a>Java 8 Lambda表达式要点</h3><h4 id="10个Java-lambda表达式、流API示例"><a href="#10个Java-lambda表达式、流API示例" class="headerlink" title="10个Java lambda表达式、流API示例"></a>10个Java lambda表达式、流API示例</h4><p>到目前为止我们看到了Java 8的10个lambda表达式，这对于新手来说是个合适的任务量，你可能需要亲自运行示例程序以便掌握。试着修改要求创建自己的例子，达到快速学习的目的。我还想建议大家使用Netbeans IDE来练习lambda表达式，它对Java 8支持良好。当把代码转换成函数式的时候，Netbeans会及时给你提示。只需跟着Netbeans的提示，就能很容易地把匿名类转换成lambda表达式。此外，如果你喜欢阅读，那么记得看一下Java 8的lambdas，实用函数式编程这本书（<a target="_blank" rel="noopener" href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/B00OVMRHPO/ref=sr_1_3?ie=UTF8&qid=1438567374&sr=8-3&keywords=Java+8+Lambdas,+pragmatic+functional+programming">Java 8 Lambdas, pragmatic functional programming</a>），作者是Richard Warburton，或者也可以看看Manning的Java 8实战（<a target="_blank" rel="noopener" href="http://www.amazon.com/Java-Action-Lambdas-functional-style-programming/dp/1617291994/ref=sr_1_1?ie=UTF8&qid=1438567348&sr=8-1&keywords=Java+8+in+Action">Java 8 in Action</a>），这本书虽然还没出版，但我猜线上有第一章的免费pdf。不过，在你开始忙其它事情之前，先回顾一下Java 8的lambda表达式、默认方法和函数式接口的重点知识。</p>
<p>1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。</p>
<p>2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。</p>
<pre><code>list.forEach(n -&gt; System.out.println(n)); 
list.forEach(System.out::println);  // 使用方法引用</code></pre>
<p>然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：</p>
<pre><code>list.forEach((String s) -&gt; System.out.println(&quot;*&quot; + s + &quot;*&quot;));</code></pre>
<p>事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。</p>
<p>3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</p>
<p>4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。</p>
<p>5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：</p>
<pre><code>private static java.lang.Object lambda$0(java.lang.String);</code></pre>
<p>6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。</p>
<pre><code>List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);
int factor = 2;
primes.forEach(element -&gt; &#123; factor++; &#125;);


Compile time error : &quot;local variables referenced from a lambda expression must be final or effectively final&quot;</code></pre>
<p>另外，只是访问它而不作修改是可以的，如下所示：</p>
<pre><code>List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);
int factor = 2;
primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);</code></pre>
<p>输出：</p>
<pre><code>4
6
10
14</code></pre>
<p>因此，它看起来更像不可变闭包，类似于Python。</p>
<p>以上就是Java 8的lambda表达式的全部10个例子。此次修改将成为Java史上最大的一次，将深远影响未来Java开发者使用集合框架的方式。我想规模最相似的一次修改就是Java 5的发布了，它带来了很多优点，提升了代码质量，例如：泛型、枚举、自动装箱（Autoboxing）、静态导入、并发API和变量参数。上述特性使得Java代码更加清晰，我想lambda表达式也将进一步改进它。我在期待着开发并行第三方库，这可以使高性能应用变得更容易写。</p>
<p>更多阅读：<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc">http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc</a></p>
<p>原文链接： <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html">javarevisited</a> 翻译： <a target="_blank" rel="noopener" href="http://www.importnew.com/">ImportNew.com</a> - <a target="_blank" rel="noopener" href="http://www.importnew.com/author/lemeilleur">lemeilleur</a><br>译文链接： <a target="_blank" rel="noopener" href="http://www.importnew.com/16436.html">http://www.importnew.com/16436.html</a></p>
<p>[ <strong>转载请保留原文出处、译者和译文链接。</strong>]</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/util/gradle/LearnGradle_3_Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/util/gradle/LearnGradle_3_Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html" class="post-title-link" itemprop="url">Learn Gradle - 3 Java 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-28T00:00:00+00:00">2017-10-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Gradle/" itemprop="url" rel="index"><span itemprop="name">Gradle</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一节主要对Gradle的脚本进行了简要的介绍，本节将继续学习Gradle的另外一个特性——插件（plugins）。</p>
<h2 id="1、插件介绍"><a href="#1、插件介绍" class="headerlink" title="1、插件介绍"></a>1、插件介绍</h2><p>插件是对Gradle功能的扩展，Gradle有着丰富的插件，你可以在这里搜索相关插件（<a target="_blank" rel="noopener" href="https://plugins.gradle.org/">传送门</a>）。本章将简要介绍Gradle的Java插件（Java plugin），这个插件会给你的构建项目添加一些任务，比如编译java类、执行单元测试和将编译的class文件打包成jar文件等。</p>
<p>Java插件是基于约定的（约定优于配置），它在项目的很多方面定义了默认值，例如，Java源文件应该位于什么位置。我们只要遵循插件的约定，就不需要在Gradle配置脚本进行额外的相关配置。当然，在某些情况下，你的项目不想或不能遵循这个约定也是可以的，这样你就需要额外的配置你的构建脚本。</p>
<p>Gradle Java插件对于项目文件存放的默认位置与maven类似。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/util/gradle/LearnGradle_3_Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fenxiangz.com/post/util/gradle/LearnGradle_2_%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%E4%BB%8B%E7%BB%8D.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hassan">
      <meta itemprop="description" content="Share everything">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享之">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/util/gradle/LearnGradle_2_%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%E4%BB%8B%E7%BB%8D.html" class="post-title-link" itemprop="url">Learn Gradle - 2 基本的构建脚本介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-27T00:00:00+00:00">2017-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-20 16:47:02" itemprop="dateModified" datetime="2020-12-20T16:47:02+00:00">2020-12-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Gradle/" itemprop="url" rel="index"><span itemprop="name">Gradle</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、项目和任务"><a href="#1、项目和任务" class="headerlink" title="1、项目和任务"></a>1、项目和任务</h2><p>Gradle 构建脚本包括两个最基本的概念，就是项目（projects）和任务（tasks）。</p>
<p>项目是指我们的构建产物（比如jar包）或实施产物（比如web application等）。<strong>Gradle构建脚本包含一个或多个项目。</strong></p>
<p>任务是指不可分的最小工作单元，执行构建工作（比如编译一些类文件、创建jar文件、生成javadoc以及发布架构文档到仓库等）。<strong>一个项目包含一个或多个任务。</strong></p>
<h2 id="2、Hello-World！！"><a href="#2、Hello-World！！" class="headerlink" title="2、Hello World！！"></a>2、Hello World！！</h2><p>下面我们学习一个简单的hello world例子来简单认识一下Gradle构建脚本。</p>
<p>新建文件：build.gradle </p>
<p>添加内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令行进入build.gradle所在目录，执行：gradle hello ，输出：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/util/gradle/LearnGradle_2_%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%E4%BB%8B%E7%BB%8D.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hassan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
